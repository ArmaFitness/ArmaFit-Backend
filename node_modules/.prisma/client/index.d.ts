
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model User
 * 
 */
export type User = {
  id: number
  email: string
  passwordHash: string
  fullName: string
  role: Role
  createdAt: Date
  updatedAt: Date
}

/**
 * Model AthleteCoach
 * 
 */
export type AthleteCoach = {
  id: number
  coachId: number
  athleteId: number
}

/**
 * Model WorkoutPlan
 * 
 */
export type WorkoutPlan = {
  id: number
  title: string
  description: string | null
  createdAt: Date
  updatedAt: Date
  creatorId: number
  assignedToId: number | null
}

/**
 * Model Exercise
 * 
 */
export type Exercise = {
  id: number
  name: string
  description: string | null
  createdAt: Date
}

/**
 * Model WorkoutPlanExercise
 * 
 */
export type WorkoutPlanExercise = {
  id: number
  planId: number
  exerciseId: number
  orderIndex: number
}

/**
 * Model WorkoutSession
 * 
 */
export type WorkoutSession = {
  id: number
  athleteId: number
  planId: number
  date: Date
}

/**
 * Model WorkoutSessionExercise
 * 
 */
export type WorkoutSessionExercise = {
  id: number
  sessionId: number
  exerciseId: number
  orderIndex: number
}

/**
 * Model WorkoutSessionSet
 * 
 */
export type WorkoutSessionSet = {
  id: number
  sessionExerciseId: number
  setIndex: number
  reps: number
  weightKg: number
  rpe: number | null
  notes: string | null
}

/**
 * Model Workout
 * 
 */
export type Workout = {
  id: number
  date: Date
  durationMinutes: number
  notes: string | null
  createdAt: Date
  athleteId: number
  workoutPlanId: number | null
}

/**
 * Model WorkoutExercise
 * 
 */
export type WorkoutExercise = {
  id: number
  workoutId: number
  exerciseId: number
  orderIndex: number
  notes: string | null
}

/**
 * Model WorkoutSet
 * 
 */
export type WorkoutSet = {
  id: number
  workoutExerciseId: number
  setIndex: number
  reps: number
  weightKg: number
  rpe: number | null
  notes: string | null
}

/**
 * Model Weight
 * 
 */
export type Weight = {
  id: number
  weightKg: number
  date: Date
  createdAt: Date
  athleteId: number
}

/**
 * Model Message
 * 
 */
export type Message = {
  id: number
  senderId: number
  receiverId: number
  content: string
  createdAt: Date
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const Role: {
  athlete: 'athlete',
  coach: 'coach'
};

export type Role = (typeof Role)[keyof typeof Role]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

  /**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;


      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.athleteCoach`: Exposes CRUD operations for the **AthleteCoach** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AthleteCoaches
    * const athleteCoaches = await prisma.athleteCoach.findMany()
    * ```
    */
  get athleteCoach(): Prisma.AthleteCoachDelegate<GlobalReject>;

  /**
   * `prisma.workoutPlan`: Exposes CRUD operations for the **WorkoutPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkoutPlans
    * const workoutPlans = await prisma.workoutPlan.findMany()
    * ```
    */
  get workoutPlan(): Prisma.WorkoutPlanDelegate<GlobalReject>;

  /**
   * `prisma.exercise`: Exposes CRUD operations for the **Exercise** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exercises
    * const exercises = await prisma.exercise.findMany()
    * ```
    */
  get exercise(): Prisma.ExerciseDelegate<GlobalReject>;

  /**
   * `prisma.workoutPlanExercise`: Exposes CRUD operations for the **WorkoutPlanExercise** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkoutPlanExercises
    * const workoutPlanExercises = await prisma.workoutPlanExercise.findMany()
    * ```
    */
  get workoutPlanExercise(): Prisma.WorkoutPlanExerciseDelegate<GlobalReject>;

  /**
   * `prisma.workoutSession`: Exposes CRUD operations for the **WorkoutSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkoutSessions
    * const workoutSessions = await prisma.workoutSession.findMany()
    * ```
    */
  get workoutSession(): Prisma.WorkoutSessionDelegate<GlobalReject>;

  /**
   * `prisma.workoutSessionExercise`: Exposes CRUD operations for the **WorkoutSessionExercise** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkoutSessionExercises
    * const workoutSessionExercises = await prisma.workoutSessionExercise.findMany()
    * ```
    */
  get workoutSessionExercise(): Prisma.WorkoutSessionExerciseDelegate<GlobalReject>;

  /**
   * `prisma.workoutSessionSet`: Exposes CRUD operations for the **WorkoutSessionSet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkoutSessionSets
    * const workoutSessionSets = await prisma.workoutSessionSet.findMany()
    * ```
    */
  get workoutSessionSet(): Prisma.WorkoutSessionSetDelegate<GlobalReject>;

  /**
   * `prisma.workout`: Exposes CRUD operations for the **Workout** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workouts
    * const workouts = await prisma.workout.findMany()
    * ```
    */
  get workout(): Prisma.WorkoutDelegate<GlobalReject>;

  /**
   * `prisma.workoutExercise`: Exposes CRUD operations for the **WorkoutExercise** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkoutExercises
    * const workoutExercises = await prisma.workoutExercise.findMany()
    * ```
    */
  get workoutExercise(): Prisma.WorkoutExerciseDelegate<GlobalReject>;

  /**
   * `prisma.workoutSet`: Exposes CRUD operations for the **WorkoutSet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkoutSets
    * const workoutSets = await prisma.workoutSet.findMany()
    * ```
    */
  get workoutSet(): Prisma.WorkoutSetDelegate<GlobalReject>;

  /**
   * `prisma.weight`: Exposes CRUD operations for the **Weight** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Weights
    * const weights = await prisma.weight.findMany()
    * ```
    */
  get weight(): Prisma.WeightDelegate<GlobalReject>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 3.8.1
   * Query Engine version: 34df67547cf5598f5a6cd3eb45f14ee70c3fb86f
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: 'DbNull'

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: 'JsonNull'

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: 'AnyNull'

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    User: 'User',
    AthleteCoach: 'AthleteCoach',
    WorkoutPlan: 'WorkoutPlan',
    Exercise: 'Exercise',
    WorkoutPlanExercise: 'WorkoutPlanExercise',
    WorkoutSession: 'WorkoutSession',
    WorkoutSessionExercise: 'WorkoutSessionExercise',
    WorkoutSessionSet: 'WorkoutSessionSet',
    Workout: 'Workout',
    WorkoutExercise: 'WorkoutExercise',
    WorkoutSet: 'WorkoutSet',
    Weight: 'Weight',
    Message: 'Message'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends boolean
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    createdWorkoutPlans: number
    assignedWorkoutPlans: number
    workouts: number
    weights: number
    coachLinks: number
    athleteLinks: number
    SentMessages: number
    ReceivedMessages: number
    workoutSessions: number
  }

  export type UserCountOutputTypeSelect = {
    createdWorkoutPlans?: boolean
    assignedWorkoutPlans?: boolean
    workouts?: boolean
    weights?: boolean
    coachLinks?: boolean
    athleteLinks?: boolean
    SentMessages?: boolean
    ReceivedMessages?: boolean
    workoutSessions?: boolean
  }

  export type UserCountOutputTypeGetPayload<
    S extends boolean | null | undefined | UserCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? UserCountOutputType
    : S extends undefined
    ? never
    : S extends UserCountOutputTypeArgs
    ?'include' extends U
    ? UserCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof UserCountOutputType ?UserCountOutputType [P]
  : 
     never
  } 
    : UserCountOutputType
  : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     * 
    **/
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type WorkoutPlanCountOutputType
   */


  export type WorkoutPlanCountOutputType = {
    exercises: number
    sessions: number
    workouts: number
  }

  export type WorkoutPlanCountOutputTypeSelect = {
    exercises?: boolean
    sessions?: boolean
    workouts?: boolean
  }

  export type WorkoutPlanCountOutputTypeGetPayload<
    S extends boolean | null | undefined | WorkoutPlanCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? WorkoutPlanCountOutputType
    : S extends undefined
    ? never
    : S extends WorkoutPlanCountOutputTypeArgs
    ?'include' extends U
    ? WorkoutPlanCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof WorkoutPlanCountOutputType ?WorkoutPlanCountOutputType [P]
  : 
     never
  } 
    : WorkoutPlanCountOutputType
  : WorkoutPlanCountOutputType




  // Custom InputTypes

  /**
   * WorkoutPlanCountOutputType without action
   */
  export type WorkoutPlanCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the WorkoutPlanCountOutputType
     * 
    **/
    select?: WorkoutPlanCountOutputTypeSelect | null
  }



  /**
   * Count Type ExerciseCountOutputType
   */


  export type ExerciseCountOutputType = {
    workoutExercises: number
    planExercises: number
    sessionExercises: number
  }

  export type ExerciseCountOutputTypeSelect = {
    workoutExercises?: boolean
    planExercises?: boolean
    sessionExercises?: boolean
  }

  export type ExerciseCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ExerciseCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ExerciseCountOutputType
    : S extends undefined
    ? never
    : S extends ExerciseCountOutputTypeArgs
    ?'include' extends U
    ? ExerciseCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ExerciseCountOutputType ?ExerciseCountOutputType [P]
  : 
     never
  } 
    : ExerciseCountOutputType
  : ExerciseCountOutputType




  // Custom InputTypes

  /**
   * ExerciseCountOutputType without action
   */
  export type ExerciseCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ExerciseCountOutputType
     * 
    **/
    select?: ExerciseCountOutputTypeSelect | null
  }



  /**
   * Count Type WorkoutSessionCountOutputType
   */


  export type WorkoutSessionCountOutputType = {
    sessionExercises: number
  }

  export type WorkoutSessionCountOutputTypeSelect = {
    sessionExercises?: boolean
  }

  export type WorkoutSessionCountOutputTypeGetPayload<
    S extends boolean | null | undefined | WorkoutSessionCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? WorkoutSessionCountOutputType
    : S extends undefined
    ? never
    : S extends WorkoutSessionCountOutputTypeArgs
    ?'include' extends U
    ? WorkoutSessionCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof WorkoutSessionCountOutputType ?WorkoutSessionCountOutputType [P]
  : 
     never
  } 
    : WorkoutSessionCountOutputType
  : WorkoutSessionCountOutputType




  // Custom InputTypes

  /**
   * WorkoutSessionCountOutputType without action
   */
  export type WorkoutSessionCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the WorkoutSessionCountOutputType
     * 
    **/
    select?: WorkoutSessionCountOutputTypeSelect | null
  }



  /**
   * Count Type WorkoutSessionExerciseCountOutputType
   */


  export type WorkoutSessionExerciseCountOutputType = {
    sets: number
  }

  export type WorkoutSessionExerciseCountOutputTypeSelect = {
    sets?: boolean
  }

  export type WorkoutSessionExerciseCountOutputTypeGetPayload<
    S extends boolean | null | undefined | WorkoutSessionExerciseCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? WorkoutSessionExerciseCountOutputType
    : S extends undefined
    ? never
    : S extends WorkoutSessionExerciseCountOutputTypeArgs
    ?'include' extends U
    ? WorkoutSessionExerciseCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof WorkoutSessionExerciseCountOutputType ?WorkoutSessionExerciseCountOutputType [P]
  : 
     never
  } 
    : WorkoutSessionExerciseCountOutputType
  : WorkoutSessionExerciseCountOutputType




  // Custom InputTypes

  /**
   * WorkoutSessionExerciseCountOutputType without action
   */
  export type WorkoutSessionExerciseCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the WorkoutSessionExerciseCountOutputType
     * 
    **/
    select?: WorkoutSessionExerciseCountOutputTypeSelect | null
  }



  /**
   * Count Type WorkoutCountOutputType
   */


  export type WorkoutCountOutputType = {
    workoutExercises: number
  }

  export type WorkoutCountOutputTypeSelect = {
    workoutExercises?: boolean
  }

  export type WorkoutCountOutputTypeGetPayload<
    S extends boolean | null | undefined | WorkoutCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? WorkoutCountOutputType
    : S extends undefined
    ? never
    : S extends WorkoutCountOutputTypeArgs
    ?'include' extends U
    ? WorkoutCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof WorkoutCountOutputType ?WorkoutCountOutputType [P]
  : 
     never
  } 
    : WorkoutCountOutputType
  : WorkoutCountOutputType




  // Custom InputTypes

  /**
   * WorkoutCountOutputType without action
   */
  export type WorkoutCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the WorkoutCountOutputType
     * 
    **/
    select?: WorkoutCountOutputTypeSelect | null
  }



  /**
   * Count Type WorkoutExerciseCountOutputType
   */


  export type WorkoutExerciseCountOutputType = {
    sets: number
  }

  export type WorkoutExerciseCountOutputTypeSelect = {
    sets?: boolean
  }

  export type WorkoutExerciseCountOutputTypeGetPayload<
    S extends boolean | null | undefined | WorkoutExerciseCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? WorkoutExerciseCountOutputType
    : S extends undefined
    ? never
    : S extends WorkoutExerciseCountOutputTypeArgs
    ?'include' extends U
    ? WorkoutExerciseCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof WorkoutExerciseCountOutputType ?WorkoutExerciseCountOutputType [P]
  : 
     never
  } 
    : WorkoutExerciseCountOutputType
  : WorkoutExerciseCountOutputType




  // Custom InputTypes

  /**
   * WorkoutExerciseCountOutputType without action
   */
  export type WorkoutExerciseCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the WorkoutExerciseCountOutputType
     * 
    **/
    select?: WorkoutExerciseCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    passwordHash: string | null
    fullName: string | null
    role: Role | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    passwordHash: string | null
    fullName: string | null
    role: Role | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    fullName: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    fullName?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    fullName?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    fullName?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: Array<UserScalarFieldEnum>
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: number
    email: string
    passwordHash: string
    fullName: string
    role: Role
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Promise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    fullName?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdWorkoutPlans?: boolean | WorkoutPlanFindManyArgs
    assignedWorkoutPlans?: boolean | WorkoutPlanFindManyArgs
    workouts?: boolean | WorkoutFindManyArgs
    weights?: boolean | WeightFindManyArgs
    coachLinks?: boolean | AthleteCoachFindManyArgs
    athleteLinks?: boolean | AthleteCoachFindManyArgs
    SentMessages?: boolean | MessageFindManyArgs
    ReceivedMessages?: boolean | MessageFindManyArgs
    workoutSessions?: boolean | WorkoutSessionFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserInclude = {
    createdWorkoutPlans?: boolean | WorkoutPlanFindManyArgs
    assignedWorkoutPlans?: boolean | WorkoutPlanFindManyArgs
    workouts?: boolean | WorkoutFindManyArgs
    weights?: boolean | WeightFindManyArgs
    coachLinks?: boolean | AthleteCoachFindManyArgs
    athleteLinks?: boolean | AthleteCoachFindManyArgs
    SentMessages?: boolean | MessageFindManyArgs
    ReceivedMessages?: boolean | MessageFindManyArgs
    workoutSessions?: boolean | WorkoutSessionFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserGetPayload<
    S extends boolean | null | undefined | UserArgs,
    U = keyof S
      > = S extends true
        ? User
    : S extends undefined
    ? never
    : S extends UserArgs | UserFindManyArgs
    ?'include' extends U
    ? User  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'createdWorkoutPlans'
        ? Array < WorkoutPlanGetPayload<S['include'][P]>>  :
        P extends 'assignedWorkoutPlans'
        ? Array < WorkoutPlanGetPayload<S['include'][P]>>  :
        P extends 'workouts'
        ? Array < WorkoutGetPayload<S['include'][P]>>  :
        P extends 'weights'
        ? Array < WeightGetPayload<S['include'][P]>>  :
        P extends 'coachLinks'
        ? Array < AthleteCoachGetPayload<S['include'][P]>>  :
        P extends 'athleteLinks'
        ? Array < AthleteCoachGetPayload<S['include'][P]>>  :
        P extends 'SentMessages'
        ? Array < MessageGetPayload<S['include'][P]>>  :
        P extends 'ReceivedMessages'
        ? Array < MessageGetPayload<S['include'][P]>>  :
        P extends 'workoutSessions'
        ? Array < WorkoutSessionGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? UserCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof User ?User [P]
  : 
          P extends 'createdWorkoutPlans'
        ? Array < WorkoutPlanGetPayload<S['select'][P]>>  :
        P extends 'assignedWorkoutPlans'
        ? Array < WorkoutPlanGetPayload<S['select'][P]>>  :
        P extends 'workouts'
        ? Array < WorkoutGetPayload<S['select'][P]>>  :
        P extends 'weights'
        ? Array < WeightGetPayload<S['select'][P]>>  :
        P extends 'coachLinks'
        ? Array < AthleteCoachGetPayload<S['select'][P]>>  :
        P extends 'athleteLinks'
        ? Array < AthleteCoachGetPayload<S['select'][P]>>  :
        P extends 'SentMessages'
        ? Array < MessageGetPayload<S['select'][P]>>  :
        P extends 'ReceivedMessages'
        ? Array < MessageGetPayload<S['select'][P]>>  :
        P extends 'workoutSessions'
        ? Array < WorkoutSessionGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? UserCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : User
  : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    createdWorkoutPlans<T extends WorkoutPlanFindManyArgs = {}>(args?: Subset<T, WorkoutPlanFindManyArgs>): CheckSelect<T, PrismaPromise<Array<WorkoutPlan>>, PrismaPromise<Array<WorkoutPlanGetPayload<T>>>>;

    assignedWorkoutPlans<T extends WorkoutPlanFindManyArgs = {}>(args?: Subset<T, WorkoutPlanFindManyArgs>): CheckSelect<T, PrismaPromise<Array<WorkoutPlan>>, PrismaPromise<Array<WorkoutPlanGetPayload<T>>>>;

    workouts<T extends WorkoutFindManyArgs = {}>(args?: Subset<T, WorkoutFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Workout>>, PrismaPromise<Array<WorkoutGetPayload<T>>>>;

    weights<T extends WeightFindManyArgs = {}>(args?: Subset<T, WeightFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Weight>>, PrismaPromise<Array<WeightGetPayload<T>>>>;

    coachLinks<T extends AthleteCoachFindManyArgs = {}>(args?: Subset<T, AthleteCoachFindManyArgs>): CheckSelect<T, PrismaPromise<Array<AthleteCoach>>, PrismaPromise<Array<AthleteCoachGetPayload<T>>>>;

    athleteLinks<T extends AthleteCoachFindManyArgs = {}>(args?: Subset<T, AthleteCoachFindManyArgs>): CheckSelect<T, PrismaPromise<Array<AthleteCoach>>, PrismaPromise<Array<AthleteCoachGetPayload<T>>>>;

    SentMessages<T extends MessageFindManyArgs = {}>(args?: Subset<T, MessageFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Message>>, PrismaPromise<Array<MessageGetPayload<T>>>>;

    ReceivedMessages<T extends MessageFindManyArgs = {}>(args?: Subset<T, MessageFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Message>>, PrismaPromise<Array<MessageGetPayload<T>>>>;

    workoutSessions<T extends WorkoutSessionFindManyArgs = {}>(args?: Subset<T, WorkoutSessionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<WorkoutSession>>, PrismaPromise<Array<WorkoutSessionGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     * 
    **/
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     * 
    **/
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     * 
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     * 
    **/
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    where?: UserWhereInput
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
  }



  /**
   * Model AthleteCoach
   */


  export type AggregateAthleteCoach = {
    _count: AthleteCoachCountAggregateOutputType | null
    _avg: AthleteCoachAvgAggregateOutputType | null
    _sum: AthleteCoachSumAggregateOutputType | null
    _min: AthleteCoachMinAggregateOutputType | null
    _max: AthleteCoachMaxAggregateOutputType | null
  }

  export type AthleteCoachAvgAggregateOutputType = {
    id: number | null
    coachId: number | null
    athleteId: number | null
  }

  export type AthleteCoachSumAggregateOutputType = {
    id: number | null
    coachId: number | null
    athleteId: number | null
  }

  export type AthleteCoachMinAggregateOutputType = {
    id: number | null
    coachId: number | null
    athleteId: number | null
  }

  export type AthleteCoachMaxAggregateOutputType = {
    id: number | null
    coachId: number | null
    athleteId: number | null
  }

  export type AthleteCoachCountAggregateOutputType = {
    id: number
    coachId: number
    athleteId: number
    _all: number
  }


  export type AthleteCoachAvgAggregateInputType = {
    id?: true
    coachId?: true
    athleteId?: true
  }

  export type AthleteCoachSumAggregateInputType = {
    id?: true
    coachId?: true
    athleteId?: true
  }

  export type AthleteCoachMinAggregateInputType = {
    id?: true
    coachId?: true
    athleteId?: true
  }

  export type AthleteCoachMaxAggregateInputType = {
    id?: true
    coachId?: true
    athleteId?: true
  }

  export type AthleteCoachCountAggregateInputType = {
    id?: true
    coachId?: true
    athleteId?: true
    _all?: true
  }

  export type AthleteCoachAggregateArgs = {
    /**
     * Filter which AthleteCoach to aggregate.
     * 
    **/
    where?: AthleteCoachWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AthleteCoaches to fetch.
     * 
    **/
    orderBy?: Enumerable<AthleteCoachOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AthleteCoachWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AthleteCoaches from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AthleteCoaches.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AthleteCoaches
    **/
    _count?: true | AthleteCoachCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AthleteCoachAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AthleteCoachSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AthleteCoachMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AthleteCoachMaxAggregateInputType
  }

  export type GetAthleteCoachAggregateType<T extends AthleteCoachAggregateArgs> = {
        [P in keyof T & keyof AggregateAthleteCoach]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAthleteCoach[P]>
      : GetScalarType<T[P], AggregateAthleteCoach[P]>
  }




  export type AthleteCoachGroupByArgs = {
    where?: AthleteCoachWhereInput
    orderBy?: Enumerable<AthleteCoachOrderByWithAggregationInput>
    by: Array<AthleteCoachScalarFieldEnum>
    having?: AthleteCoachScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AthleteCoachCountAggregateInputType | true
    _avg?: AthleteCoachAvgAggregateInputType
    _sum?: AthleteCoachSumAggregateInputType
    _min?: AthleteCoachMinAggregateInputType
    _max?: AthleteCoachMaxAggregateInputType
  }


  export type AthleteCoachGroupByOutputType = {
    id: number
    coachId: number
    athleteId: number
    _count: AthleteCoachCountAggregateOutputType | null
    _avg: AthleteCoachAvgAggregateOutputType | null
    _sum: AthleteCoachSumAggregateOutputType | null
    _min: AthleteCoachMinAggregateOutputType | null
    _max: AthleteCoachMaxAggregateOutputType | null
  }

  type GetAthleteCoachGroupByPayload<T extends AthleteCoachGroupByArgs> = Promise<
    Array<
      PickArray<AthleteCoachGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AthleteCoachGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AthleteCoachGroupByOutputType[P]>
            : GetScalarType<T[P], AthleteCoachGroupByOutputType[P]>
        }
      >
    >


  export type AthleteCoachSelect = {
    id?: boolean
    coachId?: boolean
    athleteId?: boolean
    coach?: boolean | UserArgs
    athlete?: boolean | UserArgs
  }

  export type AthleteCoachInclude = {
    coach?: boolean | UserArgs
    athlete?: boolean | UserArgs
  }

  export type AthleteCoachGetPayload<
    S extends boolean | null | undefined | AthleteCoachArgs,
    U = keyof S
      > = S extends true
        ? AthleteCoach
    : S extends undefined
    ? never
    : S extends AthleteCoachArgs | AthleteCoachFindManyArgs
    ?'include' extends U
    ? AthleteCoach  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'coach'
        ? UserGetPayload<S['include'][P]> :
        P extends 'athlete'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof AthleteCoach ?AthleteCoach [P]
  : 
          P extends 'coach'
        ? UserGetPayload<S['select'][P]> :
        P extends 'athlete'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : AthleteCoach
  : AthleteCoach


  type AthleteCoachCountArgs = Merge<
    Omit<AthleteCoachFindManyArgs, 'select' | 'include'> & {
      select?: AthleteCoachCountAggregateInputType | true
    }
  >

  export interface AthleteCoachDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one AthleteCoach that matches the filter.
     * @param {AthleteCoachFindUniqueArgs} args - Arguments to find a AthleteCoach
     * @example
     * // Get one AthleteCoach
     * const athleteCoach = await prisma.athleteCoach.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AthleteCoachFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AthleteCoachFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AthleteCoach'> extends True ? CheckSelect<T, Prisma__AthleteCoachClient<AthleteCoach>, Prisma__AthleteCoachClient<AthleteCoachGetPayload<T>>> : CheckSelect<T, Prisma__AthleteCoachClient<AthleteCoach | null >, Prisma__AthleteCoachClient<AthleteCoachGetPayload<T> | null >>

    /**
     * Find the first AthleteCoach that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AthleteCoachFindFirstArgs} args - Arguments to find a AthleteCoach
     * @example
     * // Get one AthleteCoach
     * const athleteCoach = await prisma.athleteCoach.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AthleteCoachFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AthleteCoachFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AthleteCoach'> extends True ? CheckSelect<T, Prisma__AthleteCoachClient<AthleteCoach>, Prisma__AthleteCoachClient<AthleteCoachGetPayload<T>>> : CheckSelect<T, Prisma__AthleteCoachClient<AthleteCoach | null >, Prisma__AthleteCoachClient<AthleteCoachGetPayload<T> | null >>

    /**
     * Find zero or more AthleteCoaches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AthleteCoachFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AthleteCoaches
     * const athleteCoaches = await prisma.athleteCoach.findMany()
     * 
     * // Get first 10 AthleteCoaches
     * const athleteCoaches = await prisma.athleteCoach.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const athleteCoachWithIdOnly = await prisma.athleteCoach.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AthleteCoachFindManyArgs>(
      args?: SelectSubset<T, AthleteCoachFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<AthleteCoach>>, PrismaPromise<Array<AthleteCoachGetPayload<T>>>>

    /**
     * Create a AthleteCoach.
     * @param {AthleteCoachCreateArgs} args - Arguments to create a AthleteCoach.
     * @example
     * // Create one AthleteCoach
     * const AthleteCoach = await prisma.athleteCoach.create({
     *   data: {
     *     // ... data to create a AthleteCoach
     *   }
     * })
     * 
    **/
    create<T extends AthleteCoachCreateArgs>(
      args: SelectSubset<T, AthleteCoachCreateArgs>
    ): CheckSelect<T, Prisma__AthleteCoachClient<AthleteCoach>, Prisma__AthleteCoachClient<AthleteCoachGetPayload<T>>>

    /**
     * Create many AthleteCoaches.
     *     @param {AthleteCoachCreateManyArgs} args - Arguments to create many AthleteCoaches.
     *     @example
     *     // Create many AthleteCoaches
     *     const athleteCoach = await prisma.athleteCoach.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AthleteCoachCreateManyArgs>(
      args?: SelectSubset<T, AthleteCoachCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a AthleteCoach.
     * @param {AthleteCoachDeleteArgs} args - Arguments to delete one AthleteCoach.
     * @example
     * // Delete one AthleteCoach
     * const AthleteCoach = await prisma.athleteCoach.delete({
     *   where: {
     *     // ... filter to delete one AthleteCoach
     *   }
     * })
     * 
    **/
    delete<T extends AthleteCoachDeleteArgs>(
      args: SelectSubset<T, AthleteCoachDeleteArgs>
    ): CheckSelect<T, Prisma__AthleteCoachClient<AthleteCoach>, Prisma__AthleteCoachClient<AthleteCoachGetPayload<T>>>

    /**
     * Update one AthleteCoach.
     * @param {AthleteCoachUpdateArgs} args - Arguments to update one AthleteCoach.
     * @example
     * // Update one AthleteCoach
     * const athleteCoach = await prisma.athleteCoach.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AthleteCoachUpdateArgs>(
      args: SelectSubset<T, AthleteCoachUpdateArgs>
    ): CheckSelect<T, Prisma__AthleteCoachClient<AthleteCoach>, Prisma__AthleteCoachClient<AthleteCoachGetPayload<T>>>

    /**
     * Delete zero or more AthleteCoaches.
     * @param {AthleteCoachDeleteManyArgs} args - Arguments to filter AthleteCoaches to delete.
     * @example
     * // Delete a few AthleteCoaches
     * const { count } = await prisma.athleteCoach.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AthleteCoachDeleteManyArgs>(
      args?: SelectSubset<T, AthleteCoachDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more AthleteCoaches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AthleteCoachUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AthleteCoaches
     * const athleteCoach = await prisma.athleteCoach.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AthleteCoachUpdateManyArgs>(
      args: SelectSubset<T, AthleteCoachUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one AthleteCoach.
     * @param {AthleteCoachUpsertArgs} args - Arguments to update or create a AthleteCoach.
     * @example
     * // Update or create a AthleteCoach
     * const athleteCoach = await prisma.athleteCoach.upsert({
     *   create: {
     *     // ... data to create a AthleteCoach
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AthleteCoach we want to update
     *   }
     * })
    **/
    upsert<T extends AthleteCoachUpsertArgs>(
      args: SelectSubset<T, AthleteCoachUpsertArgs>
    ): CheckSelect<T, Prisma__AthleteCoachClient<AthleteCoach>, Prisma__AthleteCoachClient<AthleteCoachGetPayload<T>>>

    /**
     * Count the number of AthleteCoaches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AthleteCoachCountArgs} args - Arguments to filter AthleteCoaches to count.
     * @example
     * // Count the number of AthleteCoaches
     * const count = await prisma.athleteCoach.count({
     *   where: {
     *     // ... the filter for the AthleteCoaches we want to count
     *   }
     * })
    **/
    count<T extends AthleteCoachCountArgs>(
      args?: Subset<T, AthleteCoachCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AthleteCoachCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AthleteCoach.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AthleteCoachAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AthleteCoachAggregateArgs>(args: Subset<T, AthleteCoachAggregateArgs>): PrismaPromise<GetAthleteCoachAggregateType<T>>

    /**
     * Group by AthleteCoach.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AthleteCoachGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AthleteCoachGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AthleteCoachGroupByArgs['orderBy'] }
        : { orderBy?: AthleteCoachGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AthleteCoachGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAthleteCoachGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for AthleteCoach.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AthleteCoachClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    coach<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    athlete<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * AthleteCoach findUnique
   */
  export type AthleteCoachFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the AthleteCoach
     * 
    **/
    select?: AthleteCoachSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AthleteCoachInclude | null
    /**
     * Throw an Error if a AthleteCoach can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which AthleteCoach to fetch.
     * 
    **/
    where: AthleteCoachWhereUniqueInput
  }


  /**
   * AthleteCoach findFirst
   */
  export type AthleteCoachFindFirstArgs = {
    /**
     * Select specific fields to fetch from the AthleteCoach
     * 
    **/
    select?: AthleteCoachSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AthleteCoachInclude | null
    /**
     * Throw an Error if a AthleteCoach can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which AthleteCoach to fetch.
     * 
    **/
    where?: AthleteCoachWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AthleteCoaches to fetch.
     * 
    **/
    orderBy?: Enumerable<AthleteCoachOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AthleteCoaches.
     * 
    **/
    cursor?: AthleteCoachWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AthleteCoaches from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AthleteCoaches.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AthleteCoaches.
     * 
    **/
    distinct?: Enumerable<AthleteCoachScalarFieldEnum>
  }


  /**
   * AthleteCoach findMany
   */
  export type AthleteCoachFindManyArgs = {
    /**
     * Select specific fields to fetch from the AthleteCoach
     * 
    **/
    select?: AthleteCoachSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AthleteCoachInclude | null
    /**
     * Filter, which AthleteCoaches to fetch.
     * 
    **/
    where?: AthleteCoachWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AthleteCoaches to fetch.
     * 
    **/
    orderBy?: Enumerable<AthleteCoachOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AthleteCoaches.
     * 
    **/
    cursor?: AthleteCoachWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AthleteCoaches from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AthleteCoaches.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AthleteCoachScalarFieldEnum>
  }


  /**
   * AthleteCoach create
   */
  export type AthleteCoachCreateArgs = {
    /**
     * Select specific fields to fetch from the AthleteCoach
     * 
    **/
    select?: AthleteCoachSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AthleteCoachInclude | null
    /**
     * The data needed to create a AthleteCoach.
     * 
    **/
    data: XOR<AthleteCoachCreateInput, AthleteCoachUncheckedCreateInput>
  }


  /**
   * AthleteCoach createMany
   */
  export type AthleteCoachCreateManyArgs = {
    data: Enumerable<AthleteCoachCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AthleteCoach update
   */
  export type AthleteCoachUpdateArgs = {
    /**
     * Select specific fields to fetch from the AthleteCoach
     * 
    **/
    select?: AthleteCoachSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AthleteCoachInclude | null
    /**
     * The data needed to update a AthleteCoach.
     * 
    **/
    data: XOR<AthleteCoachUpdateInput, AthleteCoachUncheckedUpdateInput>
    /**
     * Choose, which AthleteCoach to update.
     * 
    **/
    where: AthleteCoachWhereUniqueInput
  }


  /**
   * AthleteCoach updateMany
   */
  export type AthleteCoachUpdateManyArgs = {
    data: XOR<AthleteCoachUpdateManyMutationInput, AthleteCoachUncheckedUpdateManyInput>
    where?: AthleteCoachWhereInput
  }


  /**
   * AthleteCoach upsert
   */
  export type AthleteCoachUpsertArgs = {
    /**
     * Select specific fields to fetch from the AthleteCoach
     * 
    **/
    select?: AthleteCoachSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AthleteCoachInclude | null
    /**
     * The filter to search for the AthleteCoach to update in case it exists.
     * 
    **/
    where: AthleteCoachWhereUniqueInput
    /**
     * In case the AthleteCoach found by the `where` argument doesn't exist, create a new AthleteCoach with this data.
     * 
    **/
    create: XOR<AthleteCoachCreateInput, AthleteCoachUncheckedCreateInput>
    /**
     * In case the AthleteCoach was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AthleteCoachUpdateInput, AthleteCoachUncheckedUpdateInput>
  }


  /**
   * AthleteCoach delete
   */
  export type AthleteCoachDeleteArgs = {
    /**
     * Select specific fields to fetch from the AthleteCoach
     * 
    **/
    select?: AthleteCoachSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AthleteCoachInclude | null
    /**
     * Filter which AthleteCoach to delete.
     * 
    **/
    where: AthleteCoachWhereUniqueInput
  }


  /**
   * AthleteCoach deleteMany
   */
  export type AthleteCoachDeleteManyArgs = {
    where?: AthleteCoachWhereInput
  }


  /**
   * AthleteCoach without action
   */
  export type AthleteCoachArgs = {
    /**
     * Select specific fields to fetch from the AthleteCoach
     * 
    **/
    select?: AthleteCoachSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AthleteCoachInclude | null
  }



  /**
   * Model WorkoutPlan
   */


  export type AggregateWorkoutPlan = {
    _count: WorkoutPlanCountAggregateOutputType | null
    _avg: WorkoutPlanAvgAggregateOutputType | null
    _sum: WorkoutPlanSumAggregateOutputType | null
    _min: WorkoutPlanMinAggregateOutputType | null
    _max: WorkoutPlanMaxAggregateOutputType | null
  }

  export type WorkoutPlanAvgAggregateOutputType = {
    id: number | null
    creatorId: number | null
    assignedToId: number | null
  }

  export type WorkoutPlanSumAggregateOutputType = {
    id: number | null
    creatorId: number | null
    assignedToId: number | null
  }

  export type WorkoutPlanMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    creatorId: number | null
    assignedToId: number | null
  }

  export type WorkoutPlanMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    creatorId: number | null
    assignedToId: number | null
  }

  export type WorkoutPlanCountAggregateOutputType = {
    id: number
    title: number
    description: number
    createdAt: number
    updatedAt: number
    creatorId: number
    assignedToId: number
    _all: number
  }


  export type WorkoutPlanAvgAggregateInputType = {
    id?: true
    creatorId?: true
    assignedToId?: true
  }

  export type WorkoutPlanSumAggregateInputType = {
    id?: true
    creatorId?: true
    assignedToId?: true
  }

  export type WorkoutPlanMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    creatorId?: true
    assignedToId?: true
  }

  export type WorkoutPlanMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    creatorId?: true
    assignedToId?: true
  }

  export type WorkoutPlanCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    creatorId?: true
    assignedToId?: true
    _all?: true
  }

  export type WorkoutPlanAggregateArgs = {
    /**
     * Filter which WorkoutPlan to aggregate.
     * 
    **/
    where?: WorkoutPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutPlans to fetch.
     * 
    **/
    orderBy?: Enumerable<WorkoutPlanOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: WorkoutPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutPlans from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutPlans.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkoutPlans
    **/
    _count?: true | WorkoutPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkoutPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkoutPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkoutPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkoutPlanMaxAggregateInputType
  }

  export type GetWorkoutPlanAggregateType<T extends WorkoutPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkoutPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkoutPlan[P]>
      : GetScalarType<T[P], AggregateWorkoutPlan[P]>
  }




  export type WorkoutPlanGroupByArgs = {
    where?: WorkoutPlanWhereInput
    orderBy?: Enumerable<WorkoutPlanOrderByWithAggregationInput>
    by: Array<WorkoutPlanScalarFieldEnum>
    having?: WorkoutPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkoutPlanCountAggregateInputType | true
    _avg?: WorkoutPlanAvgAggregateInputType
    _sum?: WorkoutPlanSumAggregateInputType
    _min?: WorkoutPlanMinAggregateInputType
    _max?: WorkoutPlanMaxAggregateInputType
  }


  export type WorkoutPlanGroupByOutputType = {
    id: number
    title: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    creatorId: number
    assignedToId: number | null
    _count: WorkoutPlanCountAggregateOutputType | null
    _avg: WorkoutPlanAvgAggregateOutputType | null
    _sum: WorkoutPlanSumAggregateOutputType | null
    _min: WorkoutPlanMinAggregateOutputType | null
    _max: WorkoutPlanMaxAggregateOutputType | null
  }

  type GetWorkoutPlanGroupByPayload<T extends WorkoutPlanGroupByArgs> = Promise<
    Array<
      PickArray<WorkoutPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkoutPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkoutPlanGroupByOutputType[P]>
            : GetScalarType<T[P], WorkoutPlanGroupByOutputType[P]>
        }
      >
    >


  export type WorkoutPlanSelect = {
    id?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorId?: boolean
    assignedToId?: boolean
    creator?: boolean | UserArgs
    assignedTo?: boolean | UserArgs
    exercises?: boolean | WorkoutPlanExerciseFindManyArgs
    sessions?: boolean | WorkoutSessionFindManyArgs
    workouts?: boolean | WorkoutFindManyArgs
    _count?: boolean | WorkoutPlanCountOutputTypeArgs
  }

  export type WorkoutPlanInclude = {
    creator?: boolean | UserArgs
    assignedTo?: boolean | UserArgs
    exercises?: boolean | WorkoutPlanExerciseFindManyArgs
    sessions?: boolean | WorkoutSessionFindManyArgs
    workouts?: boolean | WorkoutFindManyArgs
    _count?: boolean | WorkoutPlanCountOutputTypeArgs
  }

  export type WorkoutPlanGetPayload<
    S extends boolean | null | undefined | WorkoutPlanArgs,
    U = keyof S
      > = S extends true
        ? WorkoutPlan
    : S extends undefined
    ? never
    : S extends WorkoutPlanArgs | WorkoutPlanFindManyArgs
    ?'include' extends U
    ? WorkoutPlan  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'creator'
        ? UserGetPayload<S['include'][P]> :
        P extends 'assignedTo'
        ? UserGetPayload<S['include'][P]> | null :
        P extends 'exercises'
        ? Array < WorkoutPlanExerciseGetPayload<S['include'][P]>>  :
        P extends 'sessions'
        ? Array < WorkoutSessionGetPayload<S['include'][P]>>  :
        P extends 'workouts'
        ? Array < WorkoutGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? WorkoutPlanCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof WorkoutPlan ?WorkoutPlan [P]
  : 
          P extends 'creator'
        ? UserGetPayload<S['select'][P]> :
        P extends 'assignedTo'
        ? UserGetPayload<S['select'][P]> | null :
        P extends 'exercises'
        ? Array < WorkoutPlanExerciseGetPayload<S['select'][P]>>  :
        P extends 'sessions'
        ? Array < WorkoutSessionGetPayload<S['select'][P]>>  :
        P extends 'workouts'
        ? Array < WorkoutGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? WorkoutPlanCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : WorkoutPlan
  : WorkoutPlan


  type WorkoutPlanCountArgs = Merge<
    Omit<WorkoutPlanFindManyArgs, 'select' | 'include'> & {
      select?: WorkoutPlanCountAggregateInputType | true
    }
  >

  export interface WorkoutPlanDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one WorkoutPlan that matches the filter.
     * @param {WorkoutPlanFindUniqueArgs} args - Arguments to find a WorkoutPlan
     * @example
     * // Get one WorkoutPlan
     * const workoutPlan = await prisma.workoutPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WorkoutPlanFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WorkoutPlanFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'WorkoutPlan'> extends True ? CheckSelect<T, Prisma__WorkoutPlanClient<WorkoutPlan>, Prisma__WorkoutPlanClient<WorkoutPlanGetPayload<T>>> : CheckSelect<T, Prisma__WorkoutPlanClient<WorkoutPlan | null >, Prisma__WorkoutPlanClient<WorkoutPlanGetPayload<T> | null >>

    /**
     * Find the first WorkoutPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutPlanFindFirstArgs} args - Arguments to find a WorkoutPlan
     * @example
     * // Get one WorkoutPlan
     * const workoutPlan = await prisma.workoutPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WorkoutPlanFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WorkoutPlanFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'WorkoutPlan'> extends True ? CheckSelect<T, Prisma__WorkoutPlanClient<WorkoutPlan>, Prisma__WorkoutPlanClient<WorkoutPlanGetPayload<T>>> : CheckSelect<T, Prisma__WorkoutPlanClient<WorkoutPlan | null >, Prisma__WorkoutPlanClient<WorkoutPlanGetPayload<T> | null >>

    /**
     * Find zero or more WorkoutPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutPlanFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkoutPlans
     * const workoutPlans = await prisma.workoutPlan.findMany()
     * 
     * // Get first 10 WorkoutPlans
     * const workoutPlans = await prisma.workoutPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workoutPlanWithIdOnly = await prisma.workoutPlan.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WorkoutPlanFindManyArgs>(
      args?: SelectSubset<T, WorkoutPlanFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<WorkoutPlan>>, PrismaPromise<Array<WorkoutPlanGetPayload<T>>>>

    /**
     * Create a WorkoutPlan.
     * @param {WorkoutPlanCreateArgs} args - Arguments to create a WorkoutPlan.
     * @example
     * // Create one WorkoutPlan
     * const WorkoutPlan = await prisma.workoutPlan.create({
     *   data: {
     *     // ... data to create a WorkoutPlan
     *   }
     * })
     * 
    **/
    create<T extends WorkoutPlanCreateArgs>(
      args: SelectSubset<T, WorkoutPlanCreateArgs>
    ): CheckSelect<T, Prisma__WorkoutPlanClient<WorkoutPlan>, Prisma__WorkoutPlanClient<WorkoutPlanGetPayload<T>>>

    /**
     * Create many WorkoutPlans.
     *     @param {WorkoutPlanCreateManyArgs} args - Arguments to create many WorkoutPlans.
     *     @example
     *     // Create many WorkoutPlans
     *     const workoutPlan = await prisma.workoutPlan.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WorkoutPlanCreateManyArgs>(
      args?: SelectSubset<T, WorkoutPlanCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a WorkoutPlan.
     * @param {WorkoutPlanDeleteArgs} args - Arguments to delete one WorkoutPlan.
     * @example
     * // Delete one WorkoutPlan
     * const WorkoutPlan = await prisma.workoutPlan.delete({
     *   where: {
     *     // ... filter to delete one WorkoutPlan
     *   }
     * })
     * 
    **/
    delete<T extends WorkoutPlanDeleteArgs>(
      args: SelectSubset<T, WorkoutPlanDeleteArgs>
    ): CheckSelect<T, Prisma__WorkoutPlanClient<WorkoutPlan>, Prisma__WorkoutPlanClient<WorkoutPlanGetPayload<T>>>

    /**
     * Update one WorkoutPlan.
     * @param {WorkoutPlanUpdateArgs} args - Arguments to update one WorkoutPlan.
     * @example
     * // Update one WorkoutPlan
     * const workoutPlan = await prisma.workoutPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WorkoutPlanUpdateArgs>(
      args: SelectSubset<T, WorkoutPlanUpdateArgs>
    ): CheckSelect<T, Prisma__WorkoutPlanClient<WorkoutPlan>, Prisma__WorkoutPlanClient<WorkoutPlanGetPayload<T>>>

    /**
     * Delete zero or more WorkoutPlans.
     * @param {WorkoutPlanDeleteManyArgs} args - Arguments to filter WorkoutPlans to delete.
     * @example
     * // Delete a few WorkoutPlans
     * const { count } = await prisma.workoutPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WorkoutPlanDeleteManyArgs>(
      args?: SelectSubset<T, WorkoutPlanDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkoutPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkoutPlans
     * const workoutPlan = await prisma.workoutPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WorkoutPlanUpdateManyArgs>(
      args: SelectSubset<T, WorkoutPlanUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkoutPlan.
     * @param {WorkoutPlanUpsertArgs} args - Arguments to update or create a WorkoutPlan.
     * @example
     * // Update or create a WorkoutPlan
     * const workoutPlan = await prisma.workoutPlan.upsert({
     *   create: {
     *     // ... data to create a WorkoutPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkoutPlan we want to update
     *   }
     * })
    **/
    upsert<T extends WorkoutPlanUpsertArgs>(
      args: SelectSubset<T, WorkoutPlanUpsertArgs>
    ): CheckSelect<T, Prisma__WorkoutPlanClient<WorkoutPlan>, Prisma__WorkoutPlanClient<WorkoutPlanGetPayload<T>>>

    /**
     * Count the number of WorkoutPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutPlanCountArgs} args - Arguments to filter WorkoutPlans to count.
     * @example
     * // Count the number of WorkoutPlans
     * const count = await prisma.workoutPlan.count({
     *   where: {
     *     // ... the filter for the WorkoutPlans we want to count
     *   }
     * })
    **/
    count<T extends WorkoutPlanCountArgs>(
      args?: Subset<T, WorkoutPlanCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkoutPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkoutPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkoutPlanAggregateArgs>(args: Subset<T, WorkoutPlanAggregateArgs>): PrismaPromise<GetWorkoutPlanAggregateType<T>>

    /**
     * Group by WorkoutPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkoutPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkoutPlanGroupByArgs['orderBy'] }
        : { orderBy?: WorkoutPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkoutPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkoutPlanGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkoutPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WorkoutPlanClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    creator<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    assignedTo<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    exercises<T extends WorkoutPlanExerciseFindManyArgs = {}>(args?: Subset<T, WorkoutPlanExerciseFindManyArgs>): CheckSelect<T, PrismaPromise<Array<WorkoutPlanExercise>>, PrismaPromise<Array<WorkoutPlanExerciseGetPayload<T>>>>;

    sessions<T extends WorkoutSessionFindManyArgs = {}>(args?: Subset<T, WorkoutSessionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<WorkoutSession>>, PrismaPromise<Array<WorkoutSessionGetPayload<T>>>>;

    workouts<T extends WorkoutFindManyArgs = {}>(args?: Subset<T, WorkoutFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Workout>>, PrismaPromise<Array<WorkoutGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * WorkoutPlan findUnique
   */
  export type WorkoutPlanFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the WorkoutPlan
     * 
    **/
    select?: WorkoutPlanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutPlanInclude | null
    /**
     * Throw an Error if a WorkoutPlan can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which WorkoutPlan to fetch.
     * 
    **/
    where: WorkoutPlanWhereUniqueInput
  }


  /**
   * WorkoutPlan findFirst
   */
  export type WorkoutPlanFindFirstArgs = {
    /**
     * Select specific fields to fetch from the WorkoutPlan
     * 
    **/
    select?: WorkoutPlanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutPlanInclude | null
    /**
     * Throw an Error if a WorkoutPlan can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which WorkoutPlan to fetch.
     * 
    **/
    where?: WorkoutPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutPlans to fetch.
     * 
    **/
    orderBy?: Enumerable<WorkoutPlanOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkoutPlans.
     * 
    **/
    cursor?: WorkoutPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutPlans from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutPlans.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkoutPlans.
     * 
    **/
    distinct?: Enumerable<WorkoutPlanScalarFieldEnum>
  }


  /**
   * WorkoutPlan findMany
   */
  export type WorkoutPlanFindManyArgs = {
    /**
     * Select specific fields to fetch from the WorkoutPlan
     * 
    **/
    select?: WorkoutPlanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutPlanInclude | null
    /**
     * Filter, which WorkoutPlans to fetch.
     * 
    **/
    where?: WorkoutPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutPlans to fetch.
     * 
    **/
    orderBy?: Enumerable<WorkoutPlanOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkoutPlans.
     * 
    **/
    cursor?: WorkoutPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutPlans from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutPlans.
     * 
    **/
    skip?: number
    distinct?: Enumerable<WorkoutPlanScalarFieldEnum>
  }


  /**
   * WorkoutPlan create
   */
  export type WorkoutPlanCreateArgs = {
    /**
     * Select specific fields to fetch from the WorkoutPlan
     * 
    **/
    select?: WorkoutPlanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutPlanInclude | null
    /**
     * The data needed to create a WorkoutPlan.
     * 
    **/
    data: XOR<WorkoutPlanCreateInput, WorkoutPlanUncheckedCreateInput>
  }


  /**
   * WorkoutPlan createMany
   */
  export type WorkoutPlanCreateManyArgs = {
    data: Enumerable<WorkoutPlanCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * WorkoutPlan update
   */
  export type WorkoutPlanUpdateArgs = {
    /**
     * Select specific fields to fetch from the WorkoutPlan
     * 
    **/
    select?: WorkoutPlanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutPlanInclude | null
    /**
     * The data needed to update a WorkoutPlan.
     * 
    **/
    data: XOR<WorkoutPlanUpdateInput, WorkoutPlanUncheckedUpdateInput>
    /**
     * Choose, which WorkoutPlan to update.
     * 
    **/
    where: WorkoutPlanWhereUniqueInput
  }


  /**
   * WorkoutPlan updateMany
   */
  export type WorkoutPlanUpdateManyArgs = {
    data: XOR<WorkoutPlanUpdateManyMutationInput, WorkoutPlanUncheckedUpdateManyInput>
    where?: WorkoutPlanWhereInput
  }


  /**
   * WorkoutPlan upsert
   */
  export type WorkoutPlanUpsertArgs = {
    /**
     * Select specific fields to fetch from the WorkoutPlan
     * 
    **/
    select?: WorkoutPlanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutPlanInclude | null
    /**
     * The filter to search for the WorkoutPlan to update in case it exists.
     * 
    **/
    where: WorkoutPlanWhereUniqueInput
    /**
     * In case the WorkoutPlan found by the `where` argument doesn't exist, create a new WorkoutPlan with this data.
     * 
    **/
    create: XOR<WorkoutPlanCreateInput, WorkoutPlanUncheckedCreateInput>
    /**
     * In case the WorkoutPlan was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<WorkoutPlanUpdateInput, WorkoutPlanUncheckedUpdateInput>
  }


  /**
   * WorkoutPlan delete
   */
  export type WorkoutPlanDeleteArgs = {
    /**
     * Select specific fields to fetch from the WorkoutPlan
     * 
    **/
    select?: WorkoutPlanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutPlanInclude | null
    /**
     * Filter which WorkoutPlan to delete.
     * 
    **/
    where: WorkoutPlanWhereUniqueInput
  }


  /**
   * WorkoutPlan deleteMany
   */
  export type WorkoutPlanDeleteManyArgs = {
    where?: WorkoutPlanWhereInput
  }


  /**
   * WorkoutPlan without action
   */
  export type WorkoutPlanArgs = {
    /**
     * Select specific fields to fetch from the WorkoutPlan
     * 
    **/
    select?: WorkoutPlanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutPlanInclude | null
  }



  /**
   * Model Exercise
   */


  export type AggregateExercise = {
    _count: ExerciseCountAggregateOutputType | null
    _avg: ExerciseAvgAggregateOutputType | null
    _sum: ExerciseSumAggregateOutputType | null
    _min: ExerciseMinAggregateOutputType | null
    _max: ExerciseMaxAggregateOutputType | null
  }

  export type ExerciseAvgAggregateOutputType = {
    id: number | null
  }

  export type ExerciseSumAggregateOutputType = {
    id: number | null
  }

  export type ExerciseMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
  }

  export type ExerciseMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
  }

  export type ExerciseCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    _all: number
  }


  export type ExerciseAvgAggregateInputType = {
    id?: true
  }

  export type ExerciseSumAggregateInputType = {
    id?: true
  }

  export type ExerciseMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
  }

  export type ExerciseMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
  }

  export type ExerciseCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type ExerciseAggregateArgs = {
    /**
     * Filter which Exercise to aggregate.
     * 
    **/
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     * 
    **/
    orderBy?: Enumerable<ExerciseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Exercises
    **/
    _count?: true | ExerciseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExerciseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExerciseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExerciseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExerciseMaxAggregateInputType
  }

  export type GetExerciseAggregateType<T extends ExerciseAggregateArgs> = {
        [P in keyof T & keyof AggregateExercise]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExercise[P]>
      : GetScalarType<T[P], AggregateExercise[P]>
  }




  export type ExerciseGroupByArgs = {
    where?: ExerciseWhereInput
    orderBy?: Enumerable<ExerciseOrderByWithAggregationInput>
    by: Array<ExerciseScalarFieldEnum>
    having?: ExerciseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExerciseCountAggregateInputType | true
    _avg?: ExerciseAvgAggregateInputType
    _sum?: ExerciseSumAggregateInputType
    _min?: ExerciseMinAggregateInputType
    _max?: ExerciseMaxAggregateInputType
  }


  export type ExerciseGroupByOutputType = {
    id: number
    name: string
    description: string | null
    createdAt: Date
    _count: ExerciseCountAggregateOutputType | null
    _avg: ExerciseAvgAggregateOutputType | null
    _sum: ExerciseSumAggregateOutputType | null
    _min: ExerciseMinAggregateOutputType | null
    _max: ExerciseMaxAggregateOutputType | null
  }

  type GetExerciseGroupByPayload<T extends ExerciseGroupByArgs> = Promise<
    Array<
      PickArray<ExerciseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExerciseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExerciseGroupByOutputType[P]>
            : GetScalarType<T[P], ExerciseGroupByOutputType[P]>
        }
      >
    >


  export type ExerciseSelect = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    workoutExercises?: boolean | WorkoutExerciseFindManyArgs
    planExercises?: boolean | WorkoutPlanExerciseFindManyArgs
    sessionExercises?: boolean | WorkoutSessionExerciseFindManyArgs
    _count?: boolean | ExerciseCountOutputTypeArgs
  }

  export type ExerciseInclude = {
    workoutExercises?: boolean | WorkoutExerciseFindManyArgs
    planExercises?: boolean | WorkoutPlanExerciseFindManyArgs
    sessionExercises?: boolean | WorkoutSessionExerciseFindManyArgs
    _count?: boolean | ExerciseCountOutputTypeArgs
  }

  export type ExerciseGetPayload<
    S extends boolean | null | undefined | ExerciseArgs,
    U = keyof S
      > = S extends true
        ? Exercise
    : S extends undefined
    ? never
    : S extends ExerciseArgs | ExerciseFindManyArgs
    ?'include' extends U
    ? Exercise  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'workoutExercises'
        ? Array < WorkoutExerciseGetPayload<S['include'][P]>>  :
        P extends 'planExercises'
        ? Array < WorkoutPlanExerciseGetPayload<S['include'][P]>>  :
        P extends 'sessionExercises'
        ? Array < WorkoutSessionExerciseGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? ExerciseCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Exercise ?Exercise [P]
  : 
          P extends 'workoutExercises'
        ? Array < WorkoutExerciseGetPayload<S['select'][P]>>  :
        P extends 'planExercises'
        ? Array < WorkoutPlanExerciseGetPayload<S['select'][P]>>  :
        P extends 'sessionExercises'
        ? Array < WorkoutSessionExerciseGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? ExerciseCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : Exercise
  : Exercise


  type ExerciseCountArgs = Merge<
    Omit<ExerciseFindManyArgs, 'select' | 'include'> & {
      select?: ExerciseCountAggregateInputType | true
    }
  >

  export interface ExerciseDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Exercise that matches the filter.
     * @param {ExerciseFindUniqueArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ExerciseFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ExerciseFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Exercise'> extends True ? CheckSelect<T, Prisma__ExerciseClient<Exercise>, Prisma__ExerciseClient<ExerciseGetPayload<T>>> : CheckSelect<T, Prisma__ExerciseClient<Exercise | null >, Prisma__ExerciseClient<ExerciseGetPayload<T> | null >>

    /**
     * Find the first Exercise that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseFindFirstArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ExerciseFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ExerciseFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Exercise'> extends True ? CheckSelect<T, Prisma__ExerciseClient<Exercise>, Prisma__ExerciseClient<ExerciseGetPayload<T>>> : CheckSelect<T, Prisma__ExerciseClient<Exercise | null >, Prisma__ExerciseClient<ExerciseGetPayload<T> | null >>

    /**
     * Find zero or more Exercises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exercises
     * const exercises = await prisma.exercise.findMany()
     * 
     * // Get first 10 Exercises
     * const exercises = await prisma.exercise.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exerciseWithIdOnly = await prisma.exercise.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ExerciseFindManyArgs>(
      args?: SelectSubset<T, ExerciseFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Exercise>>, PrismaPromise<Array<ExerciseGetPayload<T>>>>

    /**
     * Create a Exercise.
     * @param {ExerciseCreateArgs} args - Arguments to create a Exercise.
     * @example
     * // Create one Exercise
     * const Exercise = await prisma.exercise.create({
     *   data: {
     *     // ... data to create a Exercise
     *   }
     * })
     * 
    **/
    create<T extends ExerciseCreateArgs>(
      args: SelectSubset<T, ExerciseCreateArgs>
    ): CheckSelect<T, Prisma__ExerciseClient<Exercise>, Prisma__ExerciseClient<ExerciseGetPayload<T>>>

    /**
     * Create many Exercises.
     *     @param {ExerciseCreateManyArgs} args - Arguments to create many Exercises.
     *     @example
     *     // Create many Exercises
     *     const exercise = await prisma.exercise.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ExerciseCreateManyArgs>(
      args?: SelectSubset<T, ExerciseCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Exercise.
     * @param {ExerciseDeleteArgs} args - Arguments to delete one Exercise.
     * @example
     * // Delete one Exercise
     * const Exercise = await prisma.exercise.delete({
     *   where: {
     *     // ... filter to delete one Exercise
     *   }
     * })
     * 
    **/
    delete<T extends ExerciseDeleteArgs>(
      args: SelectSubset<T, ExerciseDeleteArgs>
    ): CheckSelect<T, Prisma__ExerciseClient<Exercise>, Prisma__ExerciseClient<ExerciseGetPayload<T>>>

    /**
     * Update one Exercise.
     * @param {ExerciseUpdateArgs} args - Arguments to update one Exercise.
     * @example
     * // Update one Exercise
     * const exercise = await prisma.exercise.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ExerciseUpdateArgs>(
      args: SelectSubset<T, ExerciseUpdateArgs>
    ): CheckSelect<T, Prisma__ExerciseClient<Exercise>, Prisma__ExerciseClient<ExerciseGetPayload<T>>>

    /**
     * Delete zero or more Exercises.
     * @param {ExerciseDeleteManyArgs} args - Arguments to filter Exercises to delete.
     * @example
     * // Delete a few Exercises
     * const { count } = await prisma.exercise.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ExerciseDeleteManyArgs>(
      args?: SelectSubset<T, ExerciseDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exercises
     * const exercise = await prisma.exercise.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ExerciseUpdateManyArgs>(
      args: SelectSubset<T, ExerciseUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Exercise.
     * @param {ExerciseUpsertArgs} args - Arguments to update or create a Exercise.
     * @example
     * // Update or create a Exercise
     * const exercise = await prisma.exercise.upsert({
     *   create: {
     *     // ... data to create a Exercise
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exercise we want to update
     *   }
     * })
    **/
    upsert<T extends ExerciseUpsertArgs>(
      args: SelectSubset<T, ExerciseUpsertArgs>
    ): CheckSelect<T, Prisma__ExerciseClient<Exercise>, Prisma__ExerciseClient<ExerciseGetPayload<T>>>

    /**
     * Count the number of Exercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseCountArgs} args - Arguments to filter Exercises to count.
     * @example
     * // Count the number of Exercises
     * const count = await prisma.exercise.count({
     *   where: {
     *     // ... the filter for the Exercises we want to count
     *   }
     * })
    **/
    count<T extends ExerciseCountArgs>(
      args?: Subset<T, ExerciseCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExerciseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExerciseAggregateArgs>(args: Subset<T, ExerciseAggregateArgs>): PrismaPromise<GetExerciseAggregateType<T>>

    /**
     * Group by Exercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExerciseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExerciseGroupByArgs['orderBy'] }
        : { orderBy?: ExerciseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExerciseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExerciseGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Exercise.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ExerciseClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    workoutExercises<T extends WorkoutExerciseFindManyArgs = {}>(args?: Subset<T, WorkoutExerciseFindManyArgs>): CheckSelect<T, PrismaPromise<Array<WorkoutExercise>>, PrismaPromise<Array<WorkoutExerciseGetPayload<T>>>>;

    planExercises<T extends WorkoutPlanExerciseFindManyArgs = {}>(args?: Subset<T, WorkoutPlanExerciseFindManyArgs>): CheckSelect<T, PrismaPromise<Array<WorkoutPlanExercise>>, PrismaPromise<Array<WorkoutPlanExerciseGetPayload<T>>>>;

    sessionExercises<T extends WorkoutSessionExerciseFindManyArgs = {}>(args?: Subset<T, WorkoutSessionExerciseFindManyArgs>): CheckSelect<T, PrismaPromise<Array<WorkoutSessionExercise>>, PrismaPromise<Array<WorkoutSessionExerciseGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Exercise findUnique
   */
  export type ExerciseFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Exercise
     * 
    **/
    select?: ExerciseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ExerciseInclude | null
    /**
     * Throw an Error if a Exercise can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Exercise to fetch.
     * 
    **/
    where: ExerciseWhereUniqueInput
  }


  /**
   * Exercise findFirst
   */
  export type ExerciseFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Exercise
     * 
    **/
    select?: ExerciseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ExerciseInclude | null
    /**
     * Throw an Error if a Exercise can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Exercise to fetch.
     * 
    **/
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     * 
    **/
    orderBy?: Enumerable<ExerciseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exercises.
     * 
    **/
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exercises.
     * 
    **/
    distinct?: Enumerable<ExerciseScalarFieldEnum>
  }


  /**
   * Exercise findMany
   */
  export type ExerciseFindManyArgs = {
    /**
     * Select specific fields to fetch from the Exercise
     * 
    **/
    select?: ExerciseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ExerciseInclude | null
    /**
     * Filter, which Exercises to fetch.
     * 
    **/
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     * 
    **/
    orderBy?: Enumerable<ExerciseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Exercises.
     * 
    **/
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ExerciseScalarFieldEnum>
  }


  /**
   * Exercise create
   */
  export type ExerciseCreateArgs = {
    /**
     * Select specific fields to fetch from the Exercise
     * 
    **/
    select?: ExerciseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ExerciseInclude | null
    /**
     * The data needed to create a Exercise.
     * 
    **/
    data: XOR<ExerciseCreateInput, ExerciseUncheckedCreateInput>
  }


  /**
   * Exercise createMany
   */
  export type ExerciseCreateManyArgs = {
    data: Enumerable<ExerciseCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Exercise update
   */
  export type ExerciseUpdateArgs = {
    /**
     * Select specific fields to fetch from the Exercise
     * 
    **/
    select?: ExerciseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ExerciseInclude | null
    /**
     * The data needed to update a Exercise.
     * 
    **/
    data: XOR<ExerciseUpdateInput, ExerciseUncheckedUpdateInput>
    /**
     * Choose, which Exercise to update.
     * 
    **/
    where: ExerciseWhereUniqueInput
  }


  /**
   * Exercise updateMany
   */
  export type ExerciseUpdateManyArgs = {
    data: XOR<ExerciseUpdateManyMutationInput, ExerciseUncheckedUpdateManyInput>
    where?: ExerciseWhereInput
  }


  /**
   * Exercise upsert
   */
  export type ExerciseUpsertArgs = {
    /**
     * Select specific fields to fetch from the Exercise
     * 
    **/
    select?: ExerciseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ExerciseInclude | null
    /**
     * The filter to search for the Exercise to update in case it exists.
     * 
    **/
    where: ExerciseWhereUniqueInput
    /**
     * In case the Exercise found by the `where` argument doesn't exist, create a new Exercise with this data.
     * 
    **/
    create: XOR<ExerciseCreateInput, ExerciseUncheckedCreateInput>
    /**
     * In case the Exercise was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ExerciseUpdateInput, ExerciseUncheckedUpdateInput>
  }


  /**
   * Exercise delete
   */
  export type ExerciseDeleteArgs = {
    /**
     * Select specific fields to fetch from the Exercise
     * 
    **/
    select?: ExerciseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ExerciseInclude | null
    /**
     * Filter which Exercise to delete.
     * 
    **/
    where: ExerciseWhereUniqueInput
  }


  /**
   * Exercise deleteMany
   */
  export type ExerciseDeleteManyArgs = {
    where?: ExerciseWhereInput
  }


  /**
   * Exercise without action
   */
  export type ExerciseArgs = {
    /**
     * Select specific fields to fetch from the Exercise
     * 
    **/
    select?: ExerciseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ExerciseInclude | null
  }



  /**
   * Model WorkoutPlanExercise
   */


  export type AggregateWorkoutPlanExercise = {
    _count: WorkoutPlanExerciseCountAggregateOutputType | null
    _avg: WorkoutPlanExerciseAvgAggregateOutputType | null
    _sum: WorkoutPlanExerciseSumAggregateOutputType | null
    _min: WorkoutPlanExerciseMinAggregateOutputType | null
    _max: WorkoutPlanExerciseMaxAggregateOutputType | null
  }

  export type WorkoutPlanExerciseAvgAggregateOutputType = {
    id: number | null
    planId: number | null
    exerciseId: number | null
    orderIndex: number | null
  }

  export type WorkoutPlanExerciseSumAggregateOutputType = {
    id: number | null
    planId: number | null
    exerciseId: number | null
    orderIndex: number | null
  }

  export type WorkoutPlanExerciseMinAggregateOutputType = {
    id: number | null
    planId: number | null
    exerciseId: number | null
    orderIndex: number | null
  }

  export type WorkoutPlanExerciseMaxAggregateOutputType = {
    id: number | null
    planId: number | null
    exerciseId: number | null
    orderIndex: number | null
  }

  export type WorkoutPlanExerciseCountAggregateOutputType = {
    id: number
    planId: number
    exerciseId: number
    orderIndex: number
    _all: number
  }


  export type WorkoutPlanExerciseAvgAggregateInputType = {
    id?: true
    planId?: true
    exerciseId?: true
    orderIndex?: true
  }

  export type WorkoutPlanExerciseSumAggregateInputType = {
    id?: true
    planId?: true
    exerciseId?: true
    orderIndex?: true
  }

  export type WorkoutPlanExerciseMinAggregateInputType = {
    id?: true
    planId?: true
    exerciseId?: true
    orderIndex?: true
  }

  export type WorkoutPlanExerciseMaxAggregateInputType = {
    id?: true
    planId?: true
    exerciseId?: true
    orderIndex?: true
  }

  export type WorkoutPlanExerciseCountAggregateInputType = {
    id?: true
    planId?: true
    exerciseId?: true
    orderIndex?: true
    _all?: true
  }

  export type WorkoutPlanExerciseAggregateArgs = {
    /**
     * Filter which WorkoutPlanExercise to aggregate.
     * 
    **/
    where?: WorkoutPlanExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutPlanExercises to fetch.
     * 
    **/
    orderBy?: Enumerable<WorkoutPlanExerciseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: WorkoutPlanExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutPlanExercises from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutPlanExercises.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkoutPlanExercises
    **/
    _count?: true | WorkoutPlanExerciseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkoutPlanExerciseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkoutPlanExerciseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkoutPlanExerciseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkoutPlanExerciseMaxAggregateInputType
  }

  export type GetWorkoutPlanExerciseAggregateType<T extends WorkoutPlanExerciseAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkoutPlanExercise]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkoutPlanExercise[P]>
      : GetScalarType<T[P], AggregateWorkoutPlanExercise[P]>
  }




  export type WorkoutPlanExerciseGroupByArgs = {
    where?: WorkoutPlanExerciseWhereInput
    orderBy?: Enumerable<WorkoutPlanExerciseOrderByWithAggregationInput>
    by: Array<WorkoutPlanExerciseScalarFieldEnum>
    having?: WorkoutPlanExerciseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkoutPlanExerciseCountAggregateInputType | true
    _avg?: WorkoutPlanExerciseAvgAggregateInputType
    _sum?: WorkoutPlanExerciseSumAggregateInputType
    _min?: WorkoutPlanExerciseMinAggregateInputType
    _max?: WorkoutPlanExerciseMaxAggregateInputType
  }


  export type WorkoutPlanExerciseGroupByOutputType = {
    id: number
    planId: number
    exerciseId: number
    orderIndex: number
    _count: WorkoutPlanExerciseCountAggregateOutputType | null
    _avg: WorkoutPlanExerciseAvgAggregateOutputType | null
    _sum: WorkoutPlanExerciseSumAggregateOutputType | null
    _min: WorkoutPlanExerciseMinAggregateOutputType | null
    _max: WorkoutPlanExerciseMaxAggregateOutputType | null
  }

  type GetWorkoutPlanExerciseGroupByPayload<T extends WorkoutPlanExerciseGroupByArgs> = Promise<
    Array<
      PickArray<WorkoutPlanExerciseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkoutPlanExerciseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkoutPlanExerciseGroupByOutputType[P]>
            : GetScalarType<T[P], WorkoutPlanExerciseGroupByOutputType[P]>
        }
      >
    >


  export type WorkoutPlanExerciseSelect = {
    id?: boolean
    planId?: boolean
    exerciseId?: boolean
    orderIndex?: boolean
    plan?: boolean | WorkoutPlanArgs
    exercise?: boolean | ExerciseArgs
  }

  export type WorkoutPlanExerciseInclude = {
    plan?: boolean | WorkoutPlanArgs
    exercise?: boolean | ExerciseArgs
  }

  export type WorkoutPlanExerciseGetPayload<
    S extends boolean | null | undefined | WorkoutPlanExerciseArgs,
    U = keyof S
      > = S extends true
        ? WorkoutPlanExercise
    : S extends undefined
    ? never
    : S extends WorkoutPlanExerciseArgs | WorkoutPlanExerciseFindManyArgs
    ?'include' extends U
    ? WorkoutPlanExercise  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'plan'
        ? WorkoutPlanGetPayload<S['include'][P]> :
        P extends 'exercise'
        ? ExerciseGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof WorkoutPlanExercise ?WorkoutPlanExercise [P]
  : 
          P extends 'plan'
        ? WorkoutPlanGetPayload<S['select'][P]> :
        P extends 'exercise'
        ? ExerciseGetPayload<S['select'][P]> : never
  } 
    : WorkoutPlanExercise
  : WorkoutPlanExercise


  type WorkoutPlanExerciseCountArgs = Merge<
    Omit<WorkoutPlanExerciseFindManyArgs, 'select' | 'include'> & {
      select?: WorkoutPlanExerciseCountAggregateInputType | true
    }
  >

  export interface WorkoutPlanExerciseDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one WorkoutPlanExercise that matches the filter.
     * @param {WorkoutPlanExerciseFindUniqueArgs} args - Arguments to find a WorkoutPlanExercise
     * @example
     * // Get one WorkoutPlanExercise
     * const workoutPlanExercise = await prisma.workoutPlanExercise.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WorkoutPlanExerciseFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WorkoutPlanExerciseFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'WorkoutPlanExercise'> extends True ? CheckSelect<T, Prisma__WorkoutPlanExerciseClient<WorkoutPlanExercise>, Prisma__WorkoutPlanExerciseClient<WorkoutPlanExerciseGetPayload<T>>> : CheckSelect<T, Prisma__WorkoutPlanExerciseClient<WorkoutPlanExercise | null >, Prisma__WorkoutPlanExerciseClient<WorkoutPlanExerciseGetPayload<T> | null >>

    /**
     * Find the first WorkoutPlanExercise that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutPlanExerciseFindFirstArgs} args - Arguments to find a WorkoutPlanExercise
     * @example
     * // Get one WorkoutPlanExercise
     * const workoutPlanExercise = await prisma.workoutPlanExercise.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WorkoutPlanExerciseFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WorkoutPlanExerciseFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'WorkoutPlanExercise'> extends True ? CheckSelect<T, Prisma__WorkoutPlanExerciseClient<WorkoutPlanExercise>, Prisma__WorkoutPlanExerciseClient<WorkoutPlanExerciseGetPayload<T>>> : CheckSelect<T, Prisma__WorkoutPlanExerciseClient<WorkoutPlanExercise | null >, Prisma__WorkoutPlanExerciseClient<WorkoutPlanExerciseGetPayload<T> | null >>

    /**
     * Find zero or more WorkoutPlanExercises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutPlanExerciseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkoutPlanExercises
     * const workoutPlanExercises = await prisma.workoutPlanExercise.findMany()
     * 
     * // Get first 10 WorkoutPlanExercises
     * const workoutPlanExercises = await prisma.workoutPlanExercise.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workoutPlanExerciseWithIdOnly = await prisma.workoutPlanExercise.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WorkoutPlanExerciseFindManyArgs>(
      args?: SelectSubset<T, WorkoutPlanExerciseFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<WorkoutPlanExercise>>, PrismaPromise<Array<WorkoutPlanExerciseGetPayload<T>>>>

    /**
     * Create a WorkoutPlanExercise.
     * @param {WorkoutPlanExerciseCreateArgs} args - Arguments to create a WorkoutPlanExercise.
     * @example
     * // Create one WorkoutPlanExercise
     * const WorkoutPlanExercise = await prisma.workoutPlanExercise.create({
     *   data: {
     *     // ... data to create a WorkoutPlanExercise
     *   }
     * })
     * 
    **/
    create<T extends WorkoutPlanExerciseCreateArgs>(
      args: SelectSubset<T, WorkoutPlanExerciseCreateArgs>
    ): CheckSelect<T, Prisma__WorkoutPlanExerciseClient<WorkoutPlanExercise>, Prisma__WorkoutPlanExerciseClient<WorkoutPlanExerciseGetPayload<T>>>

    /**
     * Create many WorkoutPlanExercises.
     *     @param {WorkoutPlanExerciseCreateManyArgs} args - Arguments to create many WorkoutPlanExercises.
     *     @example
     *     // Create many WorkoutPlanExercises
     *     const workoutPlanExercise = await prisma.workoutPlanExercise.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WorkoutPlanExerciseCreateManyArgs>(
      args?: SelectSubset<T, WorkoutPlanExerciseCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a WorkoutPlanExercise.
     * @param {WorkoutPlanExerciseDeleteArgs} args - Arguments to delete one WorkoutPlanExercise.
     * @example
     * // Delete one WorkoutPlanExercise
     * const WorkoutPlanExercise = await prisma.workoutPlanExercise.delete({
     *   where: {
     *     // ... filter to delete one WorkoutPlanExercise
     *   }
     * })
     * 
    **/
    delete<T extends WorkoutPlanExerciseDeleteArgs>(
      args: SelectSubset<T, WorkoutPlanExerciseDeleteArgs>
    ): CheckSelect<T, Prisma__WorkoutPlanExerciseClient<WorkoutPlanExercise>, Prisma__WorkoutPlanExerciseClient<WorkoutPlanExerciseGetPayload<T>>>

    /**
     * Update one WorkoutPlanExercise.
     * @param {WorkoutPlanExerciseUpdateArgs} args - Arguments to update one WorkoutPlanExercise.
     * @example
     * // Update one WorkoutPlanExercise
     * const workoutPlanExercise = await prisma.workoutPlanExercise.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WorkoutPlanExerciseUpdateArgs>(
      args: SelectSubset<T, WorkoutPlanExerciseUpdateArgs>
    ): CheckSelect<T, Prisma__WorkoutPlanExerciseClient<WorkoutPlanExercise>, Prisma__WorkoutPlanExerciseClient<WorkoutPlanExerciseGetPayload<T>>>

    /**
     * Delete zero or more WorkoutPlanExercises.
     * @param {WorkoutPlanExerciseDeleteManyArgs} args - Arguments to filter WorkoutPlanExercises to delete.
     * @example
     * // Delete a few WorkoutPlanExercises
     * const { count } = await prisma.workoutPlanExercise.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WorkoutPlanExerciseDeleteManyArgs>(
      args?: SelectSubset<T, WorkoutPlanExerciseDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkoutPlanExercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutPlanExerciseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkoutPlanExercises
     * const workoutPlanExercise = await prisma.workoutPlanExercise.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WorkoutPlanExerciseUpdateManyArgs>(
      args: SelectSubset<T, WorkoutPlanExerciseUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkoutPlanExercise.
     * @param {WorkoutPlanExerciseUpsertArgs} args - Arguments to update or create a WorkoutPlanExercise.
     * @example
     * // Update or create a WorkoutPlanExercise
     * const workoutPlanExercise = await prisma.workoutPlanExercise.upsert({
     *   create: {
     *     // ... data to create a WorkoutPlanExercise
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkoutPlanExercise we want to update
     *   }
     * })
    **/
    upsert<T extends WorkoutPlanExerciseUpsertArgs>(
      args: SelectSubset<T, WorkoutPlanExerciseUpsertArgs>
    ): CheckSelect<T, Prisma__WorkoutPlanExerciseClient<WorkoutPlanExercise>, Prisma__WorkoutPlanExerciseClient<WorkoutPlanExerciseGetPayload<T>>>

    /**
     * Count the number of WorkoutPlanExercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutPlanExerciseCountArgs} args - Arguments to filter WorkoutPlanExercises to count.
     * @example
     * // Count the number of WorkoutPlanExercises
     * const count = await prisma.workoutPlanExercise.count({
     *   where: {
     *     // ... the filter for the WorkoutPlanExercises we want to count
     *   }
     * })
    **/
    count<T extends WorkoutPlanExerciseCountArgs>(
      args?: Subset<T, WorkoutPlanExerciseCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkoutPlanExerciseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkoutPlanExercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutPlanExerciseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkoutPlanExerciseAggregateArgs>(args: Subset<T, WorkoutPlanExerciseAggregateArgs>): PrismaPromise<GetWorkoutPlanExerciseAggregateType<T>>

    /**
     * Group by WorkoutPlanExercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutPlanExerciseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkoutPlanExerciseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkoutPlanExerciseGroupByArgs['orderBy'] }
        : { orderBy?: WorkoutPlanExerciseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkoutPlanExerciseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkoutPlanExerciseGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkoutPlanExercise.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WorkoutPlanExerciseClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    plan<T extends WorkoutPlanArgs = {}>(args?: Subset<T, WorkoutPlanArgs>): CheckSelect<T, Prisma__WorkoutPlanClient<WorkoutPlan | null >, Prisma__WorkoutPlanClient<WorkoutPlanGetPayload<T> | null >>;

    exercise<T extends ExerciseArgs = {}>(args?: Subset<T, ExerciseArgs>): CheckSelect<T, Prisma__ExerciseClient<Exercise | null >, Prisma__ExerciseClient<ExerciseGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * WorkoutPlanExercise findUnique
   */
  export type WorkoutPlanExerciseFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the WorkoutPlanExercise
     * 
    **/
    select?: WorkoutPlanExerciseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutPlanExerciseInclude | null
    /**
     * Throw an Error if a WorkoutPlanExercise can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which WorkoutPlanExercise to fetch.
     * 
    **/
    where: WorkoutPlanExerciseWhereUniqueInput
  }


  /**
   * WorkoutPlanExercise findFirst
   */
  export type WorkoutPlanExerciseFindFirstArgs = {
    /**
     * Select specific fields to fetch from the WorkoutPlanExercise
     * 
    **/
    select?: WorkoutPlanExerciseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutPlanExerciseInclude | null
    /**
     * Throw an Error if a WorkoutPlanExercise can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which WorkoutPlanExercise to fetch.
     * 
    **/
    where?: WorkoutPlanExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutPlanExercises to fetch.
     * 
    **/
    orderBy?: Enumerable<WorkoutPlanExerciseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkoutPlanExercises.
     * 
    **/
    cursor?: WorkoutPlanExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutPlanExercises from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutPlanExercises.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkoutPlanExercises.
     * 
    **/
    distinct?: Enumerable<WorkoutPlanExerciseScalarFieldEnum>
  }


  /**
   * WorkoutPlanExercise findMany
   */
  export type WorkoutPlanExerciseFindManyArgs = {
    /**
     * Select specific fields to fetch from the WorkoutPlanExercise
     * 
    **/
    select?: WorkoutPlanExerciseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutPlanExerciseInclude | null
    /**
     * Filter, which WorkoutPlanExercises to fetch.
     * 
    **/
    where?: WorkoutPlanExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutPlanExercises to fetch.
     * 
    **/
    orderBy?: Enumerable<WorkoutPlanExerciseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkoutPlanExercises.
     * 
    **/
    cursor?: WorkoutPlanExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutPlanExercises from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutPlanExercises.
     * 
    **/
    skip?: number
    distinct?: Enumerable<WorkoutPlanExerciseScalarFieldEnum>
  }


  /**
   * WorkoutPlanExercise create
   */
  export type WorkoutPlanExerciseCreateArgs = {
    /**
     * Select specific fields to fetch from the WorkoutPlanExercise
     * 
    **/
    select?: WorkoutPlanExerciseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutPlanExerciseInclude | null
    /**
     * The data needed to create a WorkoutPlanExercise.
     * 
    **/
    data: XOR<WorkoutPlanExerciseCreateInput, WorkoutPlanExerciseUncheckedCreateInput>
  }


  /**
   * WorkoutPlanExercise createMany
   */
  export type WorkoutPlanExerciseCreateManyArgs = {
    data: Enumerable<WorkoutPlanExerciseCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * WorkoutPlanExercise update
   */
  export type WorkoutPlanExerciseUpdateArgs = {
    /**
     * Select specific fields to fetch from the WorkoutPlanExercise
     * 
    **/
    select?: WorkoutPlanExerciseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutPlanExerciseInclude | null
    /**
     * The data needed to update a WorkoutPlanExercise.
     * 
    **/
    data: XOR<WorkoutPlanExerciseUpdateInput, WorkoutPlanExerciseUncheckedUpdateInput>
    /**
     * Choose, which WorkoutPlanExercise to update.
     * 
    **/
    where: WorkoutPlanExerciseWhereUniqueInput
  }


  /**
   * WorkoutPlanExercise updateMany
   */
  export type WorkoutPlanExerciseUpdateManyArgs = {
    data: XOR<WorkoutPlanExerciseUpdateManyMutationInput, WorkoutPlanExerciseUncheckedUpdateManyInput>
    where?: WorkoutPlanExerciseWhereInput
  }


  /**
   * WorkoutPlanExercise upsert
   */
  export type WorkoutPlanExerciseUpsertArgs = {
    /**
     * Select specific fields to fetch from the WorkoutPlanExercise
     * 
    **/
    select?: WorkoutPlanExerciseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutPlanExerciseInclude | null
    /**
     * The filter to search for the WorkoutPlanExercise to update in case it exists.
     * 
    **/
    where: WorkoutPlanExerciseWhereUniqueInput
    /**
     * In case the WorkoutPlanExercise found by the `where` argument doesn't exist, create a new WorkoutPlanExercise with this data.
     * 
    **/
    create: XOR<WorkoutPlanExerciseCreateInput, WorkoutPlanExerciseUncheckedCreateInput>
    /**
     * In case the WorkoutPlanExercise was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<WorkoutPlanExerciseUpdateInput, WorkoutPlanExerciseUncheckedUpdateInput>
  }


  /**
   * WorkoutPlanExercise delete
   */
  export type WorkoutPlanExerciseDeleteArgs = {
    /**
     * Select specific fields to fetch from the WorkoutPlanExercise
     * 
    **/
    select?: WorkoutPlanExerciseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutPlanExerciseInclude | null
    /**
     * Filter which WorkoutPlanExercise to delete.
     * 
    **/
    where: WorkoutPlanExerciseWhereUniqueInput
  }


  /**
   * WorkoutPlanExercise deleteMany
   */
  export type WorkoutPlanExerciseDeleteManyArgs = {
    where?: WorkoutPlanExerciseWhereInput
  }


  /**
   * WorkoutPlanExercise without action
   */
  export type WorkoutPlanExerciseArgs = {
    /**
     * Select specific fields to fetch from the WorkoutPlanExercise
     * 
    **/
    select?: WorkoutPlanExerciseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutPlanExerciseInclude | null
  }



  /**
   * Model WorkoutSession
   */


  export type AggregateWorkoutSession = {
    _count: WorkoutSessionCountAggregateOutputType | null
    _avg: WorkoutSessionAvgAggregateOutputType | null
    _sum: WorkoutSessionSumAggregateOutputType | null
    _min: WorkoutSessionMinAggregateOutputType | null
    _max: WorkoutSessionMaxAggregateOutputType | null
  }

  export type WorkoutSessionAvgAggregateOutputType = {
    id: number | null
    athleteId: number | null
    planId: number | null
  }

  export type WorkoutSessionSumAggregateOutputType = {
    id: number | null
    athleteId: number | null
    planId: number | null
  }

  export type WorkoutSessionMinAggregateOutputType = {
    id: number | null
    athleteId: number | null
    planId: number | null
    date: Date | null
  }

  export type WorkoutSessionMaxAggregateOutputType = {
    id: number | null
    athleteId: number | null
    planId: number | null
    date: Date | null
  }

  export type WorkoutSessionCountAggregateOutputType = {
    id: number
    athleteId: number
    planId: number
    date: number
    _all: number
  }


  export type WorkoutSessionAvgAggregateInputType = {
    id?: true
    athleteId?: true
    planId?: true
  }

  export type WorkoutSessionSumAggregateInputType = {
    id?: true
    athleteId?: true
    planId?: true
  }

  export type WorkoutSessionMinAggregateInputType = {
    id?: true
    athleteId?: true
    planId?: true
    date?: true
  }

  export type WorkoutSessionMaxAggregateInputType = {
    id?: true
    athleteId?: true
    planId?: true
    date?: true
  }

  export type WorkoutSessionCountAggregateInputType = {
    id?: true
    athleteId?: true
    planId?: true
    date?: true
    _all?: true
  }

  export type WorkoutSessionAggregateArgs = {
    /**
     * Filter which WorkoutSession to aggregate.
     * 
    **/
    where?: WorkoutSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutSessions to fetch.
     * 
    **/
    orderBy?: Enumerable<WorkoutSessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: WorkoutSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutSessions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutSessions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkoutSessions
    **/
    _count?: true | WorkoutSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkoutSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkoutSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkoutSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkoutSessionMaxAggregateInputType
  }

  export type GetWorkoutSessionAggregateType<T extends WorkoutSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkoutSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkoutSession[P]>
      : GetScalarType<T[P], AggregateWorkoutSession[P]>
  }




  export type WorkoutSessionGroupByArgs = {
    where?: WorkoutSessionWhereInput
    orderBy?: Enumerable<WorkoutSessionOrderByWithAggregationInput>
    by: Array<WorkoutSessionScalarFieldEnum>
    having?: WorkoutSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkoutSessionCountAggregateInputType | true
    _avg?: WorkoutSessionAvgAggregateInputType
    _sum?: WorkoutSessionSumAggregateInputType
    _min?: WorkoutSessionMinAggregateInputType
    _max?: WorkoutSessionMaxAggregateInputType
  }


  export type WorkoutSessionGroupByOutputType = {
    id: number
    athleteId: number
    planId: number
    date: Date
    _count: WorkoutSessionCountAggregateOutputType | null
    _avg: WorkoutSessionAvgAggregateOutputType | null
    _sum: WorkoutSessionSumAggregateOutputType | null
    _min: WorkoutSessionMinAggregateOutputType | null
    _max: WorkoutSessionMaxAggregateOutputType | null
  }

  type GetWorkoutSessionGroupByPayload<T extends WorkoutSessionGroupByArgs> = Promise<
    Array<
      PickArray<WorkoutSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkoutSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkoutSessionGroupByOutputType[P]>
            : GetScalarType<T[P], WorkoutSessionGroupByOutputType[P]>
        }
      >
    >


  export type WorkoutSessionSelect = {
    id?: boolean
    athleteId?: boolean
    planId?: boolean
    date?: boolean
    athlete?: boolean | UserArgs
    plan?: boolean | WorkoutPlanArgs
    sessionExercises?: boolean | WorkoutSessionExerciseFindManyArgs
    _count?: boolean | WorkoutSessionCountOutputTypeArgs
  }

  export type WorkoutSessionInclude = {
    athlete?: boolean | UserArgs
    plan?: boolean | WorkoutPlanArgs
    sessionExercises?: boolean | WorkoutSessionExerciseFindManyArgs
    _count?: boolean | WorkoutSessionCountOutputTypeArgs
  }

  export type WorkoutSessionGetPayload<
    S extends boolean | null | undefined | WorkoutSessionArgs,
    U = keyof S
      > = S extends true
        ? WorkoutSession
    : S extends undefined
    ? never
    : S extends WorkoutSessionArgs | WorkoutSessionFindManyArgs
    ?'include' extends U
    ? WorkoutSession  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'athlete'
        ? UserGetPayload<S['include'][P]> :
        P extends 'plan'
        ? WorkoutPlanGetPayload<S['include'][P]> :
        P extends 'sessionExercises'
        ? Array < WorkoutSessionExerciseGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? WorkoutSessionCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof WorkoutSession ?WorkoutSession [P]
  : 
          P extends 'athlete'
        ? UserGetPayload<S['select'][P]> :
        P extends 'plan'
        ? WorkoutPlanGetPayload<S['select'][P]> :
        P extends 'sessionExercises'
        ? Array < WorkoutSessionExerciseGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? WorkoutSessionCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : WorkoutSession
  : WorkoutSession


  type WorkoutSessionCountArgs = Merge<
    Omit<WorkoutSessionFindManyArgs, 'select' | 'include'> & {
      select?: WorkoutSessionCountAggregateInputType | true
    }
  >

  export interface WorkoutSessionDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one WorkoutSession that matches the filter.
     * @param {WorkoutSessionFindUniqueArgs} args - Arguments to find a WorkoutSession
     * @example
     * // Get one WorkoutSession
     * const workoutSession = await prisma.workoutSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WorkoutSessionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WorkoutSessionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'WorkoutSession'> extends True ? CheckSelect<T, Prisma__WorkoutSessionClient<WorkoutSession>, Prisma__WorkoutSessionClient<WorkoutSessionGetPayload<T>>> : CheckSelect<T, Prisma__WorkoutSessionClient<WorkoutSession | null >, Prisma__WorkoutSessionClient<WorkoutSessionGetPayload<T> | null >>

    /**
     * Find the first WorkoutSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutSessionFindFirstArgs} args - Arguments to find a WorkoutSession
     * @example
     * // Get one WorkoutSession
     * const workoutSession = await prisma.workoutSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WorkoutSessionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WorkoutSessionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'WorkoutSession'> extends True ? CheckSelect<T, Prisma__WorkoutSessionClient<WorkoutSession>, Prisma__WorkoutSessionClient<WorkoutSessionGetPayload<T>>> : CheckSelect<T, Prisma__WorkoutSessionClient<WorkoutSession | null >, Prisma__WorkoutSessionClient<WorkoutSessionGetPayload<T> | null >>

    /**
     * Find zero or more WorkoutSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutSessionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkoutSessions
     * const workoutSessions = await prisma.workoutSession.findMany()
     * 
     * // Get first 10 WorkoutSessions
     * const workoutSessions = await prisma.workoutSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workoutSessionWithIdOnly = await prisma.workoutSession.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WorkoutSessionFindManyArgs>(
      args?: SelectSubset<T, WorkoutSessionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<WorkoutSession>>, PrismaPromise<Array<WorkoutSessionGetPayload<T>>>>

    /**
     * Create a WorkoutSession.
     * @param {WorkoutSessionCreateArgs} args - Arguments to create a WorkoutSession.
     * @example
     * // Create one WorkoutSession
     * const WorkoutSession = await prisma.workoutSession.create({
     *   data: {
     *     // ... data to create a WorkoutSession
     *   }
     * })
     * 
    **/
    create<T extends WorkoutSessionCreateArgs>(
      args: SelectSubset<T, WorkoutSessionCreateArgs>
    ): CheckSelect<T, Prisma__WorkoutSessionClient<WorkoutSession>, Prisma__WorkoutSessionClient<WorkoutSessionGetPayload<T>>>

    /**
     * Create many WorkoutSessions.
     *     @param {WorkoutSessionCreateManyArgs} args - Arguments to create many WorkoutSessions.
     *     @example
     *     // Create many WorkoutSessions
     *     const workoutSession = await prisma.workoutSession.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WorkoutSessionCreateManyArgs>(
      args?: SelectSubset<T, WorkoutSessionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a WorkoutSession.
     * @param {WorkoutSessionDeleteArgs} args - Arguments to delete one WorkoutSession.
     * @example
     * // Delete one WorkoutSession
     * const WorkoutSession = await prisma.workoutSession.delete({
     *   where: {
     *     // ... filter to delete one WorkoutSession
     *   }
     * })
     * 
    **/
    delete<T extends WorkoutSessionDeleteArgs>(
      args: SelectSubset<T, WorkoutSessionDeleteArgs>
    ): CheckSelect<T, Prisma__WorkoutSessionClient<WorkoutSession>, Prisma__WorkoutSessionClient<WorkoutSessionGetPayload<T>>>

    /**
     * Update one WorkoutSession.
     * @param {WorkoutSessionUpdateArgs} args - Arguments to update one WorkoutSession.
     * @example
     * // Update one WorkoutSession
     * const workoutSession = await prisma.workoutSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WorkoutSessionUpdateArgs>(
      args: SelectSubset<T, WorkoutSessionUpdateArgs>
    ): CheckSelect<T, Prisma__WorkoutSessionClient<WorkoutSession>, Prisma__WorkoutSessionClient<WorkoutSessionGetPayload<T>>>

    /**
     * Delete zero or more WorkoutSessions.
     * @param {WorkoutSessionDeleteManyArgs} args - Arguments to filter WorkoutSessions to delete.
     * @example
     * // Delete a few WorkoutSessions
     * const { count } = await prisma.workoutSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WorkoutSessionDeleteManyArgs>(
      args?: SelectSubset<T, WorkoutSessionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkoutSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkoutSessions
     * const workoutSession = await prisma.workoutSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WorkoutSessionUpdateManyArgs>(
      args: SelectSubset<T, WorkoutSessionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkoutSession.
     * @param {WorkoutSessionUpsertArgs} args - Arguments to update or create a WorkoutSession.
     * @example
     * // Update or create a WorkoutSession
     * const workoutSession = await prisma.workoutSession.upsert({
     *   create: {
     *     // ... data to create a WorkoutSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkoutSession we want to update
     *   }
     * })
    **/
    upsert<T extends WorkoutSessionUpsertArgs>(
      args: SelectSubset<T, WorkoutSessionUpsertArgs>
    ): CheckSelect<T, Prisma__WorkoutSessionClient<WorkoutSession>, Prisma__WorkoutSessionClient<WorkoutSessionGetPayload<T>>>

    /**
     * Count the number of WorkoutSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutSessionCountArgs} args - Arguments to filter WorkoutSessions to count.
     * @example
     * // Count the number of WorkoutSessions
     * const count = await prisma.workoutSession.count({
     *   where: {
     *     // ... the filter for the WorkoutSessions we want to count
     *   }
     * })
    **/
    count<T extends WorkoutSessionCountArgs>(
      args?: Subset<T, WorkoutSessionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkoutSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkoutSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkoutSessionAggregateArgs>(args: Subset<T, WorkoutSessionAggregateArgs>): PrismaPromise<GetWorkoutSessionAggregateType<T>>

    /**
     * Group by WorkoutSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkoutSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkoutSessionGroupByArgs['orderBy'] }
        : { orderBy?: WorkoutSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkoutSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkoutSessionGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkoutSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WorkoutSessionClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    athlete<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    plan<T extends WorkoutPlanArgs = {}>(args?: Subset<T, WorkoutPlanArgs>): CheckSelect<T, Prisma__WorkoutPlanClient<WorkoutPlan | null >, Prisma__WorkoutPlanClient<WorkoutPlanGetPayload<T> | null >>;

    sessionExercises<T extends WorkoutSessionExerciseFindManyArgs = {}>(args?: Subset<T, WorkoutSessionExerciseFindManyArgs>): CheckSelect<T, PrismaPromise<Array<WorkoutSessionExercise>>, PrismaPromise<Array<WorkoutSessionExerciseGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * WorkoutSession findUnique
   */
  export type WorkoutSessionFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the WorkoutSession
     * 
    **/
    select?: WorkoutSessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutSessionInclude | null
    /**
     * Throw an Error if a WorkoutSession can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which WorkoutSession to fetch.
     * 
    **/
    where: WorkoutSessionWhereUniqueInput
  }


  /**
   * WorkoutSession findFirst
   */
  export type WorkoutSessionFindFirstArgs = {
    /**
     * Select specific fields to fetch from the WorkoutSession
     * 
    **/
    select?: WorkoutSessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutSessionInclude | null
    /**
     * Throw an Error if a WorkoutSession can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which WorkoutSession to fetch.
     * 
    **/
    where?: WorkoutSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutSessions to fetch.
     * 
    **/
    orderBy?: Enumerable<WorkoutSessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkoutSessions.
     * 
    **/
    cursor?: WorkoutSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutSessions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutSessions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkoutSessions.
     * 
    **/
    distinct?: Enumerable<WorkoutSessionScalarFieldEnum>
  }


  /**
   * WorkoutSession findMany
   */
  export type WorkoutSessionFindManyArgs = {
    /**
     * Select specific fields to fetch from the WorkoutSession
     * 
    **/
    select?: WorkoutSessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutSessionInclude | null
    /**
     * Filter, which WorkoutSessions to fetch.
     * 
    **/
    where?: WorkoutSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutSessions to fetch.
     * 
    **/
    orderBy?: Enumerable<WorkoutSessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkoutSessions.
     * 
    **/
    cursor?: WorkoutSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutSessions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutSessions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<WorkoutSessionScalarFieldEnum>
  }


  /**
   * WorkoutSession create
   */
  export type WorkoutSessionCreateArgs = {
    /**
     * Select specific fields to fetch from the WorkoutSession
     * 
    **/
    select?: WorkoutSessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutSessionInclude | null
    /**
     * The data needed to create a WorkoutSession.
     * 
    **/
    data: XOR<WorkoutSessionCreateInput, WorkoutSessionUncheckedCreateInput>
  }


  /**
   * WorkoutSession createMany
   */
  export type WorkoutSessionCreateManyArgs = {
    data: Enumerable<WorkoutSessionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * WorkoutSession update
   */
  export type WorkoutSessionUpdateArgs = {
    /**
     * Select specific fields to fetch from the WorkoutSession
     * 
    **/
    select?: WorkoutSessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutSessionInclude | null
    /**
     * The data needed to update a WorkoutSession.
     * 
    **/
    data: XOR<WorkoutSessionUpdateInput, WorkoutSessionUncheckedUpdateInput>
    /**
     * Choose, which WorkoutSession to update.
     * 
    **/
    where: WorkoutSessionWhereUniqueInput
  }


  /**
   * WorkoutSession updateMany
   */
  export type WorkoutSessionUpdateManyArgs = {
    data: XOR<WorkoutSessionUpdateManyMutationInput, WorkoutSessionUncheckedUpdateManyInput>
    where?: WorkoutSessionWhereInput
  }


  /**
   * WorkoutSession upsert
   */
  export type WorkoutSessionUpsertArgs = {
    /**
     * Select specific fields to fetch from the WorkoutSession
     * 
    **/
    select?: WorkoutSessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutSessionInclude | null
    /**
     * The filter to search for the WorkoutSession to update in case it exists.
     * 
    **/
    where: WorkoutSessionWhereUniqueInput
    /**
     * In case the WorkoutSession found by the `where` argument doesn't exist, create a new WorkoutSession with this data.
     * 
    **/
    create: XOR<WorkoutSessionCreateInput, WorkoutSessionUncheckedCreateInput>
    /**
     * In case the WorkoutSession was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<WorkoutSessionUpdateInput, WorkoutSessionUncheckedUpdateInput>
  }


  /**
   * WorkoutSession delete
   */
  export type WorkoutSessionDeleteArgs = {
    /**
     * Select specific fields to fetch from the WorkoutSession
     * 
    **/
    select?: WorkoutSessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutSessionInclude | null
    /**
     * Filter which WorkoutSession to delete.
     * 
    **/
    where: WorkoutSessionWhereUniqueInput
  }


  /**
   * WorkoutSession deleteMany
   */
  export type WorkoutSessionDeleteManyArgs = {
    where?: WorkoutSessionWhereInput
  }


  /**
   * WorkoutSession without action
   */
  export type WorkoutSessionArgs = {
    /**
     * Select specific fields to fetch from the WorkoutSession
     * 
    **/
    select?: WorkoutSessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutSessionInclude | null
  }



  /**
   * Model WorkoutSessionExercise
   */


  export type AggregateWorkoutSessionExercise = {
    _count: WorkoutSessionExerciseCountAggregateOutputType | null
    _avg: WorkoutSessionExerciseAvgAggregateOutputType | null
    _sum: WorkoutSessionExerciseSumAggregateOutputType | null
    _min: WorkoutSessionExerciseMinAggregateOutputType | null
    _max: WorkoutSessionExerciseMaxAggregateOutputType | null
  }

  export type WorkoutSessionExerciseAvgAggregateOutputType = {
    id: number | null
    sessionId: number | null
    exerciseId: number | null
    orderIndex: number | null
  }

  export type WorkoutSessionExerciseSumAggregateOutputType = {
    id: number | null
    sessionId: number | null
    exerciseId: number | null
    orderIndex: number | null
  }

  export type WorkoutSessionExerciseMinAggregateOutputType = {
    id: number | null
    sessionId: number | null
    exerciseId: number | null
    orderIndex: number | null
  }

  export type WorkoutSessionExerciseMaxAggregateOutputType = {
    id: number | null
    sessionId: number | null
    exerciseId: number | null
    orderIndex: number | null
  }

  export type WorkoutSessionExerciseCountAggregateOutputType = {
    id: number
    sessionId: number
    exerciseId: number
    orderIndex: number
    _all: number
  }


  export type WorkoutSessionExerciseAvgAggregateInputType = {
    id?: true
    sessionId?: true
    exerciseId?: true
    orderIndex?: true
  }

  export type WorkoutSessionExerciseSumAggregateInputType = {
    id?: true
    sessionId?: true
    exerciseId?: true
    orderIndex?: true
  }

  export type WorkoutSessionExerciseMinAggregateInputType = {
    id?: true
    sessionId?: true
    exerciseId?: true
    orderIndex?: true
  }

  export type WorkoutSessionExerciseMaxAggregateInputType = {
    id?: true
    sessionId?: true
    exerciseId?: true
    orderIndex?: true
  }

  export type WorkoutSessionExerciseCountAggregateInputType = {
    id?: true
    sessionId?: true
    exerciseId?: true
    orderIndex?: true
    _all?: true
  }

  export type WorkoutSessionExerciseAggregateArgs = {
    /**
     * Filter which WorkoutSessionExercise to aggregate.
     * 
    **/
    where?: WorkoutSessionExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutSessionExercises to fetch.
     * 
    **/
    orderBy?: Enumerable<WorkoutSessionExerciseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: WorkoutSessionExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutSessionExercises from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutSessionExercises.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkoutSessionExercises
    **/
    _count?: true | WorkoutSessionExerciseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkoutSessionExerciseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkoutSessionExerciseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkoutSessionExerciseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkoutSessionExerciseMaxAggregateInputType
  }

  export type GetWorkoutSessionExerciseAggregateType<T extends WorkoutSessionExerciseAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkoutSessionExercise]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkoutSessionExercise[P]>
      : GetScalarType<T[P], AggregateWorkoutSessionExercise[P]>
  }




  export type WorkoutSessionExerciseGroupByArgs = {
    where?: WorkoutSessionExerciseWhereInput
    orderBy?: Enumerable<WorkoutSessionExerciseOrderByWithAggregationInput>
    by: Array<WorkoutSessionExerciseScalarFieldEnum>
    having?: WorkoutSessionExerciseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkoutSessionExerciseCountAggregateInputType | true
    _avg?: WorkoutSessionExerciseAvgAggregateInputType
    _sum?: WorkoutSessionExerciseSumAggregateInputType
    _min?: WorkoutSessionExerciseMinAggregateInputType
    _max?: WorkoutSessionExerciseMaxAggregateInputType
  }


  export type WorkoutSessionExerciseGroupByOutputType = {
    id: number
    sessionId: number
    exerciseId: number
    orderIndex: number
    _count: WorkoutSessionExerciseCountAggregateOutputType | null
    _avg: WorkoutSessionExerciseAvgAggregateOutputType | null
    _sum: WorkoutSessionExerciseSumAggregateOutputType | null
    _min: WorkoutSessionExerciseMinAggregateOutputType | null
    _max: WorkoutSessionExerciseMaxAggregateOutputType | null
  }

  type GetWorkoutSessionExerciseGroupByPayload<T extends WorkoutSessionExerciseGroupByArgs> = Promise<
    Array<
      PickArray<WorkoutSessionExerciseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkoutSessionExerciseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkoutSessionExerciseGroupByOutputType[P]>
            : GetScalarType<T[P], WorkoutSessionExerciseGroupByOutputType[P]>
        }
      >
    >


  export type WorkoutSessionExerciseSelect = {
    id?: boolean
    sessionId?: boolean
    exerciseId?: boolean
    orderIndex?: boolean
    session?: boolean | WorkoutSessionArgs
    exercise?: boolean | ExerciseArgs
    sets?: boolean | WorkoutSessionSetFindManyArgs
    _count?: boolean | WorkoutSessionExerciseCountOutputTypeArgs
  }

  export type WorkoutSessionExerciseInclude = {
    session?: boolean | WorkoutSessionArgs
    exercise?: boolean | ExerciseArgs
    sets?: boolean | WorkoutSessionSetFindManyArgs
    _count?: boolean | WorkoutSessionExerciseCountOutputTypeArgs
  }

  export type WorkoutSessionExerciseGetPayload<
    S extends boolean | null | undefined | WorkoutSessionExerciseArgs,
    U = keyof S
      > = S extends true
        ? WorkoutSessionExercise
    : S extends undefined
    ? never
    : S extends WorkoutSessionExerciseArgs | WorkoutSessionExerciseFindManyArgs
    ?'include' extends U
    ? WorkoutSessionExercise  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'session'
        ? WorkoutSessionGetPayload<S['include'][P]> :
        P extends 'exercise'
        ? ExerciseGetPayload<S['include'][P]> :
        P extends 'sets'
        ? Array < WorkoutSessionSetGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? WorkoutSessionExerciseCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof WorkoutSessionExercise ?WorkoutSessionExercise [P]
  : 
          P extends 'session'
        ? WorkoutSessionGetPayload<S['select'][P]> :
        P extends 'exercise'
        ? ExerciseGetPayload<S['select'][P]> :
        P extends 'sets'
        ? Array < WorkoutSessionSetGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? WorkoutSessionExerciseCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : WorkoutSessionExercise
  : WorkoutSessionExercise


  type WorkoutSessionExerciseCountArgs = Merge<
    Omit<WorkoutSessionExerciseFindManyArgs, 'select' | 'include'> & {
      select?: WorkoutSessionExerciseCountAggregateInputType | true
    }
  >

  export interface WorkoutSessionExerciseDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one WorkoutSessionExercise that matches the filter.
     * @param {WorkoutSessionExerciseFindUniqueArgs} args - Arguments to find a WorkoutSessionExercise
     * @example
     * // Get one WorkoutSessionExercise
     * const workoutSessionExercise = await prisma.workoutSessionExercise.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WorkoutSessionExerciseFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WorkoutSessionExerciseFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'WorkoutSessionExercise'> extends True ? CheckSelect<T, Prisma__WorkoutSessionExerciseClient<WorkoutSessionExercise>, Prisma__WorkoutSessionExerciseClient<WorkoutSessionExerciseGetPayload<T>>> : CheckSelect<T, Prisma__WorkoutSessionExerciseClient<WorkoutSessionExercise | null >, Prisma__WorkoutSessionExerciseClient<WorkoutSessionExerciseGetPayload<T> | null >>

    /**
     * Find the first WorkoutSessionExercise that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutSessionExerciseFindFirstArgs} args - Arguments to find a WorkoutSessionExercise
     * @example
     * // Get one WorkoutSessionExercise
     * const workoutSessionExercise = await prisma.workoutSessionExercise.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WorkoutSessionExerciseFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WorkoutSessionExerciseFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'WorkoutSessionExercise'> extends True ? CheckSelect<T, Prisma__WorkoutSessionExerciseClient<WorkoutSessionExercise>, Prisma__WorkoutSessionExerciseClient<WorkoutSessionExerciseGetPayload<T>>> : CheckSelect<T, Prisma__WorkoutSessionExerciseClient<WorkoutSessionExercise | null >, Prisma__WorkoutSessionExerciseClient<WorkoutSessionExerciseGetPayload<T> | null >>

    /**
     * Find zero or more WorkoutSessionExercises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutSessionExerciseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkoutSessionExercises
     * const workoutSessionExercises = await prisma.workoutSessionExercise.findMany()
     * 
     * // Get first 10 WorkoutSessionExercises
     * const workoutSessionExercises = await prisma.workoutSessionExercise.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workoutSessionExerciseWithIdOnly = await prisma.workoutSessionExercise.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WorkoutSessionExerciseFindManyArgs>(
      args?: SelectSubset<T, WorkoutSessionExerciseFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<WorkoutSessionExercise>>, PrismaPromise<Array<WorkoutSessionExerciseGetPayload<T>>>>

    /**
     * Create a WorkoutSessionExercise.
     * @param {WorkoutSessionExerciseCreateArgs} args - Arguments to create a WorkoutSessionExercise.
     * @example
     * // Create one WorkoutSessionExercise
     * const WorkoutSessionExercise = await prisma.workoutSessionExercise.create({
     *   data: {
     *     // ... data to create a WorkoutSessionExercise
     *   }
     * })
     * 
    **/
    create<T extends WorkoutSessionExerciseCreateArgs>(
      args: SelectSubset<T, WorkoutSessionExerciseCreateArgs>
    ): CheckSelect<T, Prisma__WorkoutSessionExerciseClient<WorkoutSessionExercise>, Prisma__WorkoutSessionExerciseClient<WorkoutSessionExerciseGetPayload<T>>>

    /**
     * Create many WorkoutSessionExercises.
     *     @param {WorkoutSessionExerciseCreateManyArgs} args - Arguments to create many WorkoutSessionExercises.
     *     @example
     *     // Create many WorkoutSessionExercises
     *     const workoutSessionExercise = await prisma.workoutSessionExercise.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WorkoutSessionExerciseCreateManyArgs>(
      args?: SelectSubset<T, WorkoutSessionExerciseCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a WorkoutSessionExercise.
     * @param {WorkoutSessionExerciseDeleteArgs} args - Arguments to delete one WorkoutSessionExercise.
     * @example
     * // Delete one WorkoutSessionExercise
     * const WorkoutSessionExercise = await prisma.workoutSessionExercise.delete({
     *   where: {
     *     // ... filter to delete one WorkoutSessionExercise
     *   }
     * })
     * 
    **/
    delete<T extends WorkoutSessionExerciseDeleteArgs>(
      args: SelectSubset<T, WorkoutSessionExerciseDeleteArgs>
    ): CheckSelect<T, Prisma__WorkoutSessionExerciseClient<WorkoutSessionExercise>, Prisma__WorkoutSessionExerciseClient<WorkoutSessionExerciseGetPayload<T>>>

    /**
     * Update one WorkoutSessionExercise.
     * @param {WorkoutSessionExerciseUpdateArgs} args - Arguments to update one WorkoutSessionExercise.
     * @example
     * // Update one WorkoutSessionExercise
     * const workoutSessionExercise = await prisma.workoutSessionExercise.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WorkoutSessionExerciseUpdateArgs>(
      args: SelectSubset<T, WorkoutSessionExerciseUpdateArgs>
    ): CheckSelect<T, Prisma__WorkoutSessionExerciseClient<WorkoutSessionExercise>, Prisma__WorkoutSessionExerciseClient<WorkoutSessionExerciseGetPayload<T>>>

    /**
     * Delete zero or more WorkoutSessionExercises.
     * @param {WorkoutSessionExerciseDeleteManyArgs} args - Arguments to filter WorkoutSessionExercises to delete.
     * @example
     * // Delete a few WorkoutSessionExercises
     * const { count } = await prisma.workoutSessionExercise.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WorkoutSessionExerciseDeleteManyArgs>(
      args?: SelectSubset<T, WorkoutSessionExerciseDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkoutSessionExercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutSessionExerciseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkoutSessionExercises
     * const workoutSessionExercise = await prisma.workoutSessionExercise.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WorkoutSessionExerciseUpdateManyArgs>(
      args: SelectSubset<T, WorkoutSessionExerciseUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkoutSessionExercise.
     * @param {WorkoutSessionExerciseUpsertArgs} args - Arguments to update or create a WorkoutSessionExercise.
     * @example
     * // Update or create a WorkoutSessionExercise
     * const workoutSessionExercise = await prisma.workoutSessionExercise.upsert({
     *   create: {
     *     // ... data to create a WorkoutSessionExercise
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkoutSessionExercise we want to update
     *   }
     * })
    **/
    upsert<T extends WorkoutSessionExerciseUpsertArgs>(
      args: SelectSubset<T, WorkoutSessionExerciseUpsertArgs>
    ): CheckSelect<T, Prisma__WorkoutSessionExerciseClient<WorkoutSessionExercise>, Prisma__WorkoutSessionExerciseClient<WorkoutSessionExerciseGetPayload<T>>>

    /**
     * Count the number of WorkoutSessionExercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutSessionExerciseCountArgs} args - Arguments to filter WorkoutSessionExercises to count.
     * @example
     * // Count the number of WorkoutSessionExercises
     * const count = await prisma.workoutSessionExercise.count({
     *   where: {
     *     // ... the filter for the WorkoutSessionExercises we want to count
     *   }
     * })
    **/
    count<T extends WorkoutSessionExerciseCountArgs>(
      args?: Subset<T, WorkoutSessionExerciseCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkoutSessionExerciseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkoutSessionExercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutSessionExerciseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkoutSessionExerciseAggregateArgs>(args: Subset<T, WorkoutSessionExerciseAggregateArgs>): PrismaPromise<GetWorkoutSessionExerciseAggregateType<T>>

    /**
     * Group by WorkoutSessionExercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutSessionExerciseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkoutSessionExerciseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkoutSessionExerciseGroupByArgs['orderBy'] }
        : { orderBy?: WorkoutSessionExerciseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkoutSessionExerciseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkoutSessionExerciseGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkoutSessionExercise.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WorkoutSessionExerciseClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    session<T extends WorkoutSessionArgs = {}>(args?: Subset<T, WorkoutSessionArgs>): CheckSelect<T, Prisma__WorkoutSessionClient<WorkoutSession | null >, Prisma__WorkoutSessionClient<WorkoutSessionGetPayload<T> | null >>;

    exercise<T extends ExerciseArgs = {}>(args?: Subset<T, ExerciseArgs>): CheckSelect<T, Prisma__ExerciseClient<Exercise | null >, Prisma__ExerciseClient<ExerciseGetPayload<T> | null >>;

    sets<T extends WorkoutSessionSetFindManyArgs = {}>(args?: Subset<T, WorkoutSessionSetFindManyArgs>): CheckSelect<T, PrismaPromise<Array<WorkoutSessionSet>>, PrismaPromise<Array<WorkoutSessionSetGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * WorkoutSessionExercise findUnique
   */
  export type WorkoutSessionExerciseFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the WorkoutSessionExercise
     * 
    **/
    select?: WorkoutSessionExerciseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutSessionExerciseInclude | null
    /**
     * Throw an Error if a WorkoutSessionExercise can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which WorkoutSessionExercise to fetch.
     * 
    **/
    where: WorkoutSessionExerciseWhereUniqueInput
  }


  /**
   * WorkoutSessionExercise findFirst
   */
  export type WorkoutSessionExerciseFindFirstArgs = {
    /**
     * Select specific fields to fetch from the WorkoutSessionExercise
     * 
    **/
    select?: WorkoutSessionExerciseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutSessionExerciseInclude | null
    /**
     * Throw an Error if a WorkoutSessionExercise can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which WorkoutSessionExercise to fetch.
     * 
    **/
    where?: WorkoutSessionExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutSessionExercises to fetch.
     * 
    **/
    orderBy?: Enumerable<WorkoutSessionExerciseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkoutSessionExercises.
     * 
    **/
    cursor?: WorkoutSessionExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutSessionExercises from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutSessionExercises.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkoutSessionExercises.
     * 
    **/
    distinct?: Enumerable<WorkoutSessionExerciseScalarFieldEnum>
  }


  /**
   * WorkoutSessionExercise findMany
   */
  export type WorkoutSessionExerciseFindManyArgs = {
    /**
     * Select specific fields to fetch from the WorkoutSessionExercise
     * 
    **/
    select?: WorkoutSessionExerciseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutSessionExerciseInclude | null
    /**
     * Filter, which WorkoutSessionExercises to fetch.
     * 
    **/
    where?: WorkoutSessionExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutSessionExercises to fetch.
     * 
    **/
    orderBy?: Enumerable<WorkoutSessionExerciseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkoutSessionExercises.
     * 
    **/
    cursor?: WorkoutSessionExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutSessionExercises from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutSessionExercises.
     * 
    **/
    skip?: number
    distinct?: Enumerable<WorkoutSessionExerciseScalarFieldEnum>
  }


  /**
   * WorkoutSessionExercise create
   */
  export type WorkoutSessionExerciseCreateArgs = {
    /**
     * Select specific fields to fetch from the WorkoutSessionExercise
     * 
    **/
    select?: WorkoutSessionExerciseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutSessionExerciseInclude | null
    /**
     * The data needed to create a WorkoutSessionExercise.
     * 
    **/
    data: XOR<WorkoutSessionExerciseCreateInput, WorkoutSessionExerciseUncheckedCreateInput>
  }


  /**
   * WorkoutSessionExercise createMany
   */
  export type WorkoutSessionExerciseCreateManyArgs = {
    data: Enumerable<WorkoutSessionExerciseCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * WorkoutSessionExercise update
   */
  export type WorkoutSessionExerciseUpdateArgs = {
    /**
     * Select specific fields to fetch from the WorkoutSessionExercise
     * 
    **/
    select?: WorkoutSessionExerciseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutSessionExerciseInclude | null
    /**
     * The data needed to update a WorkoutSessionExercise.
     * 
    **/
    data: XOR<WorkoutSessionExerciseUpdateInput, WorkoutSessionExerciseUncheckedUpdateInput>
    /**
     * Choose, which WorkoutSessionExercise to update.
     * 
    **/
    where: WorkoutSessionExerciseWhereUniqueInput
  }


  /**
   * WorkoutSessionExercise updateMany
   */
  export type WorkoutSessionExerciseUpdateManyArgs = {
    data: XOR<WorkoutSessionExerciseUpdateManyMutationInput, WorkoutSessionExerciseUncheckedUpdateManyInput>
    where?: WorkoutSessionExerciseWhereInput
  }


  /**
   * WorkoutSessionExercise upsert
   */
  export type WorkoutSessionExerciseUpsertArgs = {
    /**
     * Select specific fields to fetch from the WorkoutSessionExercise
     * 
    **/
    select?: WorkoutSessionExerciseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutSessionExerciseInclude | null
    /**
     * The filter to search for the WorkoutSessionExercise to update in case it exists.
     * 
    **/
    where: WorkoutSessionExerciseWhereUniqueInput
    /**
     * In case the WorkoutSessionExercise found by the `where` argument doesn't exist, create a new WorkoutSessionExercise with this data.
     * 
    **/
    create: XOR<WorkoutSessionExerciseCreateInput, WorkoutSessionExerciseUncheckedCreateInput>
    /**
     * In case the WorkoutSessionExercise was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<WorkoutSessionExerciseUpdateInput, WorkoutSessionExerciseUncheckedUpdateInput>
  }


  /**
   * WorkoutSessionExercise delete
   */
  export type WorkoutSessionExerciseDeleteArgs = {
    /**
     * Select specific fields to fetch from the WorkoutSessionExercise
     * 
    **/
    select?: WorkoutSessionExerciseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutSessionExerciseInclude | null
    /**
     * Filter which WorkoutSessionExercise to delete.
     * 
    **/
    where: WorkoutSessionExerciseWhereUniqueInput
  }


  /**
   * WorkoutSessionExercise deleteMany
   */
  export type WorkoutSessionExerciseDeleteManyArgs = {
    where?: WorkoutSessionExerciseWhereInput
  }


  /**
   * WorkoutSessionExercise without action
   */
  export type WorkoutSessionExerciseArgs = {
    /**
     * Select specific fields to fetch from the WorkoutSessionExercise
     * 
    **/
    select?: WorkoutSessionExerciseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutSessionExerciseInclude | null
  }



  /**
   * Model WorkoutSessionSet
   */


  export type AggregateWorkoutSessionSet = {
    _count: WorkoutSessionSetCountAggregateOutputType | null
    _avg: WorkoutSessionSetAvgAggregateOutputType | null
    _sum: WorkoutSessionSetSumAggregateOutputType | null
    _min: WorkoutSessionSetMinAggregateOutputType | null
    _max: WorkoutSessionSetMaxAggregateOutputType | null
  }

  export type WorkoutSessionSetAvgAggregateOutputType = {
    id: number | null
    sessionExerciseId: number | null
    setIndex: number | null
    reps: number | null
    weightKg: number | null
    rpe: number | null
  }

  export type WorkoutSessionSetSumAggregateOutputType = {
    id: number | null
    sessionExerciseId: number | null
    setIndex: number | null
    reps: number | null
    weightKg: number | null
    rpe: number | null
  }

  export type WorkoutSessionSetMinAggregateOutputType = {
    id: number | null
    sessionExerciseId: number | null
    setIndex: number | null
    reps: number | null
    weightKg: number | null
    rpe: number | null
    notes: string | null
  }

  export type WorkoutSessionSetMaxAggregateOutputType = {
    id: number | null
    sessionExerciseId: number | null
    setIndex: number | null
    reps: number | null
    weightKg: number | null
    rpe: number | null
    notes: string | null
  }

  export type WorkoutSessionSetCountAggregateOutputType = {
    id: number
    sessionExerciseId: number
    setIndex: number
    reps: number
    weightKg: number
    rpe: number
    notes: number
    _all: number
  }


  export type WorkoutSessionSetAvgAggregateInputType = {
    id?: true
    sessionExerciseId?: true
    setIndex?: true
    reps?: true
    weightKg?: true
    rpe?: true
  }

  export type WorkoutSessionSetSumAggregateInputType = {
    id?: true
    sessionExerciseId?: true
    setIndex?: true
    reps?: true
    weightKg?: true
    rpe?: true
  }

  export type WorkoutSessionSetMinAggregateInputType = {
    id?: true
    sessionExerciseId?: true
    setIndex?: true
    reps?: true
    weightKg?: true
    rpe?: true
    notes?: true
  }

  export type WorkoutSessionSetMaxAggregateInputType = {
    id?: true
    sessionExerciseId?: true
    setIndex?: true
    reps?: true
    weightKg?: true
    rpe?: true
    notes?: true
  }

  export type WorkoutSessionSetCountAggregateInputType = {
    id?: true
    sessionExerciseId?: true
    setIndex?: true
    reps?: true
    weightKg?: true
    rpe?: true
    notes?: true
    _all?: true
  }

  export type WorkoutSessionSetAggregateArgs = {
    /**
     * Filter which WorkoutSessionSet to aggregate.
     * 
    **/
    where?: WorkoutSessionSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutSessionSets to fetch.
     * 
    **/
    orderBy?: Enumerable<WorkoutSessionSetOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: WorkoutSessionSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutSessionSets from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutSessionSets.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkoutSessionSets
    **/
    _count?: true | WorkoutSessionSetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkoutSessionSetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkoutSessionSetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkoutSessionSetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkoutSessionSetMaxAggregateInputType
  }

  export type GetWorkoutSessionSetAggregateType<T extends WorkoutSessionSetAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkoutSessionSet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkoutSessionSet[P]>
      : GetScalarType<T[P], AggregateWorkoutSessionSet[P]>
  }




  export type WorkoutSessionSetGroupByArgs = {
    where?: WorkoutSessionSetWhereInput
    orderBy?: Enumerable<WorkoutSessionSetOrderByWithAggregationInput>
    by: Array<WorkoutSessionSetScalarFieldEnum>
    having?: WorkoutSessionSetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkoutSessionSetCountAggregateInputType | true
    _avg?: WorkoutSessionSetAvgAggregateInputType
    _sum?: WorkoutSessionSetSumAggregateInputType
    _min?: WorkoutSessionSetMinAggregateInputType
    _max?: WorkoutSessionSetMaxAggregateInputType
  }


  export type WorkoutSessionSetGroupByOutputType = {
    id: number
    sessionExerciseId: number
    setIndex: number
    reps: number
    weightKg: number
    rpe: number | null
    notes: string | null
    _count: WorkoutSessionSetCountAggregateOutputType | null
    _avg: WorkoutSessionSetAvgAggregateOutputType | null
    _sum: WorkoutSessionSetSumAggregateOutputType | null
    _min: WorkoutSessionSetMinAggregateOutputType | null
    _max: WorkoutSessionSetMaxAggregateOutputType | null
  }

  type GetWorkoutSessionSetGroupByPayload<T extends WorkoutSessionSetGroupByArgs> = Promise<
    Array<
      PickArray<WorkoutSessionSetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkoutSessionSetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkoutSessionSetGroupByOutputType[P]>
            : GetScalarType<T[P], WorkoutSessionSetGroupByOutputType[P]>
        }
      >
    >


  export type WorkoutSessionSetSelect = {
    id?: boolean
    sessionExerciseId?: boolean
    setIndex?: boolean
    reps?: boolean
    weightKg?: boolean
    rpe?: boolean
    notes?: boolean
    sessionExercise?: boolean | WorkoutSessionExerciseArgs
  }

  export type WorkoutSessionSetInclude = {
    sessionExercise?: boolean | WorkoutSessionExerciseArgs
  }

  export type WorkoutSessionSetGetPayload<
    S extends boolean | null | undefined | WorkoutSessionSetArgs,
    U = keyof S
      > = S extends true
        ? WorkoutSessionSet
    : S extends undefined
    ? never
    : S extends WorkoutSessionSetArgs | WorkoutSessionSetFindManyArgs
    ?'include' extends U
    ? WorkoutSessionSet  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'sessionExercise'
        ? WorkoutSessionExerciseGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof WorkoutSessionSet ?WorkoutSessionSet [P]
  : 
          P extends 'sessionExercise'
        ? WorkoutSessionExerciseGetPayload<S['select'][P]> : never
  } 
    : WorkoutSessionSet
  : WorkoutSessionSet


  type WorkoutSessionSetCountArgs = Merge<
    Omit<WorkoutSessionSetFindManyArgs, 'select' | 'include'> & {
      select?: WorkoutSessionSetCountAggregateInputType | true
    }
  >

  export interface WorkoutSessionSetDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one WorkoutSessionSet that matches the filter.
     * @param {WorkoutSessionSetFindUniqueArgs} args - Arguments to find a WorkoutSessionSet
     * @example
     * // Get one WorkoutSessionSet
     * const workoutSessionSet = await prisma.workoutSessionSet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WorkoutSessionSetFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WorkoutSessionSetFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'WorkoutSessionSet'> extends True ? CheckSelect<T, Prisma__WorkoutSessionSetClient<WorkoutSessionSet>, Prisma__WorkoutSessionSetClient<WorkoutSessionSetGetPayload<T>>> : CheckSelect<T, Prisma__WorkoutSessionSetClient<WorkoutSessionSet | null >, Prisma__WorkoutSessionSetClient<WorkoutSessionSetGetPayload<T> | null >>

    /**
     * Find the first WorkoutSessionSet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutSessionSetFindFirstArgs} args - Arguments to find a WorkoutSessionSet
     * @example
     * // Get one WorkoutSessionSet
     * const workoutSessionSet = await prisma.workoutSessionSet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WorkoutSessionSetFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WorkoutSessionSetFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'WorkoutSessionSet'> extends True ? CheckSelect<T, Prisma__WorkoutSessionSetClient<WorkoutSessionSet>, Prisma__WorkoutSessionSetClient<WorkoutSessionSetGetPayload<T>>> : CheckSelect<T, Prisma__WorkoutSessionSetClient<WorkoutSessionSet | null >, Prisma__WorkoutSessionSetClient<WorkoutSessionSetGetPayload<T> | null >>

    /**
     * Find zero or more WorkoutSessionSets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutSessionSetFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkoutSessionSets
     * const workoutSessionSets = await prisma.workoutSessionSet.findMany()
     * 
     * // Get first 10 WorkoutSessionSets
     * const workoutSessionSets = await prisma.workoutSessionSet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workoutSessionSetWithIdOnly = await prisma.workoutSessionSet.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WorkoutSessionSetFindManyArgs>(
      args?: SelectSubset<T, WorkoutSessionSetFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<WorkoutSessionSet>>, PrismaPromise<Array<WorkoutSessionSetGetPayload<T>>>>

    /**
     * Create a WorkoutSessionSet.
     * @param {WorkoutSessionSetCreateArgs} args - Arguments to create a WorkoutSessionSet.
     * @example
     * // Create one WorkoutSessionSet
     * const WorkoutSessionSet = await prisma.workoutSessionSet.create({
     *   data: {
     *     // ... data to create a WorkoutSessionSet
     *   }
     * })
     * 
    **/
    create<T extends WorkoutSessionSetCreateArgs>(
      args: SelectSubset<T, WorkoutSessionSetCreateArgs>
    ): CheckSelect<T, Prisma__WorkoutSessionSetClient<WorkoutSessionSet>, Prisma__WorkoutSessionSetClient<WorkoutSessionSetGetPayload<T>>>

    /**
     * Create many WorkoutSessionSets.
     *     @param {WorkoutSessionSetCreateManyArgs} args - Arguments to create many WorkoutSessionSets.
     *     @example
     *     // Create many WorkoutSessionSets
     *     const workoutSessionSet = await prisma.workoutSessionSet.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WorkoutSessionSetCreateManyArgs>(
      args?: SelectSubset<T, WorkoutSessionSetCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a WorkoutSessionSet.
     * @param {WorkoutSessionSetDeleteArgs} args - Arguments to delete one WorkoutSessionSet.
     * @example
     * // Delete one WorkoutSessionSet
     * const WorkoutSessionSet = await prisma.workoutSessionSet.delete({
     *   where: {
     *     // ... filter to delete one WorkoutSessionSet
     *   }
     * })
     * 
    **/
    delete<T extends WorkoutSessionSetDeleteArgs>(
      args: SelectSubset<T, WorkoutSessionSetDeleteArgs>
    ): CheckSelect<T, Prisma__WorkoutSessionSetClient<WorkoutSessionSet>, Prisma__WorkoutSessionSetClient<WorkoutSessionSetGetPayload<T>>>

    /**
     * Update one WorkoutSessionSet.
     * @param {WorkoutSessionSetUpdateArgs} args - Arguments to update one WorkoutSessionSet.
     * @example
     * // Update one WorkoutSessionSet
     * const workoutSessionSet = await prisma.workoutSessionSet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WorkoutSessionSetUpdateArgs>(
      args: SelectSubset<T, WorkoutSessionSetUpdateArgs>
    ): CheckSelect<T, Prisma__WorkoutSessionSetClient<WorkoutSessionSet>, Prisma__WorkoutSessionSetClient<WorkoutSessionSetGetPayload<T>>>

    /**
     * Delete zero or more WorkoutSessionSets.
     * @param {WorkoutSessionSetDeleteManyArgs} args - Arguments to filter WorkoutSessionSets to delete.
     * @example
     * // Delete a few WorkoutSessionSets
     * const { count } = await prisma.workoutSessionSet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WorkoutSessionSetDeleteManyArgs>(
      args?: SelectSubset<T, WorkoutSessionSetDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkoutSessionSets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutSessionSetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkoutSessionSets
     * const workoutSessionSet = await prisma.workoutSessionSet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WorkoutSessionSetUpdateManyArgs>(
      args: SelectSubset<T, WorkoutSessionSetUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkoutSessionSet.
     * @param {WorkoutSessionSetUpsertArgs} args - Arguments to update or create a WorkoutSessionSet.
     * @example
     * // Update or create a WorkoutSessionSet
     * const workoutSessionSet = await prisma.workoutSessionSet.upsert({
     *   create: {
     *     // ... data to create a WorkoutSessionSet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkoutSessionSet we want to update
     *   }
     * })
    **/
    upsert<T extends WorkoutSessionSetUpsertArgs>(
      args: SelectSubset<T, WorkoutSessionSetUpsertArgs>
    ): CheckSelect<T, Prisma__WorkoutSessionSetClient<WorkoutSessionSet>, Prisma__WorkoutSessionSetClient<WorkoutSessionSetGetPayload<T>>>

    /**
     * Count the number of WorkoutSessionSets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutSessionSetCountArgs} args - Arguments to filter WorkoutSessionSets to count.
     * @example
     * // Count the number of WorkoutSessionSets
     * const count = await prisma.workoutSessionSet.count({
     *   where: {
     *     // ... the filter for the WorkoutSessionSets we want to count
     *   }
     * })
    **/
    count<T extends WorkoutSessionSetCountArgs>(
      args?: Subset<T, WorkoutSessionSetCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkoutSessionSetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkoutSessionSet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutSessionSetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkoutSessionSetAggregateArgs>(args: Subset<T, WorkoutSessionSetAggregateArgs>): PrismaPromise<GetWorkoutSessionSetAggregateType<T>>

    /**
     * Group by WorkoutSessionSet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutSessionSetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkoutSessionSetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkoutSessionSetGroupByArgs['orderBy'] }
        : { orderBy?: WorkoutSessionSetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkoutSessionSetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkoutSessionSetGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkoutSessionSet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WorkoutSessionSetClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    sessionExercise<T extends WorkoutSessionExerciseArgs = {}>(args?: Subset<T, WorkoutSessionExerciseArgs>): CheckSelect<T, Prisma__WorkoutSessionExerciseClient<WorkoutSessionExercise | null >, Prisma__WorkoutSessionExerciseClient<WorkoutSessionExerciseGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * WorkoutSessionSet findUnique
   */
  export type WorkoutSessionSetFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the WorkoutSessionSet
     * 
    **/
    select?: WorkoutSessionSetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutSessionSetInclude | null
    /**
     * Throw an Error if a WorkoutSessionSet can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which WorkoutSessionSet to fetch.
     * 
    **/
    where: WorkoutSessionSetWhereUniqueInput
  }


  /**
   * WorkoutSessionSet findFirst
   */
  export type WorkoutSessionSetFindFirstArgs = {
    /**
     * Select specific fields to fetch from the WorkoutSessionSet
     * 
    **/
    select?: WorkoutSessionSetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutSessionSetInclude | null
    /**
     * Throw an Error if a WorkoutSessionSet can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which WorkoutSessionSet to fetch.
     * 
    **/
    where?: WorkoutSessionSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutSessionSets to fetch.
     * 
    **/
    orderBy?: Enumerable<WorkoutSessionSetOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkoutSessionSets.
     * 
    **/
    cursor?: WorkoutSessionSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutSessionSets from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutSessionSets.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkoutSessionSets.
     * 
    **/
    distinct?: Enumerable<WorkoutSessionSetScalarFieldEnum>
  }


  /**
   * WorkoutSessionSet findMany
   */
  export type WorkoutSessionSetFindManyArgs = {
    /**
     * Select specific fields to fetch from the WorkoutSessionSet
     * 
    **/
    select?: WorkoutSessionSetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutSessionSetInclude | null
    /**
     * Filter, which WorkoutSessionSets to fetch.
     * 
    **/
    where?: WorkoutSessionSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutSessionSets to fetch.
     * 
    **/
    orderBy?: Enumerable<WorkoutSessionSetOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkoutSessionSets.
     * 
    **/
    cursor?: WorkoutSessionSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutSessionSets from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutSessionSets.
     * 
    **/
    skip?: number
    distinct?: Enumerable<WorkoutSessionSetScalarFieldEnum>
  }


  /**
   * WorkoutSessionSet create
   */
  export type WorkoutSessionSetCreateArgs = {
    /**
     * Select specific fields to fetch from the WorkoutSessionSet
     * 
    **/
    select?: WorkoutSessionSetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutSessionSetInclude | null
    /**
     * The data needed to create a WorkoutSessionSet.
     * 
    **/
    data: XOR<WorkoutSessionSetCreateInput, WorkoutSessionSetUncheckedCreateInput>
  }


  /**
   * WorkoutSessionSet createMany
   */
  export type WorkoutSessionSetCreateManyArgs = {
    data: Enumerable<WorkoutSessionSetCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * WorkoutSessionSet update
   */
  export type WorkoutSessionSetUpdateArgs = {
    /**
     * Select specific fields to fetch from the WorkoutSessionSet
     * 
    **/
    select?: WorkoutSessionSetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutSessionSetInclude | null
    /**
     * The data needed to update a WorkoutSessionSet.
     * 
    **/
    data: XOR<WorkoutSessionSetUpdateInput, WorkoutSessionSetUncheckedUpdateInput>
    /**
     * Choose, which WorkoutSessionSet to update.
     * 
    **/
    where: WorkoutSessionSetWhereUniqueInput
  }


  /**
   * WorkoutSessionSet updateMany
   */
  export type WorkoutSessionSetUpdateManyArgs = {
    data: XOR<WorkoutSessionSetUpdateManyMutationInput, WorkoutSessionSetUncheckedUpdateManyInput>
    where?: WorkoutSessionSetWhereInput
  }


  /**
   * WorkoutSessionSet upsert
   */
  export type WorkoutSessionSetUpsertArgs = {
    /**
     * Select specific fields to fetch from the WorkoutSessionSet
     * 
    **/
    select?: WorkoutSessionSetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutSessionSetInclude | null
    /**
     * The filter to search for the WorkoutSessionSet to update in case it exists.
     * 
    **/
    where: WorkoutSessionSetWhereUniqueInput
    /**
     * In case the WorkoutSessionSet found by the `where` argument doesn't exist, create a new WorkoutSessionSet with this data.
     * 
    **/
    create: XOR<WorkoutSessionSetCreateInput, WorkoutSessionSetUncheckedCreateInput>
    /**
     * In case the WorkoutSessionSet was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<WorkoutSessionSetUpdateInput, WorkoutSessionSetUncheckedUpdateInput>
  }


  /**
   * WorkoutSessionSet delete
   */
  export type WorkoutSessionSetDeleteArgs = {
    /**
     * Select specific fields to fetch from the WorkoutSessionSet
     * 
    **/
    select?: WorkoutSessionSetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutSessionSetInclude | null
    /**
     * Filter which WorkoutSessionSet to delete.
     * 
    **/
    where: WorkoutSessionSetWhereUniqueInput
  }


  /**
   * WorkoutSessionSet deleteMany
   */
  export type WorkoutSessionSetDeleteManyArgs = {
    where?: WorkoutSessionSetWhereInput
  }


  /**
   * WorkoutSessionSet without action
   */
  export type WorkoutSessionSetArgs = {
    /**
     * Select specific fields to fetch from the WorkoutSessionSet
     * 
    **/
    select?: WorkoutSessionSetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutSessionSetInclude | null
  }



  /**
   * Model Workout
   */


  export type AggregateWorkout = {
    _count: WorkoutCountAggregateOutputType | null
    _avg: WorkoutAvgAggregateOutputType | null
    _sum: WorkoutSumAggregateOutputType | null
    _min: WorkoutMinAggregateOutputType | null
    _max: WorkoutMaxAggregateOutputType | null
  }

  export type WorkoutAvgAggregateOutputType = {
    id: number | null
    durationMinutes: number | null
    athleteId: number | null
    workoutPlanId: number | null
  }

  export type WorkoutSumAggregateOutputType = {
    id: number | null
    durationMinutes: number | null
    athleteId: number | null
    workoutPlanId: number | null
  }

  export type WorkoutMinAggregateOutputType = {
    id: number | null
    date: Date | null
    durationMinutes: number | null
    notes: string | null
    createdAt: Date | null
    athleteId: number | null
    workoutPlanId: number | null
  }

  export type WorkoutMaxAggregateOutputType = {
    id: number | null
    date: Date | null
    durationMinutes: number | null
    notes: string | null
    createdAt: Date | null
    athleteId: number | null
    workoutPlanId: number | null
  }

  export type WorkoutCountAggregateOutputType = {
    id: number
    date: number
    durationMinutes: number
    notes: number
    createdAt: number
    athleteId: number
    workoutPlanId: number
    _all: number
  }


  export type WorkoutAvgAggregateInputType = {
    id?: true
    durationMinutes?: true
    athleteId?: true
    workoutPlanId?: true
  }

  export type WorkoutSumAggregateInputType = {
    id?: true
    durationMinutes?: true
    athleteId?: true
    workoutPlanId?: true
  }

  export type WorkoutMinAggregateInputType = {
    id?: true
    date?: true
    durationMinutes?: true
    notes?: true
    createdAt?: true
    athleteId?: true
    workoutPlanId?: true
  }

  export type WorkoutMaxAggregateInputType = {
    id?: true
    date?: true
    durationMinutes?: true
    notes?: true
    createdAt?: true
    athleteId?: true
    workoutPlanId?: true
  }

  export type WorkoutCountAggregateInputType = {
    id?: true
    date?: true
    durationMinutes?: true
    notes?: true
    createdAt?: true
    athleteId?: true
    workoutPlanId?: true
    _all?: true
  }

  export type WorkoutAggregateArgs = {
    /**
     * Filter which Workout to aggregate.
     * 
    **/
    where?: WorkoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workouts to fetch.
     * 
    **/
    orderBy?: Enumerable<WorkoutOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: WorkoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workouts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workouts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Workouts
    **/
    _count?: true | WorkoutCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkoutAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkoutSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkoutMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkoutMaxAggregateInputType
  }

  export type GetWorkoutAggregateType<T extends WorkoutAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkout]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkout[P]>
      : GetScalarType<T[P], AggregateWorkout[P]>
  }




  export type WorkoutGroupByArgs = {
    where?: WorkoutWhereInput
    orderBy?: Enumerable<WorkoutOrderByWithAggregationInput>
    by: Array<WorkoutScalarFieldEnum>
    having?: WorkoutScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkoutCountAggregateInputType | true
    _avg?: WorkoutAvgAggregateInputType
    _sum?: WorkoutSumAggregateInputType
    _min?: WorkoutMinAggregateInputType
    _max?: WorkoutMaxAggregateInputType
  }


  export type WorkoutGroupByOutputType = {
    id: number
    date: Date
    durationMinutes: number
    notes: string | null
    createdAt: Date
    athleteId: number
    workoutPlanId: number | null
    _count: WorkoutCountAggregateOutputType | null
    _avg: WorkoutAvgAggregateOutputType | null
    _sum: WorkoutSumAggregateOutputType | null
    _min: WorkoutMinAggregateOutputType | null
    _max: WorkoutMaxAggregateOutputType | null
  }

  type GetWorkoutGroupByPayload<T extends WorkoutGroupByArgs> = Promise<
    Array<
      PickArray<WorkoutGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkoutGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkoutGroupByOutputType[P]>
            : GetScalarType<T[P], WorkoutGroupByOutputType[P]>
        }
      >
    >


  export type WorkoutSelect = {
    id?: boolean
    date?: boolean
    durationMinutes?: boolean
    notes?: boolean
    createdAt?: boolean
    athleteId?: boolean
    workoutPlanId?: boolean
    athlete?: boolean | UserArgs
    workoutPlan?: boolean | WorkoutPlanArgs
    workoutExercises?: boolean | WorkoutExerciseFindManyArgs
    _count?: boolean | WorkoutCountOutputTypeArgs
  }

  export type WorkoutInclude = {
    athlete?: boolean | UserArgs
    workoutPlan?: boolean | WorkoutPlanArgs
    workoutExercises?: boolean | WorkoutExerciseFindManyArgs
    _count?: boolean | WorkoutCountOutputTypeArgs
  }

  export type WorkoutGetPayload<
    S extends boolean | null | undefined | WorkoutArgs,
    U = keyof S
      > = S extends true
        ? Workout
    : S extends undefined
    ? never
    : S extends WorkoutArgs | WorkoutFindManyArgs
    ?'include' extends U
    ? Workout  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'athlete'
        ? UserGetPayload<S['include'][P]> :
        P extends 'workoutPlan'
        ? WorkoutPlanGetPayload<S['include'][P]> | null :
        P extends 'workoutExercises'
        ? Array < WorkoutExerciseGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? WorkoutCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Workout ?Workout [P]
  : 
          P extends 'athlete'
        ? UserGetPayload<S['select'][P]> :
        P extends 'workoutPlan'
        ? WorkoutPlanGetPayload<S['select'][P]> | null :
        P extends 'workoutExercises'
        ? Array < WorkoutExerciseGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? WorkoutCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : Workout
  : Workout


  type WorkoutCountArgs = Merge<
    Omit<WorkoutFindManyArgs, 'select' | 'include'> & {
      select?: WorkoutCountAggregateInputType | true
    }
  >

  export interface WorkoutDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Workout that matches the filter.
     * @param {WorkoutFindUniqueArgs} args - Arguments to find a Workout
     * @example
     * // Get one Workout
     * const workout = await prisma.workout.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WorkoutFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WorkoutFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Workout'> extends True ? CheckSelect<T, Prisma__WorkoutClient<Workout>, Prisma__WorkoutClient<WorkoutGetPayload<T>>> : CheckSelect<T, Prisma__WorkoutClient<Workout | null >, Prisma__WorkoutClient<WorkoutGetPayload<T> | null >>

    /**
     * Find the first Workout that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutFindFirstArgs} args - Arguments to find a Workout
     * @example
     * // Get one Workout
     * const workout = await prisma.workout.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WorkoutFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WorkoutFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Workout'> extends True ? CheckSelect<T, Prisma__WorkoutClient<Workout>, Prisma__WorkoutClient<WorkoutGetPayload<T>>> : CheckSelect<T, Prisma__WorkoutClient<Workout | null >, Prisma__WorkoutClient<WorkoutGetPayload<T> | null >>

    /**
     * Find zero or more Workouts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workouts
     * const workouts = await prisma.workout.findMany()
     * 
     * // Get first 10 Workouts
     * const workouts = await prisma.workout.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workoutWithIdOnly = await prisma.workout.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WorkoutFindManyArgs>(
      args?: SelectSubset<T, WorkoutFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Workout>>, PrismaPromise<Array<WorkoutGetPayload<T>>>>

    /**
     * Create a Workout.
     * @param {WorkoutCreateArgs} args - Arguments to create a Workout.
     * @example
     * // Create one Workout
     * const Workout = await prisma.workout.create({
     *   data: {
     *     // ... data to create a Workout
     *   }
     * })
     * 
    **/
    create<T extends WorkoutCreateArgs>(
      args: SelectSubset<T, WorkoutCreateArgs>
    ): CheckSelect<T, Prisma__WorkoutClient<Workout>, Prisma__WorkoutClient<WorkoutGetPayload<T>>>

    /**
     * Create many Workouts.
     *     @param {WorkoutCreateManyArgs} args - Arguments to create many Workouts.
     *     @example
     *     // Create many Workouts
     *     const workout = await prisma.workout.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WorkoutCreateManyArgs>(
      args?: SelectSubset<T, WorkoutCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Workout.
     * @param {WorkoutDeleteArgs} args - Arguments to delete one Workout.
     * @example
     * // Delete one Workout
     * const Workout = await prisma.workout.delete({
     *   where: {
     *     // ... filter to delete one Workout
     *   }
     * })
     * 
    **/
    delete<T extends WorkoutDeleteArgs>(
      args: SelectSubset<T, WorkoutDeleteArgs>
    ): CheckSelect<T, Prisma__WorkoutClient<Workout>, Prisma__WorkoutClient<WorkoutGetPayload<T>>>

    /**
     * Update one Workout.
     * @param {WorkoutUpdateArgs} args - Arguments to update one Workout.
     * @example
     * // Update one Workout
     * const workout = await prisma.workout.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WorkoutUpdateArgs>(
      args: SelectSubset<T, WorkoutUpdateArgs>
    ): CheckSelect<T, Prisma__WorkoutClient<Workout>, Prisma__WorkoutClient<WorkoutGetPayload<T>>>

    /**
     * Delete zero or more Workouts.
     * @param {WorkoutDeleteManyArgs} args - Arguments to filter Workouts to delete.
     * @example
     * // Delete a few Workouts
     * const { count } = await prisma.workout.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WorkoutDeleteManyArgs>(
      args?: SelectSubset<T, WorkoutDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workouts
     * const workout = await prisma.workout.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WorkoutUpdateManyArgs>(
      args: SelectSubset<T, WorkoutUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Workout.
     * @param {WorkoutUpsertArgs} args - Arguments to update or create a Workout.
     * @example
     * // Update or create a Workout
     * const workout = await prisma.workout.upsert({
     *   create: {
     *     // ... data to create a Workout
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Workout we want to update
     *   }
     * })
    **/
    upsert<T extends WorkoutUpsertArgs>(
      args: SelectSubset<T, WorkoutUpsertArgs>
    ): CheckSelect<T, Prisma__WorkoutClient<Workout>, Prisma__WorkoutClient<WorkoutGetPayload<T>>>

    /**
     * Count the number of Workouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutCountArgs} args - Arguments to filter Workouts to count.
     * @example
     * // Count the number of Workouts
     * const count = await prisma.workout.count({
     *   where: {
     *     // ... the filter for the Workouts we want to count
     *   }
     * })
    **/
    count<T extends WorkoutCountArgs>(
      args?: Subset<T, WorkoutCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkoutCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Workout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkoutAggregateArgs>(args: Subset<T, WorkoutAggregateArgs>): PrismaPromise<GetWorkoutAggregateType<T>>

    /**
     * Group by Workout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkoutGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkoutGroupByArgs['orderBy'] }
        : { orderBy?: WorkoutGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkoutGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkoutGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Workout.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WorkoutClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    athlete<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    workoutPlan<T extends WorkoutPlanArgs = {}>(args?: Subset<T, WorkoutPlanArgs>): CheckSelect<T, Prisma__WorkoutPlanClient<WorkoutPlan | null >, Prisma__WorkoutPlanClient<WorkoutPlanGetPayload<T> | null >>;

    workoutExercises<T extends WorkoutExerciseFindManyArgs = {}>(args?: Subset<T, WorkoutExerciseFindManyArgs>): CheckSelect<T, PrismaPromise<Array<WorkoutExercise>>, PrismaPromise<Array<WorkoutExerciseGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Workout findUnique
   */
  export type WorkoutFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Workout
     * 
    **/
    select?: WorkoutSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutInclude | null
    /**
     * Throw an Error if a Workout can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Workout to fetch.
     * 
    **/
    where: WorkoutWhereUniqueInput
  }


  /**
   * Workout findFirst
   */
  export type WorkoutFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Workout
     * 
    **/
    select?: WorkoutSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutInclude | null
    /**
     * Throw an Error if a Workout can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Workout to fetch.
     * 
    **/
    where?: WorkoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workouts to fetch.
     * 
    **/
    orderBy?: Enumerable<WorkoutOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workouts.
     * 
    **/
    cursor?: WorkoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workouts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workouts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workouts.
     * 
    **/
    distinct?: Enumerable<WorkoutScalarFieldEnum>
  }


  /**
   * Workout findMany
   */
  export type WorkoutFindManyArgs = {
    /**
     * Select specific fields to fetch from the Workout
     * 
    **/
    select?: WorkoutSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutInclude | null
    /**
     * Filter, which Workouts to fetch.
     * 
    **/
    where?: WorkoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workouts to fetch.
     * 
    **/
    orderBy?: Enumerable<WorkoutOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Workouts.
     * 
    **/
    cursor?: WorkoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workouts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workouts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<WorkoutScalarFieldEnum>
  }


  /**
   * Workout create
   */
  export type WorkoutCreateArgs = {
    /**
     * Select specific fields to fetch from the Workout
     * 
    **/
    select?: WorkoutSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutInclude | null
    /**
     * The data needed to create a Workout.
     * 
    **/
    data: XOR<WorkoutCreateInput, WorkoutUncheckedCreateInput>
  }


  /**
   * Workout createMany
   */
  export type WorkoutCreateManyArgs = {
    data: Enumerable<WorkoutCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Workout update
   */
  export type WorkoutUpdateArgs = {
    /**
     * Select specific fields to fetch from the Workout
     * 
    **/
    select?: WorkoutSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutInclude | null
    /**
     * The data needed to update a Workout.
     * 
    **/
    data: XOR<WorkoutUpdateInput, WorkoutUncheckedUpdateInput>
    /**
     * Choose, which Workout to update.
     * 
    **/
    where: WorkoutWhereUniqueInput
  }


  /**
   * Workout updateMany
   */
  export type WorkoutUpdateManyArgs = {
    data: XOR<WorkoutUpdateManyMutationInput, WorkoutUncheckedUpdateManyInput>
    where?: WorkoutWhereInput
  }


  /**
   * Workout upsert
   */
  export type WorkoutUpsertArgs = {
    /**
     * Select specific fields to fetch from the Workout
     * 
    **/
    select?: WorkoutSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutInclude | null
    /**
     * The filter to search for the Workout to update in case it exists.
     * 
    **/
    where: WorkoutWhereUniqueInput
    /**
     * In case the Workout found by the `where` argument doesn't exist, create a new Workout with this data.
     * 
    **/
    create: XOR<WorkoutCreateInput, WorkoutUncheckedCreateInput>
    /**
     * In case the Workout was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<WorkoutUpdateInput, WorkoutUncheckedUpdateInput>
  }


  /**
   * Workout delete
   */
  export type WorkoutDeleteArgs = {
    /**
     * Select specific fields to fetch from the Workout
     * 
    **/
    select?: WorkoutSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutInclude | null
    /**
     * Filter which Workout to delete.
     * 
    **/
    where: WorkoutWhereUniqueInput
  }


  /**
   * Workout deleteMany
   */
  export type WorkoutDeleteManyArgs = {
    where?: WorkoutWhereInput
  }


  /**
   * Workout without action
   */
  export type WorkoutArgs = {
    /**
     * Select specific fields to fetch from the Workout
     * 
    **/
    select?: WorkoutSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutInclude | null
  }



  /**
   * Model WorkoutExercise
   */


  export type AggregateWorkoutExercise = {
    _count: WorkoutExerciseCountAggregateOutputType | null
    _avg: WorkoutExerciseAvgAggregateOutputType | null
    _sum: WorkoutExerciseSumAggregateOutputType | null
    _min: WorkoutExerciseMinAggregateOutputType | null
    _max: WorkoutExerciseMaxAggregateOutputType | null
  }

  export type WorkoutExerciseAvgAggregateOutputType = {
    id: number | null
    workoutId: number | null
    exerciseId: number | null
    orderIndex: number | null
  }

  export type WorkoutExerciseSumAggregateOutputType = {
    id: number | null
    workoutId: number | null
    exerciseId: number | null
    orderIndex: number | null
  }

  export type WorkoutExerciseMinAggregateOutputType = {
    id: number | null
    workoutId: number | null
    exerciseId: number | null
    orderIndex: number | null
    notes: string | null
  }

  export type WorkoutExerciseMaxAggregateOutputType = {
    id: number | null
    workoutId: number | null
    exerciseId: number | null
    orderIndex: number | null
    notes: string | null
  }

  export type WorkoutExerciseCountAggregateOutputType = {
    id: number
    workoutId: number
    exerciseId: number
    orderIndex: number
    notes: number
    _all: number
  }


  export type WorkoutExerciseAvgAggregateInputType = {
    id?: true
    workoutId?: true
    exerciseId?: true
    orderIndex?: true
  }

  export type WorkoutExerciseSumAggregateInputType = {
    id?: true
    workoutId?: true
    exerciseId?: true
    orderIndex?: true
  }

  export type WorkoutExerciseMinAggregateInputType = {
    id?: true
    workoutId?: true
    exerciseId?: true
    orderIndex?: true
    notes?: true
  }

  export type WorkoutExerciseMaxAggregateInputType = {
    id?: true
    workoutId?: true
    exerciseId?: true
    orderIndex?: true
    notes?: true
  }

  export type WorkoutExerciseCountAggregateInputType = {
    id?: true
    workoutId?: true
    exerciseId?: true
    orderIndex?: true
    notes?: true
    _all?: true
  }

  export type WorkoutExerciseAggregateArgs = {
    /**
     * Filter which WorkoutExercise to aggregate.
     * 
    **/
    where?: WorkoutExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutExercises to fetch.
     * 
    **/
    orderBy?: Enumerable<WorkoutExerciseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: WorkoutExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutExercises from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutExercises.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkoutExercises
    **/
    _count?: true | WorkoutExerciseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkoutExerciseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkoutExerciseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkoutExerciseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkoutExerciseMaxAggregateInputType
  }

  export type GetWorkoutExerciseAggregateType<T extends WorkoutExerciseAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkoutExercise]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkoutExercise[P]>
      : GetScalarType<T[P], AggregateWorkoutExercise[P]>
  }




  export type WorkoutExerciseGroupByArgs = {
    where?: WorkoutExerciseWhereInput
    orderBy?: Enumerable<WorkoutExerciseOrderByWithAggregationInput>
    by: Array<WorkoutExerciseScalarFieldEnum>
    having?: WorkoutExerciseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkoutExerciseCountAggregateInputType | true
    _avg?: WorkoutExerciseAvgAggregateInputType
    _sum?: WorkoutExerciseSumAggregateInputType
    _min?: WorkoutExerciseMinAggregateInputType
    _max?: WorkoutExerciseMaxAggregateInputType
  }


  export type WorkoutExerciseGroupByOutputType = {
    id: number
    workoutId: number
    exerciseId: number
    orderIndex: number
    notes: string | null
    _count: WorkoutExerciseCountAggregateOutputType | null
    _avg: WorkoutExerciseAvgAggregateOutputType | null
    _sum: WorkoutExerciseSumAggregateOutputType | null
    _min: WorkoutExerciseMinAggregateOutputType | null
    _max: WorkoutExerciseMaxAggregateOutputType | null
  }

  type GetWorkoutExerciseGroupByPayload<T extends WorkoutExerciseGroupByArgs> = Promise<
    Array<
      PickArray<WorkoutExerciseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkoutExerciseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkoutExerciseGroupByOutputType[P]>
            : GetScalarType<T[P], WorkoutExerciseGroupByOutputType[P]>
        }
      >
    >


  export type WorkoutExerciseSelect = {
    id?: boolean
    workoutId?: boolean
    exerciseId?: boolean
    orderIndex?: boolean
    notes?: boolean
    workout?: boolean | WorkoutArgs
    exercise?: boolean | ExerciseArgs
    sets?: boolean | WorkoutSetFindManyArgs
    _count?: boolean | WorkoutExerciseCountOutputTypeArgs
  }

  export type WorkoutExerciseInclude = {
    workout?: boolean | WorkoutArgs
    exercise?: boolean | ExerciseArgs
    sets?: boolean | WorkoutSetFindManyArgs
    _count?: boolean | WorkoutExerciseCountOutputTypeArgs
  }

  export type WorkoutExerciseGetPayload<
    S extends boolean | null | undefined | WorkoutExerciseArgs,
    U = keyof S
      > = S extends true
        ? WorkoutExercise
    : S extends undefined
    ? never
    : S extends WorkoutExerciseArgs | WorkoutExerciseFindManyArgs
    ?'include' extends U
    ? WorkoutExercise  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'workout'
        ? WorkoutGetPayload<S['include'][P]> :
        P extends 'exercise'
        ? ExerciseGetPayload<S['include'][P]> :
        P extends 'sets'
        ? Array < WorkoutSetGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? WorkoutExerciseCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof WorkoutExercise ?WorkoutExercise [P]
  : 
          P extends 'workout'
        ? WorkoutGetPayload<S['select'][P]> :
        P extends 'exercise'
        ? ExerciseGetPayload<S['select'][P]> :
        P extends 'sets'
        ? Array < WorkoutSetGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? WorkoutExerciseCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : WorkoutExercise
  : WorkoutExercise


  type WorkoutExerciseCountArgs = Merge<
    Omit<WorkoutExerciseFindManyArgs, 'select' | 'include'> & {
      select?: WorkoutExerciseCountAggregateInputType | true
    }
  >

  export interface WorkoutExerciseDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one WorkoutExercise that matches the filter.
     * @param {WorkoutExerciseFindUniqueArgs} args - Arguments to find a WorkoutExercise
     * @example
     * // Get one WorkoutExercise
     * const workoutExercise = await prisma.workoutExercise.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WorkoutExerciseFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WorkoutExerciseFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'WorkoutExercise'> extends True ? CheckSelect<T, Prisma__WorkoutExerciseClient<WorkoutExercise>, Prisma__WorkoutExerciseClient<WorkoutExerciseGetPayload<T>>> : CheckSelect<T, Prisma__WorkoutExerciseClient<WorkoutExercise | null >, Prisma__WorkoutExerciseClient<WorkoutExerciseGetPayload<T> | null >>

    /**
     * Find the first WorkoutExercise that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutExerciseFindFirstArgs} args - Arguments to find a WorkoutExercise
     * @example
     * // Get one WorkoutExercise
     * const workoutExercise = await prisma.workoutExercise.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WorkoutExerciseFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WorkoutExerciseFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'WorkoutExercise'> extends True ? CheckSelect<T, Prisma__WorkoutExerciseClient<WorkoutExercise>, Prisma__WorkoutExerciseClient<WorkoutExerciseGetPayload<T>>> : CheckSelect<T, Prisma__WorkoutExerciseClient<WorkoutExercise | null >, Prisma__WorkoutExerciseClient<WorkoutExerciseGetPayload<T> | null >>

    /**
     * Find zero or more WorkoutExercises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutExerciseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkoutExercises
     * const workoutExercises = await prisma.workoutExercise.findMany()
     * 
     * // Get first 10 WorkoutExercises
     * const workoutExercises = await prisma.workoutExercise.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workoutExerciseWithIdOnly = await prisma.workoutExercise.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WorkoutExerciseFindManyArgs>(
      args?: SelectSubset<T, WorkoutExerciseFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<WorkoutExercise>>, PrismaPromise<Array<WorkoutExerciseGetPayload<T>>>>

    /**
     * Create a WorkoutExercise.
     * @param {WorkoutExerciseCreateArgs} args - Arguments to create a WorkoutExercise.
     * @example
     * // Create one WorkoutExercise
     * const WorkoutExercise = await prisma.workoutExercise.create({
     *   data: {
     *     // ... data to create a WorkoutExercise
     *   }
     * })
     * 
    **/
    create<T extends WorkoutExerciseCreateArgs>(
      args: SelectSubset<T, WorkoutExerciseCreateArgs>
    ): CheckSelect<T, Prisma__WorkoutExerciseClient<WorkoutExercise>, Prisma__WorkoutExerciseClient<WorkoutExerciseGetPayload<T>>>

    /**
     * Create many WorkoutExercises.
     *     @param {WorkoutExerciseCreateManyArgs} args - Arguments to create many WorkoutExercises.
     *     @example
     *     // Create many WorkoutExercises
     *     const workoutExercise = await prisma.workoutExercise.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WorkoutExerciseCreateManyArgs>(
      args?: SelectSubset<T, WorkoutExerciseCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a WorkoutExercise.
     * @param {WorkoutExerciseDeleteArgs} args - Arguments to delete one WorkoutExercise.
     * @example
     * // Delete one WorkoutExercise
     * const WorkoutExercise = await prisma.workoutExercise.delete({
     *   where: {
     *     // ... filter to delete one WorkoutExercise
     *   }
     * })
     * 
    **/
    delete<T extends WorkoutExerciseDeleteArgs>(
      args: SelectSubset<T, WorkoutExerciseDeleteArgs>
    ): CheckSelect<T, Prisma__WorkoutExerciseClient<WorkoutExercise>, Prisma__WorkoutExerciseClient<WorkoutExerciseGetPayload<T>>>

    /**
     * Update one WorkoutExercise.
     * @param {WorkoutExerciseUpdateArgs} args - Arguments to update one WorkoutExercise.
     * @example
     * // Update one WorkoutExercise
     * const workoutExercise = await prisma.workoutExercise.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WorkoutExerciseUpdateArgs>(
      args: SelectSubset<T, WorkoutExerciseUpdateArgs>
    ): CheckSelect<T, Prisma__WorkoutExerciseClient<WorkoutExercise>, Prisma__WorkoutExerciseClient<WorkoutExerciseGetPayload<T>>>

    /**
     * Delete zero or more WorkoutExercises.
     * @param {WorkoutExerciseDeleteManyArgs} args - Arguments to filter WorkoutExercises to delete.
     * @example
     * // Delete a few WorkoutExercises
     * const { count } = await prisma.workoutExercise.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WorkoutExerciseDeleteManyArgs>(
      args?: SelectSubset<T, WorkoutExerciseDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkoutExercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutExerciseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkoutExercises
     * const workoutExercise = await prisma.workoutExercise.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WorkoutExerciseUpdateManyArgs>(
      args: SelectSubset<T, WorkoutExerciseUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkoutExercise.
     * @param {WorkoutExerciseUpsertArgs} args - Arguments to update or create a WorkoutExercise.
     * @example
     * // Update or create a WorkoutExercise
     * const workoutExercise = await prisma.workoutExercise.upsert({
     *   create: {
     *     // ... data to create a WorkoutExercise
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkoutExercise we want to update
     *   }
     * })
    **/
    upsert<T extends WorkoutExerciseUpsertArgs>(
      args: SelectSubset<T, WorkoutExerciseUpsertArgs>
    ): CheckSelect<T, Prisma__WorkoutExerciseClient<WorkoutExercise>, Prisma__WorkoutExerciseClient<WorkoutExerciseGetPayload<T>>>

    /**
     * Count the number of WorkoutExercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutExerciseCountArgs} args - Arguments to filter WorkoutExercises to count.
     * @example
     * // Count the number of WorkoutExercises
     * const count = await prisma.workoutExercise.count({
     *   where: {
     *     // ... the filter for the WorkoutExercises we want to count
     *   }
     * })
    **/
    count<T extends WorkoutExerciseCountArgs>(
      args?: Subset<T, WorkoutExerciseCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkoutExerciseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkoutExercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutExerciseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkoutExerciseAggregateArgs>(args: Subset<T, WorkoutExerciseAggregateArgs>): PrismaPromise<GetWorkoutExerciseAggregateType<T>>

    /**
     * Group by WorkoutExercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutExerciseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkoutExerciseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkoutExerciseGroupByArgs['orderBy'] }
        : { orderBy?: WorkoutExerciseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkoutExerciseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkoutExerciseGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkoutExercise.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WorkoutExerciseClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    workout<T extends WorkoutArgs = {}>(args?: Subset<T, WorkoutArgs>): CheckSelect<T, Prisma__WorkoutClient<Workout | null >, Prisma__WorkoutClient<WorkoutGetPayload<T> | null >>;

    exercise<T extends ExerciseArgs = {}>(args?: Subset<T, ExerciseArgs>): CheckSelect<T, Prisma__ExerciseClient<Exercise | null >, Prisma__ExerciseClient<ExerciseGetPayload<T> | null >>;

    sets<T extends WorkoutSetFindManyArgs = {}>(args?: Subset<T, WorkoutSetFindManyArgs>): CheckSelect<T, PrismaPromise<Array<WorkoutSet>>, PrismaPromise<Array<WorkoutSetGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * WorkoutExercise findUnique
   */
  export type WorkoutExerciseFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the WorkoutExercise
     * 
    **/
    select?: WorkoutExerciseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutExerciseInclude | null
    /**
     * Throw an Error if a WorkoutExercise can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which WorkoutExercise to fetch.
     * 
    **/
    where: WorkoutExerciseWhereUniqueInput
  }


  /**
   * WorkoutExercise findFirst
   */
  export type WorkoutExerciseFindFirstArgs = {
    /**
     * Select specific fields to fetch from the WorkoutExercise
     * 
    **/
    select?: WorkoutExerciseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutExerciseInclude | null
    /**
     * Throw an Error if a WorkoutExercise can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which WorkoutExercise to fetch.
     * 
    **/
    where?: WorkoutExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutExercises to fetch.
     * 
    **/
    orderBy?: Enumerable<WorkoutExerciseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkoutExercises.
     * 
    **/
    cursor?: WorkoutExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutExercises from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutExercises.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkoutExercises.
     * 
    **/
    distinct?: Enumerable<WorkoutExerciseScalarFieldEnum>
  }


  /**
   * WorkoutExercise findMany
   */
  export type WorkoutExerciseFindManyArgs = {
    /**
     * Select specific fields to fetch from the WorkoutExercise
     * 
    **/
    select?: WorkoutExerciseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutExerciseInclude | null
    /**
     * Filter, which WorkoutExercises to fetch.
     * 
    **/
    where?: WorkoutExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutExercises to fetch.
     * 
    **/
    orderBy?: Enumerable<WorkoutExerciseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkoutExercises.
     * 
    **/
    cursor?: WorkoutExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutExercises from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutExercises.
     * 
    **/
    skip?: number
    distinct?: Enumerable<WorkoutExerciseScalarFieldEnum>
  }


  /**
   * WorkoutExercise create
   */
  export type WorkoutExerciseCreateArgs = {
    /**
     * Select specific fields to fetch from the WorkoutExercise
     * 
    **/
    select?: WorkoutExerciseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutExerciseInclude | null
    /**
     * The data needed to create a WorkoutExercise.
     * 
    **/
    data: XOR<WorkoutExerciseCreateInput, WorkoutExerciseUncheckedCreateInput>
  }


  /**
   * WorkoutExercise createMany
   */
  export type WorkoutExerciseCreateManyArgs = {
    data: Enumerable<WorkoutExerciseCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * WorkoutExercise update
   */
  export type WorkoutExerciseUpdateArgs = {
    /**
     * Select specific fields to fetch from the WorkoutExercise
     * 
    **/
    select?: WorkoutExerciseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutExerciseInclude | null
    /**
     * The data needed to update a WorkoutExercise.
     * 
    **/
    data: XOR<WorkoutExerciseUpdateInput, WorkoutExerciseUncheckedUpdateInput>
    /**
     * Choose, which WorkoutExercise to update.
     * 
    **/
    where: WorkoutExerciseWhereUniqueInput
  }


  /**
   * WorkoutExercise updateMany
   */
  export type WorkoutExerciseUpdateManyArgs = {
    data: XOR<WorkoutExerciseUpdateManyMutationInput, WorkoutExerciseUncheckedUpdateManyInput>
    where?: WorkoutExerciseWhereInput
  }


  /**
   * WorkoutExercise upsert
   */
  export type WorkoutExerciseUpsertArgs = {
    /**
     * Select specific fields to fetch from the WorkoutExercise
     * 
    **/
    select?: WorkoutExerciseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutExerciseInclude | null
    /**
     * The filter to search for the WorkoutExercise to update in case it exists.
     * 
    **/
    where: WorkoutExerciseWhereUniqueInput
    /**
     * In case the WorkoutExercise found by the `where` argument doesn't exist, create a new WorkoutExercise with this data.
     * 
    **/
    create: XOR<WorkoutExerciseCreateInput, WorkoutExerciseUncheckedCreateInput>
    /**
     * In case the WorkoutExercise was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<WorkoutExerciseUpdateInput, WorkoutExerciseUncheckedUpdateInput>
  }


  /**
   * WorkoutExercise delete
   */
  export type WorkoutExerciseDeleteArgs = {
    /**
     * Select specific fields to fetch from the WorkoutExercise
     * 
    **/
    select?: WorkoutExerciseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutExerciseInclude | null
    /**
     * Filter which WorkoutExercise to delete.
     * 
    **/
    where: WorkoutExerciseWhereUniqueInput
  }


  /**
   * WorkoutExercise deleteMany
   */
  export type WorkoutExerciseDeleteManyArgs = {
    where?: WorkoutExerciseWhereInput
  }


  /**
   * WorkoutExercise without action
   */
  export type WorkoutExerciseArgs = {
    /**
     * Select specific fields to fetch from the WorkoutExercise
     * 
    **/
    select?: WorkoutExerciseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutExerciseInclude | null
  }



  /**
   * Model WorkoutSet
   */


  export type AggregateWorkoutSet = {
    _count: WorkoutSetCountAggregateOutputType | null
    _avg: WorkoutSetAvgAggregateOutputType | null
    _sum: WorkoutSetSumAggregateOutputType | null
    _min: WorkoutSetMinAggregateOutputType | null
    _max: WorkoutSetMaxAggregateOutputType | null
  }

  export type WorkoutSetAvgAggregateOutputType = {
    id: number | null
    workoutExerciseId: number | null
    setIndex: number | null
    reps: number | null
    weightKg: number | null
    rpe: number | null
  }

  export type WorkoutSetSumAggregateOutputType = {
    id: number | null
    workoutExerciseId: number | null
    setIndex: number | null
    reps: number | null
    weightKg: number | null
    rpe: number | null
  }

  export type WorkoutSetMinAggregateOutputType = {
    id: number | null
    workoutExerciseId: number | null
    setIndex: number | null
    reps: number | null
    weightKg: number | null
    rpe: number | null
    notes: string | null
  }

  export type WorkoutSetMaxAggregateOutputType = {
    id: number | null
    workoutExerciseId: number | null
    setIndex: number | null
    reps: number | null
    weightKg: number | null
    rpe: number | null
    notes: string | null
  }

  export type WorkoutSetCountAggregateOutputType = {
    id: number
    workoutExerciseId: number
    setIndex: number
    reps: number
    weightKg: number
    rpe: number
    notes: number
    _all: number
  }


  export type WorkoutSetAvgAggregateInputType = {
    id?: true
    workoutExerciseId?: true
    setIndex?: true
    reps?: true
    weightKg?: true
    rpe?: true
  }

  export type WorkoutSetSumAggregateInputType = {
    id?: true
    workoutExerciseId?: true
    setIndex?: true
    reps?: true
    weightKg?: true
    rpe?: true
  }

  export type WorkoutSetMinAggregateInputType = {
    id?: true
    workoutExerciseId?: true
    setIndex?: true
    reps?: true
    weightKg?: true
    rpe?: true
    notes?: true
  }

  export type WorkoutSetMaxAggregateInputType = {
    id?: true
    workoutExerciseId?: true
    setIndex?: true
    reps?: true
    weightKg?: true
    rpe?: true
    notes?: true
  }

  export type WorkoutSetCountAggregateInputType = {
    id?: true
    workoutExerciseId?: true
    setIndex?: true
    reps?: true
    weightKg?: true
    rpe?: true
    notes?: true
    _all?: true
  }

  export type WorkoutSetAggregateArgs = {
    /**
     * Filter which WorkoutSet to aggregate.
     * 
    **/
    where?: WorkoutSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutSets to fetch.
     * 
    **/
    orderBy?: Enumerable<WorkoutSetOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: WorkoutSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutSets from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutSets.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkoutSets
    **/
    _count?: true | WorkoutSetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkoutSetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkoutSetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkoutSetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkoutSetMaxAggregateInputType
  }

  export type GetWorkoutSetAggregateType<T extends WorkoutSetAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkoutSet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkoutSet[P]>
      : GetScalarType<T[P], AggregateWorkoutSet[P]>
  }




  export type WorkoutSetGroupByArgs = {
    where?: WorkoutSetWhereInput
    orderBy?: Enumerable<WorkoutSetOrderByWithAggregationInput>
    by: Array<WorkoutSetScalarFieldEnum>
    having?: WorkoutSetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkoutSetCountAggregateInputType | true
    _avg?: WorkoutSetAvgAggregateInputType
    _sum?: WorkoutSetSumAggregateInputType
    _min?: WorkoutSetMinAggregateInputType
    _max?: WorkoutSetMaxAggregateInputType
  }


  export type WorkoutSetGroupByOutputType = {
    id: number
    workoutExerciseId: number
    setIndex: number
    reps: number
    weightKg: number
    rpe: number | null
    notes: string | null
    _count: WorkoutSetCountAggregateOutputType | null
    _avg: WorkoutSetAvgAggregateOutputType | null
    _sum: WorkoutSetSumAggregateOutputType | null
    _min: WorkoutSetMinAggregateOutputType | null
    _max: WorkoutSetMaxAggregateOutputType | null
  }

  type GetWorkoutSetGroupByPayload<T extends WorkoutSetGroupByArgs> = Promise<
    Array<
      PickArray<WorkoutSetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkoutSetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkoutSetGroupByOutputType[P]>
            : GetScalarType<T[P], WorkoutSetGroupByOutputType[P]>
        }
      >
    >


  export type WorkoutSetSelect = {
    id?: boolean
    workoutExerciseId?: boolean
    setIndex?: boolean
    reps?: boolean
    weightKg?: boolean
    rpe?: boolean
    notes?: boolean
    workoutExercise?: boolean | WorkoutExerciseArgs
  }

  export type WorkoutSetInclude = {
    workoutExercise?: boolean | WorkoutExerciseArgs
  }

  export type WorkoutSetGetPayload<
    S extends boolean | null | undefined | WorkoutSetArgs,
    U = keyof S
      > = S extends true
        ? WorkoutSet
    : S extends undefined
    ? never
    : S extends WorkoutSetArgs | WorkoutSetFindManyArgs
    ?'include' extends U
    ? WorkoutSet  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'workoutExercise'
        ? WorkoutExerciseGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof WorkoutSet ?WorkoutSet [P]
  : 
          P extends 'workoutExercise'
        ? WorkoutExerciseGetPayload<S['select'][P]> : never
  } 
    : WorkoutSet
  : WorkoutSet


  type WorkoutSetCountArgs = Merge<
    Omit<WorkoutSetFindManyArgs, 'select' | 'include'> & {
      select?: WorkoutSetCountAggregateInputType | true
    }
  >

  export interface WorkoutSetDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one WorkoutSet that matches the filter.
     * @param {WorkoutSetFindUniqueArgs} args - Arguments to find a WorkoutSet
     * @example
     * // Get one WorkoutSet
     * const workoutSet = await prisma.workoutSet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WorkoutSetFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WorkoutSetFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'WorkoutSet'> extends True ? CheckSelect<T, Prisma__WorkoutSetClient<WorkoutSet>, Prisma__WorkoutSetClient<WorkoutSetGetPayload<T>>> : CheckSelect<T, Prisma__WorkoutSetClient<WorkoutSet | null >, Prisma__WorkoutSetClient<WorkoutSetGetPayload<T> | null >>

    /**
     * Find the first WorkoutSet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutSetFindFirstArgs} args - Arguments to find a WorkoutSet
     * @example
     * // Get one WorkoutSet
     * const workoutSet = await prisma.workoutSet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WorkoutSetFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WorkoutSetFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'WorkoutSet'> extends True ? CheckSelect<T, Prisma__WorkoutSetClient<WorkoutSet>, Prisma__WorkoutSetClient<WorkoutSetGetPayload<T>>> : CheckSelect<T, Prisma__WorkoutSetClient<WorkoutSet | null >, Prisma__WorkoutSetClient<WorkoutSetGetPayload<T> | null >>

    /**
     * Find zero or more WorkoutSets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutSetFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkoutSets
     * const workoutSets = await prisma.workoutSet.findMany()
     * 
     * // Get first 10 WorkoutSets
     * const workoutSets = await prisma.workoutSet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workoutSetWithIdOnly = await prisma.workoutSet.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WorkoutSetFindManyArgs>(
      args?: SelectSubset<T, WorkoutSetFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<WorkoutSet>>, PrismaPromise<Array<WorkoutSetGetPayload<T>>>>

    /**
     * Create a WorkoutSet.
     * @param {WorkoutSetCreateArgs} args - Arguments to create a WorkoutSet.
     * @example
     * // Create one WorkoutSet
     * const WorkoutSet = await prisma.workoutSet.create({
     *   data: {
     *     // ... data to create a WorkoutSet
     *   }
     * })
     * 
    **/
    create<T extends WorkoutSetCreateArgs>(
      args: SelectSubset<T, WorkoutSetCreateArgs>
    ): CheckSelect<T, Prisma__WorkoutSetClient<WorkoutSet>, Prisma__WorkoutSetClient<WorkoutSetGetPayload<T>>>

    /**
     * Create many WorkoutSets.
     *     @param {WorkoutSetCreateManyArgs} args - Arguments to create many WorkoutSets.
     *     @example
     *     // Create many WorkoutSets
     *     const workoutSet = await prisma.workoutSet.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WorkoutSetCreateManyArgs>(
      args?: SelectSubset<T, WorkoutSetCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a WorkoutSet.
     * @param {WorkoutSetDeleteArgs} args - Arguments to delete one WorkoutSet.
     * @example
     * // Delete one WorkoutSet
     * const WorkoutSet = await prisma.workoutSet.delete({
     *   where: {
     *     // ... filter to delete one WorkoutSet
     *   }
     * })
     * 
    **/
    delete<T extends WorkoutSetDeleteArgs>(
      args: SelectSubset<T, WorkoutSetDeleteArgs>
    ): CheckSelect<T, Prisma__WorkoutSetClient<WorkoutSet>, Prisma__WorkoutSetClient<WorkoutSetGetPayload<T>>>

    /**
     * Update one WorkoutSet.
     * @param {WorkoutSetUpdateArgs} args - Arguments to update one WorkoutSet.
     * @example
     * // Update one WorkoutSet
     * const workoutSet = await prisma.workoutSet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WorkoutSetUpdateArgs>(
      args: SelectSubset<T, WorkoutSetUpdateArgs>
    ): CheckSelect<T, Prisma__WorkoutSetClient<WorkoutSet>, Prisma__WorkoutSetClient<WorkoutSetGetPayload<T>>>

    /**
     * Delete zero or more WorkoutSets.
     * @param {WorkoutSetDeleteManyArgs} args - Arguments to filter WorkoutSets to delete.
     * @example
     * // Delete a few WorkoutSets
     * const { count } = await prisma.workoutSet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WorkoutSetDeleteManyArgs>(
      args?: SelectSubset<T, WorkoutSetDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkoutSets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutSetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkoutSets
     * const workoutSet = await prisma.workoutSet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WorkoutSetUpdateManyArgs>(
      args: SelectSubset<T, WorkoutSetUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkoutSet.
     * @param {WorkoutSetUpsertArgs} args - Arguments to update or create a WorkoutSet.
     * @example
     * // Update or create a WorkoutSet
     * const workoutSet = await prisma.workoutSet.upsert({
     *   create: {
     *     // ... data to create a WorkoutSet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkoutSet we want to update
     *   }
     * })
    **/
    upsert<T extends WorkoutSetUpsertArgs>(
      args: SelectSubset<T, WorkoutSetUpsertArgs>
    ): CheckSelect<T, Prisma__WorkoutSetClient<WorkoutSet>, Prisma__WorkoutSetClient<WorkoutSetGetPayload<T>>>

    /**
     * Count the number of WorkoutSets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutSetCountArgs} args - Arguments to filter WorkoutSets to count.
     * @example
     * // Count the number of WorkoutSets
     * const count = await prisma.workoutSet.count({
     *   where: {
     *     // ... the filter for the WorkoutSets we want to count
     *   }
     * })
    **/
    count<T extends WorkoutSetCountArgs>(
      args?: Subset<T, WorkoutSetCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkoutSetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkoutSet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutSetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkoutSetAggregateArgs>(args: Subset<T, WorkoutSetAggregateArgs>): PrismaPromise<GetWorkoutSetAggregateType<T>>

    /**
     * Group by WorkoutSet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutSetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkoutSetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkoutSetGroupByArgs['orderBy'] }
        : { orderBy?: WorkoutSetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkoutSetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkoutSetGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkoutSet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WorkoutSetClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    workoutExercise<T extends WorkoutExerciseArgs = {}>(args?: Subset<T, WorkoutExerciseArgs>): CheckSelect<T, Prisma__WorkoutExerciseClient<WorkoutExercise | null >, Prisma__WorkoutExerciseClient<WorkoutExerciseGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * WorkoutSet findUnique
   */
  export type WorkoutSetFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the WorkoutSet
     * 
    **/
    select?: WorkoutSetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutSetInclude | null
    /**
     * Throw an Error if a WorkoutSet can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which WorkoutSet to fetch.
     * 
    **/
    where: WorkoutSetWhereUniqueInput
  }


  /**
   * WorkoutSet findFirst
   */
  export type WorkoutSetFindFirstArgs = {
    /**
     * Select specific fields to fetch from the WorkoutSet
     * 
    **/
    select?: WorkoutSetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutSetInclude | null
    /**
     * Throw an Error if a WorkoutSet can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which WorkoutSet to fetch.
     * 
    **/
    where?: WorkoutSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutSets to fetch.
     * 
    **/
    orderBy?: Enumerable<WorkoutSetOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkoutSets.
     * 
    **/
    cursor?: WorkoutSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutSets from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutSets.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkoutSets.
     * 
    **/
    distinct?: Enumerable<WorkoutSetScalarFieldEnum>
  }


  /**
   * WorkoutSet findMany
   */
  export type WorkoutSetFindManyArgs = {
    /**
     * Select specific fields to fetch from the WorkoutSet
     * 
    **/
    select?: WorkoutSetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutSetInclude | null
    /**
     * Filter, which WorkoutSets to fetch.
     * 
    **/
    where?: WorkoutSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutSets to fetch.
     * 
    **/
    orderBy?: Enumerable<WorkoutSetOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkoutSets.
     * 
    **/
    cursor?: WorkoutSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutSets from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutSets.
     * 
    **/
    skip?: number
    distinct?: Enumerable<WorkoutSetScalarFieldEnum>
  }


  /**
   * WorkoutSet create
   */
  export type WorkoutSetCreateArgs = {
    /**
     * Select specific fields to fetch from the WorkoutSet
     * 
    **/
    select?: WorkoutSetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutSetInclude | null
    /**
     * The data needed to create a WorkoutSet.
     * 
    **/
    data: XOR<WorkoutSetCreateInput, WorkoutSetUncheckedCreateInput>
  }


  /**
   * WorkoutSet createMany
   */
  export type WorkoutSetCreateManyArgs = {
    data: Enumerable<WorkoutSetCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * WorkoutSet update
   */
  export type WorkoutSetUpdateArgs = {
    /**
     * Select specific fields to fetch from the WorkoutSet
     * 
    **/
    select?: WorkoutSetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutSetInclude | null
    /**
     * The data needed to update a WorkoutSet.
     * 
    **/
    data: XOR<WorkoutSetUpdateInput, WorkoutSetUncheckedUpdateInput>
    /**
     * Choose, which WorkoutSet to update.
     * 
    **/
    where: WorkoutSetWhereUniqueInput
  }


  /**
   * WorkoutSet updateMany
   */
  export type WorkoutSetUpdateManyArgs = {
    data: XOR<WorkoutSetUpdateManyMutationInput, WorkoutSetUncheckedUpdateManyInput>
    where?: WorkoutSetWhereInput
  }


  /**
   * WorkoutSet upsert
   */
  export type WorkoutSetUpsertArgs = {
    /**
     * Select specific fields to fetch from the WorkoutSet
     * 
    **/
    select?: WorkoutSetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutSetInclude | null
    /**
     * The filter to search for the WorkoutSet to update in case it exists.
     * 
    **/
    where: WorkoutSetWhereUniqueInput
    /**
     * In case the WorkoutSet found by the `where` argument doesn't exist, create a new WorkoutSet with this data.
     * 
    **/
    create: XOR<WorkoutSetCreateInput, WorkoutSetUncheckedCreateInput>
    /**
     * In case the WorkoutSet was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<WorkoutSetUpdateInput, WorkoutSetUncheckedUpdateInput>
  }


  /**
   * WorkoutSet delete
   */
  export type WorkoutSetDeleteArgs = {
    /**
     * Select specific fields to fetch from the WorkoutSet
     * 
    **/
    select?: WorkoutSetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutSetInclude | null
    /**
     * Filter which WorkoutSet to delete.
     * 
    **/
    where: WorkoutSetWhereUniqueInput
  }


  /**
   * WorkoutSet deleteMany
   */
  export type WorkoutSetDeleteManyArgs = {
    where?: WorkoutSetWhereInput
  }


  /**
   * WorkoutSet without action
   */
  export type WorkoutSetArgs = {
    /**
     * Select specific fields to fetch from the WorkoutSet
     * 
    **/
    select?: WorkoutSetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkoutSetInclude | null
  }



  /**
   * Model Weight
   */


  export type AggregateWeight = {
    _count: WeightCountAggregateOutputType | null
    _avg: WeightAvgAggregateOutputType | null
    _sum: WeightSumAggregateOutputType | null
    _min: WeightMinAggregateOutputType | null
    _max: WeightMaxAggregateOutputType | null
  }

  export type WeightAvgAggregateOutputType = {
    id: number | null
    weightKg: number | null
    athleteId: number | null
  }

  export type WeightSumAggregateOutputType = {
    id: number | null
    weightKg: number | null
    athleteId: number | null
  }

  export type WeightMinAggregateOutputType = {
    id: number | null
    weightKg: number | null
    date: Date | null
    createdAt: Date | null
    athleteId: number | null
  }

  export type WeightMaxAggregateOutputType = {
    id: number | null
    weightKg: number | null
    date: Date | null
    createdAt: Date | null
    athleteId: number | null
  }

  export type WeightCountAggregateOutputType = {
    id: number
    weightKg: number
    date: number
    createdAt: number
    athleteId: number
    _all: number
  }


  export type WeightAvgAggregateInputType = {
    id?: true
    weightKg?: true
    athleteId?: true
  }

  export type WeightSumAggregateInputType = {
    id?: true
    weightKg?: true
    athleteId?: true
  }

  export type WeightMinAggregateInputType = {
    id?: true
    weightKg?: true
    date?: true
    createdAt?: true
    athleteId?: true
  }

  export type WeightMaxAggregateInputType = {
    id?: true
    weightKg?: true
    date?: true
    createdAt?: true
    athleteId?: true
  }

  export type WeightCountAggregateInputType = {
    id?: true
    weightKg?: true
    date?: true
    createdAt?: true
    athleteId?: true
    _all?: true
  }

  export type WeightAggregateArgs = {
    /**
     * Filter which Weight to aggregate.
     * 
    **/
    where?: WeightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weights to fetch.
     * 
    **/
    orderBy?: Enumerable<WeightOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: WeightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weights from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weights.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Weights
    **/
    _count?: true | WeightCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WeightAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WeightSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WeightMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WeightMaxAggregateInputType
  }

  export type GetWeightAggregateType<T extends WeightAggregateArgs> = {
        [P in keyof T & keyof AggregateWeight]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeight[P]>
      : GetScalarType<T[P], AggregateWeight[P]>
  }




  export type WeightGroupByArgs = {
    where?: WeightWhereInput
    orderBy?: Enumerable<WeightOrderByWithAggregationInput>
    by: Array<WeightScalarFieldEnum>
    having?: WeightScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WeightCountAggregateInputType | true
    _avg?: WeightAvgAggregateInputType
    _sum?: WeightSumAggregateInputType
    _min?: WeightMinAggregateInputType
    _max?: WeightMaxAggregateInputType
  }


  export type WeightGroupByOutputType = {
    id: number
    weightKg: number
    date: Date
    createdAt: Date
    athleteId: number
    _count: WeightCountAggregateOutputType | null
    _avg: WeightAvgAggregateOutputType | null
    _sum: WeightSumAggregateOutputType | null
    _min: WeightMinAggregateOutputType | null
    _max: WeightMaxAggregateOutputType | null
  }

  type GetWeightGroupByPayload<T extends WeightGroupByArgs> = Promise<
    Array<
      PickArray<WeightGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WeightGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WeightGroupByOutputType[P]>
            : GetScalarType<T[P], WeightGroupByOutputType[P]>
        }
      >
    >


  export type WeightSelect = {
    id?: boolean
    weightKg?: boolean
    date?: boolean
    createdAt?: boolean
    athleteId?: boolean
    athlete?: boolean | UserArgs
  }

  export type WeightInclude = {
    athlete?: boolean | UserArgs
  }

  export type WeightGetPayload<
    S extends boolean | null | undefined | WeightArgs,
    U = keyof S
      > = S extends true
        ? Weight
    : S extends undefined
    ? never
    : S extends WeightArgs | WeightFindManyArgs
    ?'include' extends U
    ? Weight  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'athlete'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Weight ?Weight [P]
  : 
          P extends 'athlete'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : Weight
  : Weight


  type WeightCountArgs = Merge<
    Omit<WeightFindManyArgs, 'select' | 'include'> & {
      select?: WeightCountAggregateInputType | true
    }
  >

  export interface WeightDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Weight that matches the filter.
     * @param {WeightFindUniqueArgs} args - Arguments to find a Weight
     * @example
     * // Get one Weight
     * const weight = await prisma.weight.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WeightFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WeightFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Weight'> extends True ? CheckSelect<T, Prisma__WeightClient<Weight>, Prisma__WeightClient<WeightGetPayload<T>>> : CheckSelect<T, Prisma__WeightClient<Weight | null >, Prisma__WeightClient<WeightGetPayload<T> | null >>

    /**
     * Find the first Weight that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeightFindFirstArgs} args - Arguments to find a Weight
     * @example
     * // Get one Weight
     * const weight = await prisma.weight.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WeightFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WeightFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Weight'> extends True ? CheckSelect<T, Prisma__WeightClient<Weight>, Prisma__WeightClient<WeightGetPayload<T>>> : CheckSelect<T, Prisma__WeightClient<Weight | null >, Prisma__WeightClient<WeightGetPayload<T> | null >>

    /**
     * Find zero or more Weights that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeightFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Weights
     * const weights = await prisma.weight.findMany()
     * 
     * // Get first 10 Weights
     * const weights = await prisma.weight.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const weightWithIdOnly = await prisma.weight.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WeightFindManyArgs>(
      args?: SelectSubset<T, WeightFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Weight>>, PrismaPromise<Array<WeightGetPayload<T>>>>

    /**
     * Create a Weight.
     * @param {WeightCreateArgs} args - Arguments to create a Weight.
     * @example
     * // Create one Weight
     * const Weight = await prisma.weight.create({
     *   data: {
     *     // ... data to create a Weight
     *   }
     * })
     * 
    **/
    create<T extends WeightCreateArgs>(
      args: SelectSubset<T, WeightCreateArgs>
    ): CheckSelect<T, Prisma__WeightClient<Weight>, Prisma__WeightClient<WeightGetPayload<T>>>

    /**
     * Create many Weights.
     *     @param {WeightCreateManyArgs} args - Arguments to create many Weights.
     *     @example
     *     // Create many Weights
     *     const weight = await prisma.weight.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WeightCreateManyArgs>(
      args?: SelectSubset<T, WeightCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Weight.
     * @param {WeightDeleteArgs} args - Arguments to delete one Weight.
     * @example
     * // Delete one Weight
     * const Weight = await prisma.weight.delete({
     *   where: {
     *     // ... filter to delete one Weight
     *   }
     * })
     * 
    **/
    delete<T extends WeightDeleteArgs>(
      args: SelectSubset<T, WeightDeleteArgs>
    ): CheckSelect<T, Prisma__WeightClient<Weight>, Prisma__WeightClient<WeightGetPayload<T>>>

    /**
     * Update one Weight.
     * @param {WeightUpdateArgs} args - Arguments to update one Weight.
     * @example
     * // Update one Weight
     * const weight = await prisma.weight.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WeightUpdateArgs>(
      args: SelectSubset<T, WeightUpdateArgs>
    ): CheckSelect<T, Prisma__WeightClient<Weight>, Prisma__WeightClient<WeightGetPayload<T>>>

    /**
     * Delete zero or more Weights.
     * @param {WeightDeleteManyArgs} args - Arguments to filter Weights to delete.
     * @example
     * // Delete a few Weights
     * const { count } = await prisma.weight.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WeightDeleteManyArgs>(
      args?: SelectSubset<T, WeightDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Weights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeightUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Weights
     * const weight = await prisma.weight.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WeightUpdateManyArgs>(
      args: SelectSubset<T, WeightUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Weight.
     * @param {WeightUpsertArgs} args - Arguments to update or create a Weight.
     * @example
     * // Update or create a Weight
     * const weight = await prisma.weight.upsert({
     *   create: {
     *     // ... data to create a Weight
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Weight we want to update
     *   }
     * })
    **/
    upsert<T extends WeightUpsertArgs>(
      args: SelectSubset<T, WeightUpsertArgs>
    ): CheckSelect<T, Prisma__WeightClient<Weight>, Prisma__WeightClient<WeightGetPayload<T>>>

    /**
     * Count the number of Weights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeightCountArgs} args - Arguments to filter Weights to count.
     * @example
     * // Count the number of Weights
     * const count = await prisma.weight.count({
     *   where: {
     *     // ... the filter for the Weights we want to count
     *   }
     * })
    **/
    count<T extends WeightCountArgs>(
      args?: Subset<T, WeightCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WeightCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Weight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeightAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WeightAggregateArgs>(args: Subset<T, WeightAggregateArgs>): PrismaPromise<GetWeightAggregateType<T>>

    /**
     * Group by Weight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeightGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WeightGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WeightGroupByArgs['orderBy'] }
        : { orderBy?: WeightGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WeightGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeightGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Weight.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WeightClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    athlete<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Weight findUnique
   */
  export type WeightFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Weight
     * 
    **/
    select?: WeightSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WeightInclude | null
    /**
     * Throw an Error if a Weight can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Weight to fetch.
     * 
    **/
    where: WeightWhereUniqueInput
  }


  /**
   * Weight findFirst
   */
  export type WeightFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Weight
     * 
    **/
    select?: WeightSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WeightInclude | null
    /**
     * Throw an Error if a Weight can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Weight to fetch.
     * 
    **/
    where?: WeightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weights to fetch.
     * 
    **/
    orderBy?: Enumerable<WeightOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Weights.
     * 
    **/
    cursor?: WeightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weights from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weights.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Weights.
     * 
    **/
    distinct?: Enumerable<WeightScalarFieldEnum>
  }


  /**
   * Weight findMany
   */
  export type WeightFindManyArgs = {
    /**
     * Select specific fields to fetch from the Weight
     * 
    **/
    select?: WeightSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WeightInclude | null
    /**
     * Filter, which Weights to fetch.
     * 
    **/
    where?: WeightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weights to fetch.
     * 
    **/
    orderBy?: Enumerable<WeightOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Weights.
     * 
    **/
    cursor?: WeightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weights from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weights.
     * 
    **/
    skip?: number
    distinct?: Enumerable<WeightScalarFieldEnum>
  }


  /**
   * Weight create
   */
  export type WeightCreateArgs = {
    /**
     * Select specific fields to fetch from the Weight
     * 
    **/
    select?: WeightSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WeightInclude | null
    /**
     * The data needed to create a Weight.
     * 
    **/
    data: XOR<WeightCreateInput, WeightUncheckedCreateInput>
  }


  /**
   * Weight createMany
   */
  export type WeightCreateManyArgs = {
    data: Enumerable<WeightCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Weight update
   */
  export type WeightUpdateArgs = {
    /**
     * Select specific fields to fetch from the Weight
     * 
    **/
    select?: WeightSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WeightInclude | null
    /**
     * The data needed to update a Weight.
     * 
    **/
    data: XOR<WeightUpdateInput, WeightUncheckedUpdateInput>
    /**
     * Choose, which Weight to update.
     * 
    **/
    where: WeightWhereUniqueInput
  }


  /**
   * Weight updateMany
   */
  export type WeightUpdateManyArgs = {
    data: XOR<WeightUpdateManyMutationInput, WeightUncheckedUpdateManyInput>
    where?: WeightWhereInput
  }


  /**
   * Weight upsert
   */
  export type WeightUpsertArgs = {
    /**
     * Select specific fields to fetch from the Weight
     * 
    **/
    select?: WeightSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WeightInclude | null
    /**
     * The filter to search for the Weight to update in case it exists.
     * 
    **/
    where: WeightWhereUniqueInput
    /**
     * In case the Weight found by the `where` argument doesn't exist, create a new Weight with this data.
     * 
    **/
    create: XOR<WeightCreateInput, WeightUncheckedCreateInput>
    /**
     * In case the Weight was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<WeightUpdateInput, WeightUncheckedUpdateInput>
  }


  /**
   * Weight delete
   */
  export type WeightDeleteArgs = {
    /**
     * Select specific fields to fetch from the Weight
     * 
    **/
    select?: WeightSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WeightInclude | null
    /**
     * Filter which Weight to delete.
     * 
    **/
    where: WeightWhereUniqueInput
  }


  /**
   * Weight deleteMany
   */
  export type WeightDeleteManyArgs = {
    where?: WeightWhereInput
  }


  /**
   * Weight without action
   */
  export type WeightArgs = {
    /**
     * Select specific fields to fetch from the Weight
     * 
    **/
    select?: WeightSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WeightInclude | null
  }



  /**
   * Model Message
   */


  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageAvgAggregateOutputType = {
    id: number | null
    senderId: number | null
    receiverId: number | null
  }

  export type MessageSumAggregateOutputType = {
    id: number | null
    senderId: number | null
    receiverId: number | null
  }

  export type MessageMinAggregateOutputType = {
    id: number | null
    senderId: number | null
    receiverId: number | null
    content: string | null
    createdAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: number | null
    senderId: number | null
    receiverId: number | null
    content: string | null
    createdAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    senderId: number
    receiverId: number
    content: number
    createdAt: number
    _all: number
  }


  export type MessageAvgAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
  }

  export type MessageSumAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
  }

  export type MessageMinAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    content?: true
    createdAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    content?: true
    createdAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type MessageAggregateArgs = {
    /**
     * Filter which Message to aggregate.
     * 
    **/
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     * 
    **/
    orderBy?: Enumerable<MessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs = {
    where?: MessageWhereInput
    orderBy?: Enumerable<MessageOrderByWithAggregationInput>
    by: Array<MessageScalarFieldEnum>
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _avg?: MessageAvgAggregateInputType
    _sum?: MessageSumAggregateInputType
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }


  export type MessageGroupByOutputType = {
    id: number
    senderId: number
    receiverId: number
    content: string
    createdAt: Date
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Promise<
    Array<
      PickArray<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect = {
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    content?: boolean
    createdAt?: boolean
    sender?: boolean | UserArgs
    receiver?: boolean | UserArgs
  }

  export type MessageInclude = {
    sender?: boolean | UserArgs
    receiver?: boolean | UserArgs
  }

  export type MessageGetPayload<
    S extends boolean | null | undefined | MessageArgs,
    U = keyof S
      > = S extends true
        ? Message
    : S extends undefined
    ? never
    : S extends MessageArgs | MessageFindManyArgs
    ?'include' extends U
    ? Message  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'sender'
        ? UserGetPayload<S['include'][P]> :
        P extends 'receiver'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Message ?Message [P]
  : 
          P extends 'sender'
        ? UserGetPayload<S['select'][P]> :
        P extends 'receiver'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : Message
  : Message


  type MessageCountArgs = Merge<
    Omit<MessageFindManyArgs, 'select' | 'include'> & {
      select?: MessageCountAggregateInputType | true
    }
  >

  export interface MessageDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MessageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MessageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Message'> extends True ? CheckSelect<T, Prisma__MessageClient<Message>, Prisma__MessageClient<MessageGetPayload<T>>> : CheckSelect<T, Prisma__MessageClient<Message | null >, Prisma__MessageClient<MessageGetPayload<T> | null >>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MessageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MessageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Message'> extends True ? CheckSelect<T, Prisma__MessageClient<Message>, Prisma__MessageClient<MessageGetPayload<T>>> : CheckSelect<T, Prisma__MessageClient<Message | null >, Prisma__MessageClient<MessageGetPayload<T> | null >>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MessageFindManyArgs>(
      args?: SelectSubset<T, MessageFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Message>>, PrismaPromise<Array<MessageGetPayload<T>>>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
    **/
    create<T extends MessageCreateArgs>(
      args: SelectSubset<T, MessageCreateArgs>
    ): CheckSelect<T, Prisma__MessageClient<Message>, Prisma__MessageClient<MessageGetPayload<T>>>

    /**
     * Create many Messages.
     *     @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     *     @example
     *     // Create many Messages
     *     const message = await prisma.message.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MessageCreateManyArgs>(
      args?: SelectSubset<T, MessageCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
    **/
    delete<T extends MessageDeleteArgs>(
      args: SelectSubset<T, MessageDeleteArgs>
    ): CheckSelect<T, Prisma__MessageClient<Message>, Prisma__MessageClient<MessageGetPayload<T>>>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MessageUpdateArgs>(
      args: SelectSubset<T, MessageUpdateArgs>
    ): CheckSelect<T, Prisma__MessageClient<Message>, Prisma__MessageClient<MessageGetPayload<T>>>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MessageDeleteManyArgs>(
      args?: SelectSubset<T, MessageDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MessageUpdateManyArgs>(
      args: SelectSubset<T, MessageUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
    **/
    upsert<T extends MessageUpsertArgs>(
      args: SelectSubset<T, MessageUpsertArgs>
    ): CheckSelect<T, Prisma__MessageClient<Message>, Prisma__MessageClient<MessageGetPayload<T>>>

    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MessageClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    sender<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    receiver<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageInclude | null
    /**
     * Throw an Error if a Message can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Message to fetch.
     * 
    **/
    where: MessageWhereUniqueInput
  }


  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageInclude | null
    /**
     * Throw an Error if a Message can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Message to fetch.
     * 
    **/
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     * 
    **/
    orderBy?: Enumerable<MessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     * 
    **/
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     * 
    **/
    distinct?: Enumerable<MessageScalarFieldEnum>
  }


  /**
   * Message findMany
   */
  export type MessageFindManyArgs = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageInclude | null
    /**
     * Filter, which Messages to fetch.
     * 
    **/
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     * 
    **/
    orderBy?: Enumerable<MessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     * 
    **/
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MessageScalarFieldEnum>
  }


  /**
   * Message create
   */
  export type MessageCreateArgs = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageInclude | null
    /**
     * The data needed to create a Message.
     * 
    **/
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }


  /**
   * Message createMany
   */
  export type MessageCreateManyArgs = {
    data: Enumerable<MessageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Message update
   */
  export type MessageUpdateArgs = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageInclude | null
    /**
     * The data needed to update a Message.
     * 
    **/
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     * 
    **/
    where: MessageWhereUniqueInput
  }


  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs = {
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    where?: MessageWhereInput
  }


  /**
   * Message upsert
   */
  export type MessageUpsertArgs = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageInclude | null
    /**
     * The filter to search for the Message to update in case it exists.
     * 
    **/
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     * 
    **/
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }


  /**
   * Message delete
   */
  export type MessageDeleteArgs = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageInclude | null
    /**
     * Filter which Message to delete.
     * 
    **/
    where: MessageWhereUniqueInput
  }


  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs = {
    where?: MessageWhereInput
  }


  /**
   * Message without action
   */
  export type MessageArgs = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MessageInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    fullName: 'fullName',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AthleteCoachScalarFieldEnum: {
    id: 'id',
    coachId: 'coachId',
    athleteId: 'athleteId'
  };

  export type AthleteCoachScalarFieldEnum = (typeof AthleteCoachScalarFieldEnum)[keyof typeof AthleteCoachScalarFieldEnum]


  export const WorkoutPlanScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    creatorId: 'creatorId',
    assignedToId: 'assignedToId'
  };

  export type WorkoutPlanScalarFieldEnum = (typeof WorkoutPlanScalarFieldEnum)[keyof typeof WorkoutPlanScalarFieldEnum]


  export const ExerciseScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type ExerciseScalarFieldEnum = (typeof ExerciseScalarFieldEnum)[keyof typeof ExerciseScalarFieldEnum]


  export const WorkoutPlanExerciseScalarFieldEnum: {
    id: 'id',
    planId: 'planId',
    exerciseId: 'exerciseId',
    orderIndex: 'orderIndex'
  };

  export type WorkoutPlanExerciseScalarFieldEnum = (typeof WorkoutPlanExerciseScalarFieldEnum)[keyof typeof WorkoutPlanExerciseScalarFieldEnum]


  export const WorkoutSessionScalarFieldEnum: {
    id: 'id',
    athleteId: 'athleteId',
    planId: 'planId',
    date: 'date'
  };

  export type WorkoutSessionScalarFieldEnum = (typeof WorkoutSessionScalarFieldEnum)[keyof typeof WorkoutSessionScalarFieldEnum]


  export const WorkoutSessionExerciseScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    exerciseId: 'exerciseId',
    orderIndex: 'orderIndex'
  };

  export type WorkoutSessionExerciseScalarFieldEnum = (typeof WorkoutSessionExerciseScalarFieldEnum)[keyof typeof WorkoutSessionExerciseScalarFieldEnum]


  export const WorkoutSessionSetScalarFieldEnum: {
    id: 'id',
    sessionExerciseId: 'sessionExerciseId',
    setIndex: 'setIndex',
    reps: 'reps',
    weightKg: 'weightKg',
    rpe: 'rpe',
    notes: 'notes'
  };

  export type WorkoutSessionSetScalarFieldEnum = (typeof WorkoutSessionSetScalarFieldEnum)[keyof typeof WorkoutSessionSetScalarFieldEnum]


  export const WorkoutScalarFieldEnum: {
    id: 'id',
    date: 'date',
    durationMinutes: 'durationMinutes',
    notes: 'notes',
    createdAt: 'createdAt',
    athleteId: 'athleteId',
    workoutPlanId: 'workoutPlanId'
  };

  export type WorkoutScalarFieldEnum = (typeof WorkoutScalarFieldEnum)[keyof typeof WorkoutScalarFieldEnum]


  export const WorkoutExerciseScalarFieldEnum: {
    id: 'id',
    workoutId: 'workoutId',
    exerciseId: 'exerciseId',
    orderIndex: 'orderIndex',
    notes: 'notes'
  };

  export type WorkoutExerciseScalarFieldEnum = (typeof WorkoutExerciseScalarFieldEnum)[keyof typeof WorkoutExerciseScalarFieldEnum]


  export const WorkoutSetScalarFieldEnum: {
    id: 'id',
    workoutExerciseId: 'workoutExerciseId',
    setIndex: 'setIndex',
    reps: 'reps',
    weightKg: 'weightKg',
    rpe: 'rpe',
    notes: 'notes'
  };

  export type WorkoutSetScalarFieldEnum = (typeof WorkoutSetScalarFieldEnum)[keyof typeof WorkoutSetScalarFieldEnum]


  export const WeightScalarFieldEnum: {
    id: 'id',
    weightKg: 'weightKg',
    date: 'date',
    createdAt: 'createdAt',
    athleteId: 'athleteId'
  };

  export type WeightScalarFieldEnum = (typeof WeightScalarFieldEnum)[keyof typeof WeightScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    senderId: 'senderId',
    receiverId: 'receiverId',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: IntFilter | number
    email?: StringFilter | string
    passwordHash?: StringFilter | string
    fullName?: StringFilter | string
    role?: EnumRoleFilter | Role
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    createdWorkoutPlans?: WorkoutPlanListRelationFilter
    assignedWorkoutPlans?: WorkoutPlanListRelationFilter
    workouts?: WorkoutListRelationFilter
    weights?: WeightListRelationFilter
    coachLinks?: AthleteCoachListRelationFilter
    athleteLinks?: AthleteCoachListRelationFilter
    SentMessages?: MessageListRelationFilter
    ReceivedMessages?: MessageListRelationFilter
    workoutSessions?: WorkoutSessionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdWorkoutPlans?: WorkoutPlanOrderByRelationAggregateInput
    assignedWorkoutPlans?: WorkoutPlanOrderByRelationAggregateInput
    workouts?: WorkoutOrderByRelationAggregateInput
    weights?: WeightOrderByRelationAggregateInput
    coachLinks?: AthleteCoachOrderByRelationAggregateInput
    athleteLinks?: AthleteCoachOrderByRelationAggregateInput
    SentMessages?: MessageOrderByRelationAggregateInput
    ReceivedMessages?: MessageOrderByRelationAggregateInput
    workoutSessions?: WorkoutSessionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id?: number
    email?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    email?: StringWithAggregatesFilter | string
    passwordHash?: StringWithAggregatesFilter | string
    fullName?: StringWithAggregatesFilter | string
    role?: EnumRoleWithAggregatesFilter | Role
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type AthleteCoachWhereInput = {
    AND?: Enumerable<AthleteCoachWhereInput>
    OR?: Enumerable<AthleteCoachWhereInput>
    NOT?: Enumerable<AthleteCoachWhereInput>
    id?: IntFilter | number
    coachId?: IntFilter | number
    athleteId?: IntFilter | number
    coach?: XOR<UserRelationFilter, UserWhereInput>
    athlete?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AthleteCoachOrderByWithRelationInput = {
    id?: SortOrder
    coachId?: SortOrder
    athleteId?: SortOrder
    coach?: UserOrderByWithRelationInput
    athlete?: UserOrderByWithRelationInput
  }

  export type AthleteCoachWhereUniqueInput = {
    id?: number
    coachId_athleteId?: AthleteCoachCoachIdAthleteIdCompoundUniqueInput
  }

  export type AthleteCoachOrderByWithAggregationInput = {
    id?: SortOrder
    coachId?: SortOrder
    athleteId?: SortOrder
    _count?: AthleteCoachCountOrderByAggregateInput
    _avg?: AthleteCoachAvgOrderByAggregateInput
    _max?: AthleteCoachMaxOrderByAggregateInput
    _min?: AthleteCoachMinOrderByAggregateInput
    _sum?: AthleteCoachSumOrderByAggregateInput
  }

  export type AthleteCoachScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AthleteCoachScalarWhereWithAggregatesInput>
    OR?: Enumerable<AthleteCoachScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AthleteCoachScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    coachId?: IntWithAggregatesFilter | number
    athleteId?: IntWithAggregatesFilter | number
  }

  export type WorkoutPlanWhereInput = {
    AND?: Enumerable<WorkoutPlanWhereInput>
    OR?: Enumerable<WorkoutPlanWhereInput>
    NOT?: Enumerable<WorkoutPlanWhereInput>
    id?: IntFilter | number
    title?: StringFilter | string
    description?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    creatorId?: IntFilter | number
    assignedToId?: IntNullableFilter | number | null
    creator?: XOR<UserRelationFilter, UserWhereInput>
    assignedTo?: XOR<UserRelationFilter, UserWhereInput> | null
    exercises?: WorkoutPlanExerciseListRelationFilter
    sessions?: WorkoutSessionListRelationFilter
    workouts?: WorkoutListRelationFilter
  }

  export type WorkoutPlanOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
    assignedToId?: SortOrder
    creator?: UserOrderByWithRelationInput
    assignedTo?: UserOrderByWithRelationInput
    exercises?: WorkoutPlanExerciseOrderByRelationAggregateInput
    sessions?: WorkoutSessionOrderByRelationAggregateInput
    workouts?: WorkoutOrderByRelationAggregateInput
  }

  export type WorkoutPlanWhereUniqueInput = {
    id?: number
  }

  export type WorkoutPlanOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
    assignedToId?: SortOrder
    _count?: WorkoutPlanCountOrderByAggregateInput
    _avg?: WorkoutPlanAvgOrderByAggregateInput
    _max?: WorkoutPlanMaxOrderByAggregateInput
    _min?: WorkoutPlanMinOrderByAggregateInput
    _sum?: WorkoutPlanSumOrderByAggregateInput
  }

  export type WorkoutPlanScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WorkoutPlanScalarWhereWithAggregatesInput>
    OR?: Enumerable<WorkoutPlanScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WorkoutPlanScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    title?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    creatorId?: IntWithAggregatesFilter | number
    assignedToId?: IntNullableWithAggregatesFilter | number | null
  }

  export type ExerciseWhereInput = {
    AND?: Enumerable<ExerciseWhereInput>
    OR?: Enumerable<ExerciseWhereInput>
    NOT?: Enumerable<ExerciseWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    workoutExercises?: WorkoutExerciseListRelationFilter
    planExercises?: WorkoutPlanExerciseListRelationFilter
    sessionExercises?: WorkoutSessionExerciseListRelationFilter
  }

  export type ExerciseOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    workoutExercises?: WorkoutExerciseOrderByRelationAggregateInput
    planExercises?: WorkoutPlanExerciseOrderByRelationAggregateInput
    sessionExercises?: WorkoutSessionExerciseOrderByRelationAggregateInput
  }

  export type ExerciseWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type ExerciseOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    _count?: ExerciseCountOrderByAggregateInput
    _avg?: ExerciseAvgOrderByAggregateInput
    _max?: ExerciseMaxOrderByAggregateInput
    _min?: ExerciseMinOrderByAggregateInput
    _sum?: ExerciseSumOrderByAggregateInput
  }

  export type ExerciseScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ExerciseScalarWhereWithAggregatesInput>
    OR?: Enumerable<ExerciseScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ExerciseScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type WorkoutPlanExerciseWhereInput = {
    AND?: Enumerable<WorkoutPlanExerciseWhereInput>
    OR?: Enumerable<WorkoutPlanExerciseWhereInput>
    NOT?: Enumerable<WorkoutPlanExerciseWhereInput>
    id?: IntFilter | number
    planId?: IntFilter | number
    exerciseId?: IntFilter | number
    orderIndex?: IntFilter | number
    plan?: XOR<WorkoutPlanRelationFilter, WorkoutPlanWhereInput>
    exercise?: XOR<ExerciseRelationFilter, ExerciseWhereInput>
  }

  export type WorkoutPlanExerciseOrderByWithRelationInput = {
    id?: SortOrder
    planId?: SortOrder
    exerciseId?: SortOrder
    orderIndex?: SortOrder
    plan?: WorkoutPlanOrderByWithRelationInput
    exercise?: ExerciseOrderByWithRelationInput
  }

  export type WorkoutPlanExerciseWhereUniqueInput = {
    id?: number
  }

  export type WorkoutPlanExerciseOrderByWithAggregationInput = {
    id?: SortOrder
    planId?: SortOrder
    exerciseId?: SortOrder
    orderIndex?: SortOrder
    _count?: WorkoutPlanExerciseCountOrderByAggregateInput
    _avg?: WorkoutPlanExerciseAvgOrderByAggregateInput
    _max?: WorkoutPlanExerciseMaxOrderByAggregateInput
    _min?: WorkoutPlanExerciseMinOrderByAggregateInput
    _sum?: WorkoutPlanExerciseSumOrderByAggregateInput
  }

  export type WorkoutPlanExerciseScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WorkoutPlanExerciseScalarWhereWithAggregatesInput>
    OR?: Enumerable<WorkoutPlanExerciseScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WorkoutPlanExerciseScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    planId?: IntWithAggregatesFilter | number
    exerciseId?: IntWithAggregatesFilter | number
    orderIndex?: IntWithAggregatesFilter | number
  }

  export type WorkoutSessionWhereInput = {
    AND?: Enumerable<WorkoutSessionWhereInput>
    OR?: Enumerable<WorkoutSessionWhereInput>
    NOT?: Enumerable<WorkoutSessionWhereInput>
    id?: IntFilter | number
    athleteId?: IntFilter | number
    planId?: IntFilter | number
    date?: DateTimeFilter | Date | string
    athlete?: XOR<UserRelationFilter, UserWhereInput>
    plan?: XOR<WorkoutPlanRelationFilter, WorkoutPlanWhereInput>
    sessionExercises?: WorkoutSessionExerciseListRelationFilter
  }

  export type WorkoutSessionOrderByWithRelationInput = {
    id?: SortOrder
    athleteId?: SortOrder
    planId?: SortOrder
    date?: SortOrder
    athlete?: UserOrderByWithRelationInput
    plan?: WorkoutPlanOrderByWithRelationInput
    sessionExercises?: WorkoutSessionExerciseOrderByRelationAggregateInput
  }

  export type WorkoutSessionWhereUniqueInput = {
    id?: number
  }

  export type WorkoutSessionOrderByWithAggregationInput = {
    id?: SortOrder
    athleteId?: SortOrder
    planId?: SortOrder
    date?: SortOrder
    _count?: WorkoutSessionCountOrderByAggregateInput
    _avg?: WorkoutSessionAvgOrderByAggregateInput
    _max?: WorkoutSessionMaxOrderByAggregateInput
    _min?: WorkoutSessionMinOrderByAggregateInput
    _sum?: WorkoutSessionSumOrderByAggregateInput
  }

  export type WorkoutSessionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WorkoutSessionScalarWhereWithAggregatesInput>
    OR?: Enumerable<WorkoutSessionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WorkoutSessionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    athleteId?: IntWithAggregatesFilter | number
    planId?: IntWithAggregatesFilter | number
    date?: DateTimeWithAggregatesFilter | Date | string
  }

  export type WorkoutSessionExerciseWhereInput = {
    AND?: Enumerable<WorkoutSessionExerciseWhereInput>
    OR?: Enumerable<WorkoutSessionExerciseWhereInput>
    NOT?: Enumerable<WorkoutSessionExerciseWhereInput>
    id?: IntFilter | number
    sessionId?: IntFilter | number
    exerciseId?: IntFilter | number
    orderIndex?: IntFilter | number
    session?: XOR<WorkoutSessionRelationFilter, WorkoutSessionWhereInput>
    exercise?: XOR<ExerciseRelationFilter, ExerciseWhereInput>
    sets?: WorkoutSessionSetListRelationFilter
  }

  export type WorkoutSessionExerciseOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    exerciseId?: SortOrder
    orderIndex?: SortOrder
    session?: WorkoutSessionOrderByWithRelationInput
    exercise?: ExerciseOrderByWithRelationInput
    sets?: WorkoutSessionSetOrderByRelationAggregateInput
  }

  export type WorkoutSessionExerciseWhereUniqueInput = {
    id?: number
  }

  export type WorkoutSessionExerciseOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    exerciseId?: SortOrder
    orderIndex?: SortOrder
    _count?: WorkoutSessionExerciseCountOrderByAggregateInput
    _avg?: WorkoutSessionExerciseAvgOrderByAggregateInput
    _max?: WorkoutSessionExerciseMaxOrderByAggregateInput
    _min?: WorkoutSessionExerciseMinOrderByAggregateInput
    _sum?: WorkoutSessionExerciseSumOrderByAggregateInput
  }

  export type WorkoutSessionExerciseScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WorkoutSessionExerciseScalarWhereWithAggregatesInput>
    OR?: Enumerable<WorkoutSessionExerciseScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WorkoutSessionExerciseScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    sessionId?: IntWithAggregatesFilter | number
    exerciseId?: IntWithAggregatesFilter | number
    orderIndex?: IntWithAggregatesFilter | number
  }

  export type WorkoutSessionSetWhereInput = {
    AND?: Enumerable<WorkoutSessionSetWhereInput>
    OR?: Enumerable<WorkoutSessionSetWhereInput>
    NOT?: Enumerable<WorkoutSessionSetWhereInput>
    id?: IntFilter | number
    sessionExerciseId?: IntFilter | number
    setIndex?: IntFilter | number
    reps?: IntFilter | number
    weightKg?: FloatFilter | number
    rpe?: FloatNullableFilter | number | null
    notes?: StringNullableFilter | string | null
    sessionExercise?: XOR<WorkoutSessionExerciseRelationFilter, WorkoutSessionExerciseWhereInput>
  }

  export type WorkoutSessionSetOrderByWithRelationInput = {
    id?: SortOrder
    sessionExerciseId?: SortOrder
    setIndex?: SortOrder
    reps?: SortOrder
    weightKg?: SortOrder
    rpe?: SortOrder
    notes?: SortOrder
    sessionExercise?: WorkoutSessionExerciseOrderByWithRelationInput
  }

  export type WorkoutSessionSetWhereUniqueInput = {
    id?: number
    sessionExerciseId_setIndex?: WorkoutSessionSetSessionExerciseIdSetIndexCompoundUniqueInput
  }

  export type WorkoutSessionSetOrderByWithAggregationInput = {
    id?: SortOrder
    sessionExerciseId?: SortOrder
    setIndex?: SortOrder
    reps?: SortOrder
    weightKg?: SortOrder
    rpe?: SortOrder
    notes?: SortOrder
    _count?: WorkoutSessionSetCountOrderByAggregateInput
    _avg?: WorkoutSessionSetAvgOrderByAggregateInput
    _max?: WorkoutSessionSetMaxOrderByAggregateInput
    _min?: WorkoutSessionSetMinOrderByAggregateInput
    _sum?: WorkoutSessionSetSumOrderByAggregateInput
  }

  export type WorkoutSessionSetScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WorkoutSessionSetScalarWhereWithAggregatesInput>
    OR?: Enumerable<WorkoutSessionSetScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WorkoutSessionSetScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    sessionExerciseId?: IntWithAggregatesFilter | number
    setIndex?: IntWithAggregatesFilter | number
    reps?: IntWithAggregatesFilter | number
    weightKg?: FloatWithAggregatesFilter | number
    rpe?: FloatNullableWithAggregatesFilter | number | null
    notes?: StringNullableWithAggregatesFilter | string | null
  }

  export type WorkoutWhereInput = {
    AND?: Enumerable<WorkoutWhereInput>
    OR?: Enumerable<WorkoutWhereInput>
    NOT?: Enumerable<WorkoutWhereInput>
    id?: IntFilter | number
    date?: DateTimeFilter | Date | string
    durationMinutes?: IntFilter | number
    notes?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    athleteId?: IntFilter | number
    workoutPlanId?: IntNullableFilter | number | null
    athlete?: XOR<UserRelationFilter, UserWhereInput>
    workoutPlan?: XOR<WorkoutPlanRelationFilter, WorkoutPlanWhereInput> | null
    workoutExercises?: WorkoutExerciseListRelationFilter
  }

  export type WorkoutOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    durationMinutes?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    athleteId?: SortOrder
    workoutPlanId?: SortOrder
    athlete?: UserOrderByWithRelationInput
    workoutPlan?: WorkoutPlanOrderByWithRelationInput
    workoutExercises?: WorkoutExerciseOrderByRelationAggregateInput
  }

  export type WorkoutWhereUniqueInput = {
    id?: number
  }

  export type WorkoutOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    durationMinutes?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    athleteId?: SortOrder
    workoutPlanId?: SortOrder
    _count?: WorkoutCountOrderByAggregateInput
    _avg?: WorkoutAvgOrderByAggregateInput
    _max?: WorkoutMaxOrderByAggregateInput
    _min?: WorkoutMinOrderByAggregateInput
    _sum?: WorkoutSumOrderByAggregateInput
  }

  export type WorkoutScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WorkoutScalarWhereWithAggregatesInput>
    OR?: Enumerable<WorkoutScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WorkoutScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    date?: DateTimeWithAggregatesFilter | Date | string
    durationMinutes?: IntWithAggregatesFilter | number
    notes?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    athleteId?: IntWithAggregatesFilter | number
    workoutPlanId?: IntNullableWithAggregatesFilter | number | null
  }

  export type WorkoutExerciseWhereInput = {
    AND?: Enumerable<WorkoutExerciseWhereInput>
    OR?: Enumerable<WorkoutExerciseWhereInput>
    NOT?: Enumerable<WorkoutExerciseWhereInput>
    id?: IntFilter | number
    workoutId?: IntFilter | number
    exerciseId?: IntFilter | number
    orderIndex?: IntFilter | number
    notes?: StringNullableFilter | string | null
    workout?: XOR<WorkoutRelationFilter, WorkoutWhereInput>
    exercise?: XOR<ExerciseRelationFilter, ExerciseWhereInput>
    sets?: WorkoutSetListRelationFilter
  }

  export type WorkoutExerciseOrderByWithRelationInput = {
    id?: SortOrder
    workoutId?: SortOrder
    exerciseId?: SortOrder
    orderIndex?: SortOrder
    notes?: SortOrder
    workout?: WorkoutOrderByWithRelationInput
    exercise?: ExerciseOrderByWithRelationInput
    sets?: WorkoutSetOrderByRelationAggregateInput
  }

  export type WorkoutExerciseWhereUniqueInput = {
    id?: number
    workoutId_exerciseId_orderIndex?: WorkoutExerciseWorkoutIdExerciseIdOrderIndexCompoundUniqueInput
  }

  export type WorkoutExerciseOrderByWithAggregationInput = {
    id?: SortOrder
    workoutId?: SortOrder
    exerciseId?: SortOrder
    orderIndex?: SortOrder
    notes?: SortOrder
    _count?: WorkoutExerciseCountOrderByAggregateInput
    _avg?: WorkoutExerciseAvgOrderByAggregateInput
    _max?: WorkoutExerciseMaxOrderByAggregateInput
    _min?: WorkoutExerciseMinOrderByAggregateInput
    _sum?: WorkoutExerciseSumOrderByAggregateInput
  }

  export type WorkoutExerciseScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WorkoutExerciseScalarWhereWithAggregatesInput>
    OR?: Enumerable<WorkoutExerciseScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WorkoutExerciseScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    workoutId?: IntWithAggregatesFilter | number
    exerciseId?: IntWithAggregatesFilter | number
    orderIndex?: IntWithAggregatesFilter | number
    notes?: StringNullableWithAggregatesFilter | string | null
  }

  export type WorkoutSetWhereInput = {
    AND?: Enumerable<WorkoutSetWhereInput>
    OR?: Enumerable<WorkoutSetWhereInput>
    NOT?: Enumerable<WorkoutSetWhereInput>
    id?: IntFilter | number
    workoutExerciseId?: IntFilter | number
    setIndex?: IntFilter | number
    reps?: IntFilter | number
    weightKg?: FloatFilter | number
    rpe?: FloatNullableFilter | number | null
    notes?: StringNullableFilter | string | null
    workoutExercise?: XOR<WorkoutExerciseRelationFilter, WorkoutExerciseWhereInput>
  }

  export type WorkoutSetOrderByWithRelationInput = {
    id?: SortOrder
    workoutExerciseId?: SortOrder
    setIndex?: SortOrder
    reps?: SortOrder
    weightKg?: SortOrder
    rpe?: SortOrder
    notes?: SortOrder
    workoutExercise?: WorkoutExerciseOrderByWithRelationInput
  }

  export type WorkoutSetWhereUniqueInput = {
    id?: number
    workoutExerciseId_setIndex?: WorkoutSetWorkoutExerciseIdSetIndexCompoundUniqueInput
  }

  export type WorkoutSetOrderByWithAggregationInput = {
    id?: SortOrder
    workoutExerciseId?: SortOrder
    setIndex?: SortOrder
    reps?: SortOrder
    weightKg?: SortOrder
    rpe?: SortOrder
    notes?: SortOrder
    _count?: WorkoutSetCountOrderByAggregateInput
    _avg?: WorkoutSetAvgOrderByAggregateInput
    _max?: WorkoutSetMaxOrderByAggregateInput
    _min?: WorkoutSetMinOrderByAggregateInput
    _sum?: WorkoutSetSumOrderByAggregateInput
  }

  export type WorkoutSetScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WorkoutSetScalarWhereWithAggregatesInput>
    OR?: Enumerable<WorkoutSetScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WorkoutSetScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    workoutExerciseId?: IntWithAggregatesFilter | number
    setIndex?: IntWithAggregatesFilter | number
    reps?: IntWithAggregatesFilter | number
    weightKg?: FloatWithAggregatesFilter | number
    rpe?: FloatNullableWithAggregatesFilter | number | null
    notes?: StringNullableWithAggregatesFilter | string | null
  }

  export type WeightWhereInput = {
    AND?: Enumerable<WeightWhereInput>
    OR?: Enumerable<WeightWhereInput>
    NOT?: Enumerable<WeightWhereInput>
    id?: IntFilter | number
    weightKg?: FloatFilter | number
    date?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    athleteId?: IntFilter | number
    athlete?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type WeightOrderByWithRelationInput = {
    id?: SortOrder
    weightKg?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    athleteId?: SortOrder
    athlete?: UserOrderByWithRelationInput
  }

  export type WeightWhereUniqueInput = {
    id?: number
  }

  export type WeightOrderByWithAggregationInput = {
    id?: SortOrder
    weightKg?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    athleteId?: SortOrder
    _count?: WeightCountOrderByAggregateInput
    _avg?: WeightAvgOrderByAggregateInput
    _max?: WeightMaxOrderByAggregateInput
    _min?: WeightMinOrderByAggregateInput
    _sum?: WeightSumOrderByAggregateInput
  }

  export type WeightScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WeightScalarWhereWithAggregatesInput>
    OR?: Enumerable<WeightScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WeightScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    weightKg?: FloatWithAggregatesFilter | number
    date?: DateTimeWithAggregatesFilter | Date | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    athleteId?: IntWithAggregatesFilter | number
  }

  export type MessageWhereInput = {
    AND?: Enumerable<MessageWhereInput>
    OR?: Enumerable<MessageWhereInput>
    NOT?: Enumerable<MessageWhereInput>
    id?: IntFilter | number
    senderId?: IntFilter | number
    receiverId?: IntFilter | number
    content?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    sender?: XOR<UserRelationFilter, UserWhereInput>
    receiver?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    sender?: UserOrderByWithRelationInput
    receiver?: UserOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = {
    id?: number
  }

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _avg?: MessageAvgOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
    _sum?: MessageSumOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MessageScalarWhereWithAggregatesInput>
    OR?: Enumerable<MessageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MessageScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    senderId?: IntWithAggregatesFilter | number
    receiverId?: IntWithAggregatesFilter | number
    content?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserCreateInput = {
    email: string
    passwordHash: string
    fullName: string
    role: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    createdWorkoutPlans?: WorkoutPlanCreateNestedManyWithoutCreatorInput
    assignedWorkoutPlans?: WorkoutPlanCreateNestedManyWithoutAssignedToInput
    workouts?: WorkoutCreateNestedManyWithoutAthleteInput
    weights?: WeightCreateNestedManyWithoutAthleteInput
    coachLinks?: AthleteCoachCreateNestedManyWithoutCoachInput
    athleteLinks?: AthleteCoachCreateNestedManyWithoutAthleteInput
    SentMessages?: MessageCreateNestedManyWithoutSenderInput
    ReceivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    workoutSessions?: WorkoutSessionCreateNestedManyWithoutAthleteInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    passwordHash: string
    fullName: string
    role: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    createdWorkoutPlans?: WorkoutPlanUncheckedCreateNestedManyWithoutCreatorInput
    assignedWorkoutPlans?: WorkoutPlanUncheckedCreateNestedManyWithoutAssignedToInput
    workouts?: WorkoutUncheckedCreateNestedManyWithoutAthleteInput
    weights?: WeightUncheckedCreateNestedManyWithoutAthleteInput
    coachLinks?: AthleteCoachUncheckedCreateNestedManyWithoutCoachInput
    athleteLinks?: AthleteCoachUncheckedCreateNestedManyWithoutAthleteInput
    SentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    ReceivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    workoutSessions?: WorkoutSessionUncheckedCreateNestedManyWithoutAthleteInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdWorkoutPlans?: WorkoutPlanUpdateManyWithoutCreatorInput
    assignedWorkoutPlans?: WorkoutPlanUpdateManyWithoutAssignedToInput
    workouts?: WorkoutUpdateManyWithoutAthleteInput
    weights?: WeightUpdateManyWithoutAthleteInput
    coachLinks?: AthleteCoachUpdateManyWithoutCoachInput
    athleteLinks?: AthleteCoachUpdateManyWithoutAthleteInput
    SentMessages?: MessageUpdateManyWithoutSenderInput
    ReceivedMessages?: MessageUpdateManyWithoutReceiverInput
    workoutSessions?: WorkoutSessionUpdateManyWithoutAthleteInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdWorkoutPlans?: WorkoutPlanUncheckedUpdateManyWithoutCreatorInput
    assignedWorkoutPlans?: WorkoutPlanUncheckedUpdateManyWithoutAssignedToInput
    workouts?: WorkoutUncheckedUpdateManyWithoutAthleteInput
    weights?: WeightUncheckedUpdateManyWithoutAthleteInput
    coachLinks?: AthleteCoachUncheckedUpdateManyWithoutCoachInput
    athleteLinks?: AthleteCoachUncheckedUpdateManyWithoutAthleteInput
    SentMessages?: MessageUncheckedUpdateManyWithoutSenderInput
    ReceivedMessages?: MessageUncheckedUpdateManyWithoutReceiverInput
    workoutSessions?: WorkoutSessionUncheckedUpdateManyWithoutAthleteInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    passwordHash: string
    fullName: string
    role: Role
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AthleteCoachCreateInput = {
    coach: UserCreateNestedOneWithoutCoachLinksInput
    athlete: UserCreateNestedOneWithoutAthleteLinksInput
  }

  export type AthleteCoachUncheckedCreateInput = {
    id?: number
    coachId: number
    athleteId: number
  }

  export type AthleteCoachUpdateInput = {
    coach?: UserUpdateOneRequiredWithoutCoachLinksInput
    athlete?: UserUpdateOneRequiredWithoutAthleteLinksInput
  }

  export type AthleteCoachUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    coachId?: IntFieldUpdateOperationsInput | number
    athleteId?: IntFieldUpdateOperationsInput | number
  }

  export type AthleteCoachCreateManyInput = {
    id?: number
    coachId: number
    athleteId: number
  }

  export type AthleteCoachUpdateManyMutationInput = {

  }

  export type AthleteCoachUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    coachId?: IntFieldUpdateOperationsInput | number
    athleteId?: IntFieldUpdateOperationsInput | number
  }

  export type WorkoutPlanCreateInput = {
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedWorkoutPlansInput
    assignedTo?: UserCreateNestedOneWithoutAssignedWorkoutPlansInput
    exercises?: WorkoutPlanExerciseCreateNestedManyWithoutPlanInput
    sessions?: WorkoutSessionCreateNestedManyWithoutPlanInput
    workouts?: WorkoutCreateNestedManyWithoutWorkoutPlanInput
  }

  export type WorkoutPlanUncheckedCreateInput = {
    id?: number
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: number
    assignedToId?: number | null
    exercises?: WorkoutPlanExerciseUncheckedCreateNestedManyWithoutPlanInput
    sessions?: WorkoutSessionUncheckedCreateNestedManyWithoutPlanInput
    workouts?: WorkoutUncheckedCreateNestedManyWithoutWorkoutPlanInput
  }

  export type WorkoutPlanUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedWorkoutPlansInput
    assignedTo?: UserUpdateOneWithoutAssignedWorkoutPlansInput
    exercises?: WorkoutPlanExerciseUpdateManyWithoutPlanInput
    sessions?: WorkoutSessionUpdateManyWithoutPlanInput
    workouts?: WorkoutUpdateManyWithoutWorkoutPlanInput
  }

  export type WorkoutPlanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    exercises?: WorkoutPlanExerciseUncheckedUpdateManyWithoutPlanInput
    sessions?: WorkoutSessionUncheckedUpdateManyWithoutPlanInput
    workouts?: WorkoutUncheckedUpdateManyWithoutWorkoutPlanInput
  }

  export type WorkoutPlanCreateManyInput = {
    id?: number
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: number
    assignedToId?: number | null
  }

  export type WorkoutPlanUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutPlanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ExerciseCreateInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    workoutExercises?: WorkoutExerciseCreateNestedManyWithoutExerciseInput
    planExercises?: WorkoutPlanExerciseCreateNestedManyWithoutExerciseInput
    sessionExercises?: WorkoutSessionExerciseCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    workoutExercises?: WorkoutExerciseUncheckedCreateNestedManyWithoutExerciseInput
    planExercises?: WorkoutPlanExerciseUncheckedCreateNestedManyWithoutExerciseInput
    sessionExercises?: WorkoutSessionExerciseUncheckedCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workoutExercises?: WorkoutExerciseUpdateManyWithoutExerciseInput
    planExercises?: WorkoutPlanExerciseUpdateManyWithoutExerciseInput
    sessionExercises?: WorkoutSessionExerciseUpdateManyWithoutExerciseInput
  }

  export type ExerciseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workoutExercises?: WorkoutExerciseUncheckedUpdateManyWithoutExerciseInput
    planExercises?: WorkoutPlanExerciseUncheckedUpdateManyWithoutExerciseInput
    sessionExercises?: WorkoutSessionExerciseUncheckedUpdateManyWithoutExerciseInput
  }

  export type ExerciseCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
  }

  export type ExerciseUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutPlanExerciseCreateInput = {
    orderIndex?: number
    plan: WorkoutPlanCreateNestedOneWithoutExercisesInput
    exercise: ExerciseCreateNestedOneWithoutPlanExercisesInput
  }

  export type WorkoutPlanExerciseUncheckedCreateInput = {
    id?: number
    planId: number
    exerciseId: number
    orderIndex?: number
  }

  export type WorkoutPlanExerciseUpdateInput = {
    orderIndex?: IntFieldUpdateOperationsInput | number
    plan?: WorkoutPlanUpdateOneRequiredWithoutExercisesInput
    exercise?: ExerciseUpdateOneRequiredWithoutPlanExercisesInput
  }

  export type WorkoutPlanExerciseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    planId?: IntFieldUpdateOperationsInput | number
    exerciseId?: IntFieldUpdateOperationsInput | number
    orderIndex?: IntFieldUpdateOperationsInput | number
  }

  export type WorkoutPlanExerciseCreateManyInput = {
    id?: number
    planId: number
    exerciseId: number
    orderIndex?: number
  }

  export type WorkoutPlanExerciseUpdateManyMutationInput = {
    orderIndex?: IntFieldUpdateOperationsInput | number
  }

  export type WorkoutPlanExerciseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    planId?: IntFieldUpdateOperationsInput | number
    exerciseId?: IntFieldUpdateOperationsInput | number
    orderIndex?: IntFieldUpdateOperationsInput | number
  }

  export type WorkoutSessionCreateInput = {
    date?: Date | string
    athlete: UserCreateNestedOneWithoutWorkoutSessionsInput
    plan: WorkoutPlanCreateNestedOneWithoutSessionsInput
    sessionExercises?: WorkoutSessionExerciseCreateNestedManyWithoutSessionInput
  }

  export type WorkoutSessionUncheckedCreateInput = {
    id?: number
    athleteId: number
    planId: number
    date?: Date | string
    sessionExercises?: WorkoutSessionExerciseUncheckedCreateNestedManyWithoutSessionInput
  }

  export type WorkoutSessionUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    athlete?: UserUpdateOneRequiredWithoutWorkoutSessionsInput
    plan?: WorkoutPlanUpdateOneRequiredWithoutSessionsInput
    sessionExercises?: WorkoutSessionExerciseUpdateManyWithoutSessionInput
  }

  export type WorkoutSessionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    athleteId?: IntFieldUpdateOperationsInput | number
    planId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionExercises?: WorkoutSessionExerciseUncheckedUpdateManyWithoutSessionInput
  }

  export type WorkoutSessionCreateManyInput = {
    id?: number
    athleteId: number
    planId: number
    date?: Date | string
  }

  export type WorkoutSessionUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutSessionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    athleteId?: IntFieldUpdateOperationsInput | number
    planId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutSessionExerciseCreateInput = {
    orderIndex?: number
    session: WorkoutSessionCreateNestedOneWithoutSessionExercisesInput
    exercise: ExerciseCreateNestedOneWithoutSessionExercisesInput
    sets?: WorkoutSessionSetCreateNestedManyWithoutSessionExerciseInput
  }

  export type WorkoutSessionExerciseUncheckedCreateInput = {
    id?: number
    sessionId: number
    exerciseId: number
    orderIndex?: number
    sets?: WorkoutSessionSetUncheckedCreateNestedManyWithoutSessionExerciseInput
  }

  export type WorkoutSessionExerciseUpdateInput = {
    orderIndex?: IntFieldUpdateOperationsInput | number
    session?: WorkoutSessionUpdateOneRequiredWithoutSessionExercisesInput
    exercise?: ExerciseUpdateOneRequiredWithoutSessionExercisesInput
    sets?: WorkoutSessionSetUpdateManyWithoutSessionExerciseInput
  }

  export type WorkoutSessionExerciseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: IntFieldUpdateOperationsInput | number
    exerciseId?: IntFieldUpdateOperationsInput | number
    orderIndex?: IntFieldUpdateOperationsInput | number
    sets?: WorkoutSessionSetUncheckedUpdateManyWithoutSessionExerciseInput
  }

  export type WorkoutSessionExerciseCreateManyInput = {
    id?: number
    sessionId: number
    exerciseId: number
    orderIndex?: number
  }

  export type WorkoutSessionExerciseUpdateManyMutationInput = {
    orderIndex?: IntFieldUpdateOperationsInput | number
  }

  export type WorkoutSessionExerciseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: IntFieldUpdateOperationsInput | number
    exerciseId?: IntFieldUpdateOperationsInput | number
    orderIndex?: IntFieldUpdateOperationsInput | number
  }

  export type WorkoutSessionSetCreateInput = {
    setIndex?: number
    reps: number
    weightKg: number
    rpe?: number | null
    notes?: string | null
    sessionExercise: WorkoutSessionExerciseCreateNestedOneWithoutSetsInput
  }

  export type WorkoutSessionSetUncheckedCreateInput = {
    id?: number
    sessionExerciseId: number
    setIndex?: number
    reps: number
    weightKg: number
    rpe?: number | null
    notes?: string | null
  }

  export type WorkoutSessionSetUpdateInput = {
    setIndex?: IntFieldUpdateOperationsInput | number
    reps?: IntFieldUpdateOperationsInput | number
    weightKg?: FloatFieldUpdateOperationsInput | number
    rpe?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sessionExercise?: WorkoutSessionExerciseUpdateOneRequiredWithoutSetsInput
  }

  export type WorkoutSessionSetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionExerciseId?: IntFieldUpdateOperationsInput | number
    setIndex?: IntFieldUpdateOperationsInput | number
    reps?: IntFieldUpdateOperationsInput | number
    weightKg?: FloatFieldUpdateOperationsInput | number
    rpe?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkoutSessionSetCreateManyInput = {
    id?: number
    sessionExerciseId: number
    setIndex?: number
    reps: number
    weightKg: number
    rpe?: number | null
    notes?: string | null
  }

  export type WorkoutSessionSetUpdateManyMutationInput = {
    setIndex?: IntFieldUpdateOperationsInput | number
    reps?: IntFieldUpdateOperationsInput | number
    weightKg?: FloatFieldUpdateOperationsInput | number
    rpe?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkoutSessionSetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionExerciseId?: IntFieldUpdateOperationsInput | number
    setIndex?: IntFieldUpdateOperationsInput | number
    reps?: IntFieldUpdateOperationsInput | number
    weightKg?: FloatFieldUpdateOperationsInput | number
    rpe?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkoutCreateInput = {
    date: Date | string
    durationMinutes: number
    notes?: string | null
    createdAt?: Date | string
    athlete: UserCreateNestedOneWithoutWorkoutsInput
    workoutPlan?: WorkoutPlanCreateNestedOneWithoutWorkoutsInput
    workoutExercises?: WorkoutExerciseCreateNestedManyWithoutWorkoutInput
  }

  export type WorkoutUncheckedCreateInput = {
    id?: number
    date: Date | string
    durationMinutes: number
    notes?: string | null
    createdAt?: Date | string
    athleteId: number
    workoutPlanId?: number | null
    workoutExercises?: WorkoutExerciseUncheckedCreateNestedManyWithoutWorkoutInput
  }

  export type WorkoutUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    athlete?: UserUpdateOneRequiredWithoutWorkoutsInput
    workoutPlan?: WorkoutPlanUpdateOneWithoutWorkoutsInput
    workoutExercises?: WorkoutExerciseUpdateManyWithoutWorkoutInput
  }

  export type WorkoutUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    athleteId?: IntFieldUpdateOperationsInput | number
    workoutPlanId?: NullableIntFieldUpdateOperationsInput | number | null
    workoutExercises?: WorkoutExerciseUncheckedUpdateManyWithoutWorkoutInput
  }

  export type WorkoutCreateManyInput = {
    id?: number
    date: Date | string
    durationMinutes: number
    notes?: string | null
    createdAt?: Date | string
    athleteId: number
    workoutPlanId?: number | null
  }

  export type WorkoutUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    athleteId?: IntFieldUpdateOperationsInput | number
    workoutPlanId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WorkoutExerciseCreateInput = {
    orderIndex?: number
    notes?: string | null
    workout: WorkoutCreateNestedOneWithoutWorkoutExercisesInput
    exercise: ExerciseCreateNestedOneWithoutWorkoutExercisesInput
    sets?: WorkoutSetCreateNestedManyWithoutWorkoutExerciseInput
  }

  export type WorkoutExerciseUncheckedCreateInput = {
    id?: number
    workoutId: number
    exerciseId: number
    orderIndex?: number
    notes?: string | null
    sets?: WorkoutSetUncheckedCreateNestedManyWithoutWorkoutExerciseInput
  }

  export type WorkoutExerciseUpdateInput = {
    orderIndex?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    workout?: WorkoutUpdateOneRequiredWithoutWorkoutExercisesInput
    exercise?: ExerciseUpdateOneRequiredWithoutWorkoutExercisesInput
    sets?: WorkoutSetUpdateManyWithoutWorkoutExerciseInput
  }

  export type WorkoutExerciseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    workoutId?: IntFieldUpdateOperationsInput | number
    exerciseId?: IntFieldUpdateOperationsInput | number
    orderIndex?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sets?: WorkoutSetUncheckedUpdateManyWithoutWorkoutExerciseInput
  }

  export type WorkoutExerciseCreateManyInput = {
    id?: number
    workoutId: number
    exerciseId: number
    orderIndex?: number
    notes?: string | null
  }

  export type WorkoutExerciseUpdateManyMutationInput = {
    orderIndex?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkoutExerciseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    workoutId?: IntFieldUpdateOperationsInput | number
    exerciseId?: IntFieldUpdateOperationsInput | number
    orderIndex?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkoutSetCreateInput = {
    setIndex?: number
    reps: number
    weightKg: number
    rpe?: number | null
    notes?: string | null
    workoutExercise: WorkoutExerciseCreateNestedOneWithoutSetsInput
  }

  export type WorkoutSetUncheckedCreateInput = {
    id?: number
    workoutExerciseId: number
    setIndex?: number
    reps: number
    weightKg: number
    rpe?: number | null
    notes?: string | null
  }

  export type WorkoutSetUpdateInput = {
    setIndex?: IntFieldUpdateOperationsInput | number
    reps?: IntFieldUpdateOperationsInput | number
    weightKg?: FloatFieldUpdateOperationsInput | number
    rpe?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    workoutExercise?: WorkoutExerciseUpdateOneRequiredWithoutSetsInput
  }

  export type WorkoutSetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    workoutExerciseId?: IntFieldUpdateOperationsInput | number
    setIndex?: IntFieldUpdateOperationsInput | number
    reps?: IntFieldUpdateOperationsInput | number
    weightKg?: FloatFieldUpdateOperationsInput | number
    rpe?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkoutSetCreateManyInput = {
    id?: number
    workoutExerciseId: number
    setIndex?: number
    reps: number
    weightKg: number
    rpe?: number | null
    notes?: string | null
  }

  export type WorkoutSetUpdateManyMutationInput = {
    setIndex?: IntFieldUpdateOperationsInput | number
    reps?: IntFieldUpdateOperationsInput | number
    weightKg?: FloatFieldUpdateOperationsInput | number
    rpe?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkoutSetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    workoutExerciseId?: IntFieldUpdateOperationsInput | number
    setIndex?: IntFieldUpdateOperationsInput | number
    reps?: IntFieldUpdateOperationsInput | number
    weightKg?: FloatFieldUpdateOperationsInput | number
    rpe?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WeightCreateInput = {
    weightKg: number
    date: Date | string
    createdAt?: Date | string
    athlete: UserCreateNestedOneWithoutWeightsInput
  }

  export type WeightUncheckedCreateInput = {
    id?: number
    weightKg: number
    date: Date | string
    createdAt?: Date | string
    athleteId: number
  }

  export type WeightUpdateInput = {
    weightKg?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    athlete?: UserUpdateOneRequiredWithoutWeightsInput
  }

  export type WeightUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    weightKg?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    athleteId?: IntFieldUpdateOperationsInput | number
  }

  export type WeightCreateManyInput = {
    id?: number
    weightKg: number
    date: Date | string
    createdAt?: Date | string
    athleteId: number
  }

  export type WeightUpdateManyMutationInput = {
    weightKg?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeightUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    weightKg?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    athleteId?: IntFieldUpdateOperationsInput | number
  }

  export type MessageCreateInput = {
    content: string
    createdAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
    receiver: UserCreateNestedOneWithoutReceivedMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: number
    senderId: number
    receiverId: number
    content: string
    createdAt?: Date | string
  }

  export type MessageUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesInput
    receiver?: UserUpdateOneRequiredWithoutReceivedMessagesInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    receiverId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyInput = {
    id?: number
    senderId: number
    receiverId: number
    content: string
    createdAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    receiverId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type EnumRoleFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleFilter | Role
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type WorkoutPlanListRelationFilter = {
    every?: WorkoutPlanWhereInput
    some?: WorkoutPlanWhereInput
    none?: WorkoutPlanWhereInput
  }

  export type WorkoutListRelationFilter = {
    every?: WorkoutWhereInput
    some?: WorkoutWhereInput
    none?: WorkoutWhereInput
  }

  export type WeightListRelationFilter = {
    every?: WeightWhereInput
    some?: WeightWhereInput
    none?: WeightWhereInput
  }

  export type AthleteCoachListRelationFilter = {
    every?: AthleteCoachWhereInput
    some?: AthleteCoachWhereInput
    none?: AthleteCoachWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type WorkoutSessionListRelationFilter = {
    every?: WorkoutSessionWhereInput
    some?: WorkoutSessionWhereInput
    none?: WorkoutSessionWhereInput
  }

  export type WorkoutPlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkoutOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WeightOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AthleteCoachOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkoutSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type EnumRoleWithAggregatesFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleWithAggregatesFilter | Role
    _count?: NestedIntFilter
    _min?: NestedEnumRoleFilter
    _max?: NestedEnumRoleFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AthleteCoachCoachIdAthleteIdCompoundUniqueInput = {
    coachId: number
    athleteId: number
  }

  export type AthleteCoachCountOrderByAggregateInput = {
    id?: SortOrder
    coachId?: SortOrder
    athleteId?: SortOrder
  }

  export type AthleteCoachAvgOrderByAggregateInput = {
    id?: SortOrder
    coachId?: SortOrder
    athleteId?: SortOrder
  }

  export type AthleteCoachMaxOrderByAggregateInput = {
    id?: SortOrder
    coachId?: SortOrder
    athleteId?: SortOrder
  }

  export type AthleteCoachMinOrderByAggregateInput = {
    id?: SortOrder
    coachId?: SortOrder
    athleteId?: SortOrder
  }

  export type AthleteCoachSumOrderByAggregateInput = {
    id?: SortOrder
    coachId?: SortOrder
    athleteId?: SortOrder
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type WorkoutPlanExerciseListRelationFilter = {
    every?: WorkoutPlanExerciseWhereInput
    some?: WorkoutPlanExerciseWhereInput
    none?: WorkoutPlanExerciseWhereInput
  }

  export type WorkoutPlanExerciseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkoutPlanCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
    assignedToId?: SortOrder
  }

  export type WorkoutPlanAvgOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    assignedToId?: SortOrder
  }

  export type WorkoutPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
    assignedToId?: SortOrder
  }

  export type WorkoutPlanMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
    assignedToId?: SortOrder
  }

  export type WorkoutPlanSumOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    assignedToId?: SortOrder
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type WorkoutExerciseListRelationFilter = {
    every?: WorkoutExerciseWhereInput
    some?: WorkoutExerciseWhereInput
    none?: WorkoutExerciseWhereInput
  }

  export type WorkoutSessionExerciseListRelationFilter = {
    every?: WorkoutSessionExerciseWhereInput
    some?: WorkoutSessionExerciseWhereInput
    none?: WorkoutSessionExerciseWhereInput
  }

  export type WorkoutExerciseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkoutSessionExerciseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExerciseCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type ExerciseAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ExerciseMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type ExerciseMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type ExerciseSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type WorkoutPlanRelationFilter = {
    is?: WorkoutPlanWhereInput | null
    isNot?: WorkoutPlanWhereInput | null
  }

  export type ExerciseRelationFilter = {
    is?: ExerciseWhereInput
    isNot?: ExerciseWhereInput
  }

  export type WorkoutPlanExerciseCountOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    exerciseId?: SortOrder
    orderIndex?: SortOrder
  }

  export type WorkoutPlanExerciseAvgOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    exerciseId?: SortOrder
    orderIndex?: SortOrder
  }

  export type WorkoutPlanExerciseMaxOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    exerciseId?: SortOrder
    orderIndex?: SortOrder
  }

  export type WorkoutPlanExerciseMinOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    exerciseId?: SortOrder
    orderIndex?: SortOrder
  }

  export type WorkoutPlanExerciseSumOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    exerciseId?: SortOrder
    orderIndex?: SortOrder
  }

  export type WorkoutSessionCountOrderByAggregateInput = {
    id?: SortOrder
    athleteId?: SortOrder
    planId?: SortOrder
    date?: SortOrder
  }

  export type WorkoutSessionAvgOrderByAggregateInput = {
    id?: SortOrder
    athleteId?: SortOrder
    planId?: SortOrder
  }

  export type WorkoutSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    athleteId?: SortOrder
    planId?: SortOrder
    date?: SortOrder
  }

  export type WorkoutSessionMinOrderByAggregateInput = {
    id?: SortOrder
    athleteId?: SortOrder
    planId?: SortOrder
    date?: SortOrder
  }

  export type WorkoutSessionSumOrderByAggregateInput = {
    id?: SortOrder
    athleteId?: SortOrder
    planId?: SortOrder
  }

  export type WorkoutSessionRelationFilter = {
    is?: WorkoutSessionWhereInput
    isNot?: WorkoutSessionWhereInput
  }

  export type WorkoutSessionSetListRelationFilter = {
    every?: WorkoutSessionSetWhereInput
    some?: WorkoutSessionSetWhereInput
    none?: WorkoutSessionSetWhereInput
  }

  export type WorkoutSessionSetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkoutSessionExerciseCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    exerciseId?: SortOrder
    orderIndex?: SortOrder
  }

  export type WorkoutSessionExerciseAvgOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    exerciseId?: SortOrder
    orderIndex?: SortOrder
  }

  export type WorkoutSessionExerciseMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    exerciseId?: SortOrder
    orderIndex?: SortOrder
  }

  export type WorkoutSessionExerciseMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    exerciseId?: SortOrder
    orderIndex?: SortOrder
  }

  export type WorkoutSessionExerciseSumOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    exerciseId?: SortOrder
    orderIndex?: SortOrder
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type WorkoutSessionExerciseRelationFilter = {
    is?: WorkoutSessionExerciseWhereInput
    isNot?: WorkoutSessionExerciseWhereInput
  }

  export type WorkoutSessionSetSessionExerciseIdSetIndexCompoundUniqueInput = {
    sessionExerciseId: number
    setIndex: number
  }

  export type WorkoutSessionSetCountOrderByAggregateInput = {
    id?: SortOrder
    sessionExerciseId?: SortOrder
    setIndex?: SortOrder
    reps?: SortOrder
    weightKg?: SortOrder
    rpe?: SortOrder
    notes?: SortOrder
  }

  export type WorkoutSessionSetAvgOrderByAggregateInput = {
    id?: SortOrder
    sessionExerciseId?: SortOrder
    setIndex?: SortOrder
    reps?: SortOrder
    weightKg?: SortOrder
    rpe?: SortOrder
  }

  export type WorkoutSessionSetMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionExerciseId?: SortOrder
    setIndex?: SortOrder
    reps?: SortOrder
    weightKg?: SortOrder
    rpe?: SortOrder
    notes?: SortOrder
  }

  export type WorkoutSessionSetMinOrderByAggregateInput = {
    id?: SortOrder
    sessionExerciseId?: SortOrder
    setIndex?: SortOrder
    reps?: SortOrder
    weightKg?: SortOrder
    rpe?: SortOrder
    notes?: SortOrder
  }

  export type WorkoutSessionSetSumOrderByAggregateInput = {
    id?: SortOrder
    sessionExerciseId?: SortOrder
    setIndex?: SortOrder
    reps?: SortOrder
    weightKg?: SortOrder
    rpe?: SortOrder
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type FloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type WorkoutCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    durationMinutes?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    athleteId?: SortOrder
    workoutPlanId?: SortOrder
  }

  export type WorkoutAvgOrderByAggregateInput = {
    id?: SortOrder
    durationMinutes?: SortOrder
    athleteId?: SortOrder
    workoutPlanId?: SortOrder
  }

  export type WorkoutMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    durationMinutes?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    athleteId?: SortOrder
    workoutPlanId?: SortOrder
  }

  export type WorkoutMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    durationMinutes?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    athleteId?: SortOrder
    workoutPlanId?: SortOrder
  }

  export type WorkoutSumOrderByAggregateInput = {
    id?: SortOrder
    durationMinutes?: SortOrder
    athleteId?: SortOrder
    workoutPlanId?: SortOrder
  }

  export type WorkoutRelationFilter = {
    is?: WorkoutWhereInput
    isNot?: WorkoutWhereInput
  }

  export type WorkoutSetListRelationFilter = {
    every?: WorkoutSetWhereInput
    some?: WorkoutSetWhereInput
    none?: WorkoutSetWhereInput
  }

  export type WorkoutSetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkoutExerciseWorkoutIdExerciseIdOrderIndexCompoundUniqueInput = {
    workoutId: number
    exerciseId: number
    orderIndex: number
  }

  export type WorkoutExerciseCountOrderByAggregateInput = {
    id?: SortOrder
    workoutId?: SortOrder
    exerciseId?: SortOrder
    orderIndex?: SortOrder
    notes?: SortOrder
  }

  export type WorkoutExerciseAvgOrderByAggregateInput = {
    id?: SortOrder
    workoutId?: SortOrder
    exerciseId?: SortOrder
    orderIndex?: SortOrder
  }

  export type WorkoutExerciseMaxOrderByAggregateInput = {
    id?: SortOrder
    workoutId?: SortOrder
    exerciseId?: SortOrder
    orderIndex?: SortOrder
    notes?: SortOrder
  }

  export type WorkoutExerciseMinOrderByAggregateInput = {
    id?: SortOrder
    workoutId?: SortOrder
    exerciseId?: SortOrder
    orderIndex?: SortOrder
    notes?: SortOrder
  }

  export type WorkoutExerciseSumOrderByAggregateInput = {
    id?: SortOrder
    workoutId?: SortOrder
    exerciseId?: SortOrder
    orderIndex?: SortOrder
  }

  export type WorkoutExerciseRelationFilter = {
    is?: WorkoutExerciseWhereInput
    isNot?: WorkoutExerciseWhereInput
  }

  export type WorkoutSetWorkoutExerciseIdSetIndexCompoundUniqueInput = {
    workoutExerciseId: number
    setIndex: number
  }

  export type WorkoutSetCountOrderByAggregateInput = {
    id?: SortOrder
    workoutExerciseId?: SortOrder
    setIndex?: SortOrder
    reps?: SortOrder
    weightKg?: SortOrder
    rpe?: SortOrder
    notes?: SortOrder
  }

  export type WorkoutSetAvgOrderByAggregateInput = {
    id?: SortOrder
    workoutExerciseId?: SortOrder
    setIndex?: SortOrder
    reps?: SortOrder
    weightKg?: SortOrder
    rpe?: SortOrder
  }

  export type WorkoutSetMaxOrderByAggregateInput = {
    id?: SortOrder
    workoutExerciseId?: SortOrder
    setIndex?: SortOrder
    reps?: SortOrder
    weightKg?: SortOrder
    rpe?: SortOrder
    notes?: SortOrder
  }

  export type WorkoutSetMinOrderByAggregateInput = {
    id?: SortOrder
    workoutExerciseId?: SortOrder
    setIndex?: SortOrder
    reps?: SortOrder
    weightKg?: SortOrder
    rpe?: SortOrder
    notes?: SortOrder
  }

  export type WorkoutSetSumOrderByAggregateInput = {
    id?: SortOrder
    workoutExerciseId?: SortOrder
    setIndex?: SortOrder
    reps?: SortOrder
    weightKg?: SortOrder
    rpe?: SortOrder
  }

  export type WeightCountOrderByAggregateInput = {
    id?: SortOrder
    weightKg?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    athleteId?: SortOrder
  }

  export type WeightAvgOrderByAggregateInput = {
    id?: SortOrder
    weightKg?: SortOrder
    athleteId?: SortOrder
  }

  export type WeightMaxOrderByAggregateInput = {
    id?: SortOrder
    weightKg?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    athleteId?: SortOrder
  }

  export type WeightMinOrderByAggregateInput = {
    id?: SortOrder
    weightKg?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    athleteId?: SortOrder
  }

  export type WeightSumOrderByAggregateInput = {
    id?: SortOrder
    weightKg?: SortOrder
    athleteId?: SortOrder
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageAvgOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageSumOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
  }

  export type WorkoutPlanCreateNestedManyWithoutCreatorInput = {
    create?: XOR<Enumerable<WorkoutPlanCreateWithoutCreatorInput>, Enumerable<WorkoutPlanUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<WorkoutPlanCreateOrConnectWithoutCreatorInput>
    createMany?: WorkoutPlanCreateManyCreatorInputEnvelope
    connect?: Enumerable<WorkoutPlanWhereUniqueInput>
  }

  export type WorkoutPlanCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<Enumerable<WorkoutPlanCreateWithoutAssignedToInput>, Enumerable<WorkoutPlanUncheckedCreateWithoutAssignedToInput>>
    connectOrCreate?: Enumerable<WorkoutPlanCreateOrConnectWithoutAssignedToInput>
    createMany?: WorkoutPlanCreateManyAssignedToInputEnvelope
    connect?: Enumerable<WorkoutPlanWhereUniqueInput>
  }

  export type WorkoutCreateNestedManyWithoutAthleteInput = {
    create?: XOR<Enumerable<WorkoutCreateWithoutAthleteInput>, Enumerable<WorkoutUncheckedCreateWithoutAthleteInput>>
    connectOrCreate?: Enumerable<WorkoutCreateOrConnectWithoutAthleteInput>
    createMany?: WorkoutCreateManyAthleteInputEnvelope
    connect?: Enumerable<WorkoutWhereUniqueInput>
  }

  export type WeightCreateNestedManyWithoutAthleteInput = {
    create?: XOR<Enumerable<WeightCreateWithoutAthleteInput>, Enumerable<WeightUncheckedCreateWithoutAthleteInput>>
    connectOrCreate?: Enumerable<WeightCreateOrConnectWithoutAthleteInput>
    createMany?: WeightCreateManyAthleteInputEnvelope
    connect?: Enumerable<WeightWhereUniqueInput>
  }

  export type AthleteCoachCreateNestedManyWithoutCoachInput = {
    create?: XOR<Enumerable<AthleteCoachCreateWithoutCoachInput>, Enumerable<AthleteCoachUncheckedCreateWithoutCoachInput>>
    connectOrCreate?: Enumerable<AthleteCoachCreateOrConnectWithoutCoachInput>
    createMany?: AthleteCoachCreateManyCoachInputEnvelope
    connect?: Enumerable<AthleteCoachWhereUniqueInput>
  }

  export type AthleteCoachCreateNestedManyWithoutAthleteInput = {
    create?: XOR<Enumerable<AthleteCoachCreateWithoutAthleteInput>, Enumerable<AthleteCoachUncheckedCreateWithoutAthleteInput>>
    connectOrCreate?: Enumerable<AthleteCoachCreateOrConnectWithoutAthleteInput>
    createMany?: AthleteCoachCreateManyAthleteInputEnvelope
    connect?: Enumerable<AthleteCoachWhereUniqueInput>
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<Enumerable<MessageCreateWithoutSenderInput>, Enumerable<MessageUncheckedCreateWithoutSenderInput>>
    connectOrCreate?: Enumerable<MessageCreateOrConnectWithoutSenderInput>
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: Enumerable<MessageWhereUniqueInput>
  }

  export type MessageCreateNestedManyWithoutReceiverInput = {
    create?: XOR<Enumerable<MessageCreateWithoutReceiverInput>, Enumerable<MessageUncheckedCreateWithoutReceiverInput>>
    connectOrCreate?: Enumerable<MessageCreateOrConnectWithoutReceiverInput>
    createMany?: MessageCreateManyReceiverInputEnvelope
    connect?: Enumerable<MessageWhereUniqueInput>
  }

  export type WorkoutSessionCreateNestedManyWithoutAthleteInput = {
    create?: XOR<Enumerable<WorkoutSessionCreateWithoutAthleteInput>, Enumerable<WorkoutSessionUncheckedCreateWithoutAthleteInput>>
    connectOrCreate?: Enumerable<WorkoutSessionCreateOrConnectWithoutAthleteInput>
    createMany?: WorkoutSessionCreateManyAthleteInputEnvelope
    connect?: Enumerable<WorkoutSessionWhereUniqueInput>
  }

  export type WorkoutPlanUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<Enumerable<WorkoutPlanCreateWithoutCreatorInput>, Enumerable<WorkoutPlanUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<WorkoutPlanCreateOrConnectWithoutCreatorInput>
    createMany?: WorkoutPlanCreateManyCreatorInputEnvelope
    connect?: Enumerable<WorkoutPlanWhereUniqueInput>
  }

  export type WorkoutPlanUncheckedCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<Enumerable<WorkoutPlanCreateWithoutAssignedToInput>, Enumerable<WorkoutPlanUncheckedCreateWithoutAssignedToInput>>
    connectOrCreate?: Enumerable<WorkoutPlanCreateOrConnectWithoutAssignedToInput>
    createMany?: WorkoutPlanCreateManyAssignedToInputEnvelope
    connect?: Enumerable<WorkoutPlanWhereUniqueInput>
  }

  export type WorkoutUncheckedCreateNestedManyWithoutAthleteInput = {
    create?: XOR<Enumerable<WorkoutCreateWithoutAthleteInput>, Enumerable<WorkoutUncheckedCreateWithoutAthleteInput>>
    connectOrCreate?: Enumerable<WorkoutCreateOrConnectWithoutAthleteInput>
    createMany?: WorkoutCreateManyAthleteInputEnvelope
    connect?: Enumerable<WorkoutWhereUniqueInput>
  }

  export type WeightUncheckedCreateNestedManyWithoutAthleteInput = {
    create?: XOR<Enumerable<WeightCreateWithoutAthleteInput>, Enumerable<WeightUncheckedCreateWithoutAthleteInput>>
    connectOrCreate?: Enumerable<WeightCreateOrConnectWithoutAthleteInput>
    createMany?: WeightCreateManyAthleteInputEnvelope
    connect?: Enumerable<WeightWhereUniqueInput>
  }

  export type AthleteCoachUncheckedCreateNestedManyWithoutCoachInput = {
    create?: XOR<Enumerable<AthleteCoachCreateWithoutCoachInput>, Enumerable<AthleteCoachUncheckedCreateWithoutCoachInput>>
    connectOrCreate?: Enumerable<AthleteCoachCreateOrConnectWithoutCoachInput>
    createMany?: AthleteCoachCreateManyCoachInputEnvelope
    connect?: Enumerable<AthleteCoachWhereUniqueInput>
  }

  export type AthleteCoachUncheckedCreateNestedManyWithoutAthleteInput = {
    create?: XOR<Enumerable<AthleteCoachCreateWithoutAthleteInput>, Enumerable<AthleteCoachUncheckedCreateWithoutAthleteInput>>
    connectOrCreate?: Enumerable<AthleteCoachCreateOrConnectWithoutAthleteInput>
    createMany?: AthleteCoachCreateManyAthleteInputEnvelope
    connect?: Enumerable<AthleteCoachWhereUniqueInput>
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<Enumerable<MessageCreateWithoutSenderInput>, Enumerable<MessageUncheckedCreateWithoutSenderInput>>
    connectOrCreate?: Enumerable<MessageCreateOrConnectWithoutSenderInput>
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: Enumerable<MessageWhereUniqueInput>
  }

  export type MessageUncheckedCreateNestedManyWithoutReceiverInput = {
    create?: XOR<Enumerable<MessageCreateWithoutReceiverInput>, Enumerable<MessageUncheckedCreateWithoutReceiverInput>>
    connectOrCreate?: Enumerable<MessageCreateOrConnectWithoutReceiverInput>
    createMany?: MessageCreateManyReceiverInputEnvelope
    connect?: Enumerable<MessageWhereUniqueInput>
  }

  export type WorkoutSessionUncheckedCreateNestedManyWithoutAthleteInput = {
    create?: XOR<Enumerable<WorkoutSessionCreateWithoutAthleteInput>, Enumerable<WorkoutSessionUncheckedCreateWithoutAthleteInput>>
    connectOrCreate?: Enumerable<WorkoutSessionCreateOrConnectWithoutAthleteInput>
    createMany?: WorkoutSessionCreateManyAthleteInputEnvelope
    connect?: Enumerable<WorkoutSessionWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: Role
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type WorkoutPlanUpdateManyWithoutCreatorInput = {
    create?: XOR<Enumerable<WorkoutPlanCreateWithoutCreatorInput>, Enumerable<WorkoutPlanUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<WorkoutPlanCreateOrConnectWithoutCreatorInput>
    upsert?: Enumerable<WorkoutPlanUpsertWithWhereUniqueWithoutCreatorInput>
    createMany?: WorkoutPlanCreateManyCreatorInputEnvelope
    set?: Enumerable<WorkoutPlanWhereUniqueInput>
    disconnect?: Enumerable<WorkoutPlanWhereUniqueInput>
    delete?: Enumerable<WorkoutPlanWhereUniqueInput>
    connect?: Enumerable<WorkoutPlanWhereUniqueInput>
    update?: Enumerable<WorkoutPlanUpdateWithWhereUniqueWithoutCreatorInput>
    updateMany?: Enumerable<WorkoutPlanUpdateManyWithWhereWithoutCreatorInput>
    deleteMany?: Enumerable<WorkoutPlanScalarWhereInput>
  }

  export type WorkoutPlanUpdateManyWithoutAssignedToInput = {
    create?: XOR<Enumerable<WorkoutPlanCreateWithoutAssignedToInput>, Enumerable<WorkoutPlanUncheckedCreateWithoutAssignedToInput>>
    connectOrCreate?: Enumerable<WorkoutPlanCreateOrConnectWithoutAssignedToInput>
    upsert?: Enumerable<WorkoutPlanUpsertWithWhereUniqueWithoutAssignedToInput>
    createMany?: WorkoutPlanCreateManyAssignedToInputEnvelope
    set?: Enumerable<WorkoutPlanWhereUniqueInput>
    disconnect?: Enumerable<WorkoutPlanWhereUniqueInput>
    delete?: Enumerable<WorkoutPlanWhereUniqueInput>
    connect?: Enumerable<WorkoutPlanWhereUniqueInput>
    update?: Enumerable<WorkoutPlanUpdateWithWhereUniqueWithoutAssignedToInput>
    updateMany?: Enumerable<WorkoutPlanUpdateManyWithWhereWithoutAssignedToInput>
    deleteMany?: Enumerable<WorkoutPlanScalarWhereInput>
  }

  export type WorkoutUpdateManyWithoutAthleteInput = {
    create?: XOR<Enumerable<WorkoutCreateWithoutAthleteInput>, Enumerable<WorkoutUncheckedCreateWithoutAthleteInput>>
    connectOrCreate?: Enumerable<WorkoutCreateOrConnectWithoutAthleteInput>
    upsert?: Enumerable<WorkoutUpsertWithWhereUniqueWithoutAthleteInput>
    createMany?: WorkoutCreateManyAthleteInputEnvelope
    set?: Enumerable<WorkoutWhereUniqueInput>
    disconnect?: Enumerable<WorkoutWhereUniqueInput>
    delete?: Enumerable<WorkoutWhereUniqueInput>
    connect?: Enumerable<WorkoutWhereUniqueInput>
    update?: Enumerable<WorkoutUpdateWithWhereUniqueWithoutAthleteInput>
    updateMany?: Enumerable<WorkoutUpdateManyWithWhereWithoutAthleteInput>
    deleteMany?: Enumerable<WorkoutScalarWhereInput>
  }

  export type WeightUpdateManyWithoutAthleteInput = {
    create?: XOR<Enumerable<WeightCreateWithoutAthleteInput>, Enumerable<WeightUncheckedCreateWithoutAthleteInput>>
    connectOrCreate?: Enumerable<WeightCreateOrConnectWithoutAthleteInput>
    upsert?: Enumerable<WeightUpsertWithWhereUniqueWithoutAthleteInput>
    createMany?: WeightCreateManyAthleteInputEnvelope
    set?: Enumerable<WeightWhereUniqueInput>
    disconnect?: Enumerable<WeightWhereUniqueInput>
    delete?: Enumerable<WeightWhereUniqueInput>
    connect?: Enumerable<WeightWhereUniqueInput>
    update?: Enumerable<WeightUpdateWithWhereUniqueWithoutAthleteInput>
    updateMany?: Enumerable<WeightUpdateManyWithWhereWithoutAthleteInput>
    deleteMany?: Enumerable<WeightScalarWhereInput>
  }

  export type AthleteCoachUpdateManyWithoutCoachInput = {
    create?: XOR<Enumerable<AthleteCoachCreateWithoutCoachInput>, Enumerable<AthleteCoachUncheckedCreateWithoutCoachInput>>
    connectOrCreate?: Enumerable<AthleteCoachCreateOrConnectWithoutCoachInput>
    upsert?: Enumerable<AthleteCoachUpsertWithWhereUniqueWithoutCoachInput>
    createMany?: AthleteCoachCreateManyCoachInputEnvelope
    set?: Enumerable<AthleteCoachWhereUniqueInput>
    disconnect?: Enumerable<AthleteCoachWhereUniqueInput>
    delete?: Enumerable<AthleteCoachWhereUniqueInput>
    connect?: Enumerable<AthleteCoachWhereUniqueInput>
    update?: Enumerable<AthleteCoachUpdateWithWhereUniqueWithoutCoachInput>
    updateMany?: Enumerable<AthleteCoachUpdateManyWithWhereWithoutCoachInput>
    deleteMany?: Enumerable<AthleteCoachScalarWhereInput>
  }

  export type AthleteCoachUpdateManyWithoutAthleteInput = {
    create?: XOR<Enumerable<AthleteCoachCreateWithoutAthleteInput>, Enumerable<AthleteCoachUncheckedCreateWithoutAthleteInput>>
    connectOrCreate?: Enumerable<AthleteCoachCreateOrConnectWithoutAthleteInput>
    upsert?: Enumerable<AthleteCoachUpsertWithWhereUniqueWithoutAthleteInput>
    createMany?: AthleteCoachCreateManyAthleteInputEnvelope
    set?: Enumerable<AthleteCoachWhereUniqueInput>
    disconnect?: Enumerable<AthleteCoachWhereUniqueInput>
    delete?: Enumerable<AthleteCoachWhereUniqueInput>
    connect?: Enumerable<AthleteCoachWhereUniqueInput>
    update?: Enumerable<AthleteCoachUpdateWithWhereUniqueWithoutAthleteInput>
    updateMany?: Enumerable<AthleteCoachUpdateManyWithWhereWithoutAthleteInput>
    deleteMany?: Enumerable<AthleteCoachScalarWhereInput>
  }

  export type MessageUpdateManyWithoutSenderInput = {
    create?: XOR<Enumerable<MessageCreateWithoutSenderInput>, Enumerable<MessageUncheckedCreateWithoutSenderInput>>
    connectOrCreate?: Enumerable<MessageCreateOrConnectWithoutSenderInput>
    upsert?: Enumerable<MessageUpsertWithWhereUniqueWithoutSenderInput>
    createMany?: MessageCreateManySenderInputEnvelope
    set?: Enumerable<MessageWhereUniqueInput>
    disconnect?: Enumerable<MessageWhereUniqueInput>
    delete?: Enumerable<MessageWhereUniqueInput>
    connect?: Enumerable<MessageWhereUniqueInput>
    update?: Enumerable<MessageUpdateWithWhereUniqueWithoutSenderInput>
    updateMany?: Enumerable<MessageUpdateManyWithWhereWithoutSenderInput>
    deleteMany?: Enumerable<MessageScalarWhereInput>
  }

  export type MessageUpdateManyWithoutReceiverInput = {
    create?: XOR<Enumerable<MessageCreateWithoutReceiverInput>, Enumerable<MessageUncheckedCreateWithoutReceiverInput>>
    connectOrCreate?: Enumerable<MessageCreateOrConnectWithoutReceiverInput>
    upsert?: Enumerable<MessageUpsertWithWhereUniqueWithoutReceiverInput>
    createMany?: MessageCreateManyReceiverInputEnvelope
    set?: Enumerable<MessageWhereUniqueInput>
    disconnect?: Enumerable<MessageWhereUniqueInput>
    delete?: Enumerable<MessageWhereUniqueInput>
    connect?: Enumerable<MessageWhereUniqueInput>
    update?: Enumerable<MessageUpdateWithWhereUniqueWithoutReceiverInput>
    updateMany?: Enumerable<MessageUpdateManyWithWhereWithoutReceiverInput>
    deleteMany?: Enumerable<MessageScalarWhereInput>
  }

  export type WorkoutSessionUpdateManyWithoutAthleteInput = {
    create?: XOR<Enumerable<WorkoutSessionCreateWithoutAthleteInput>, Enumerable<WorkoutSessionUncheckedCreateWithoutAthleteInput>>
    connectOrCreate?: Enumerable<WorkoutSessionCreateOrConnectWithoutAthleteInput>
    upsert?: Enumerable<WorkoutSessionUpsertWithWhereUniqueWithoutAthleteInput>
    createMany?: WorkoutSessionCreateManyAthleteInputEnvelope
    set?: Enumerable<WorkoutSessionWhereUniqueInput>
    disconnect?: Enumerable<WorkoutSessionWhereUniqueInput>
    delete?: Enumerable<WorkoutSessionWhereUniqueInput>
    connect?: Enumerable<WorkoutSessionWhereUniqueInput>
    update?: Enumerable<WorkoutSessionUpdateWithWhereUniqueWithoutAthleteInput>
    updateMany?: Enumerable<WorkoutSessionUpdateManyWithWhereWithoutAthleteInput>
    deleteMany?: Enumerable<WorkoutSessionScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type WorkoutPlanUncheckedUpdateManyWithoutCreatorInput = {
    create?: XOR<Enumerable<WorkoutPlanCreateWithoutCreatorInput>, Enumerable<WorkoutPlanUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<WorkoutPlanCreateOrConnectWithoutCreatorInput>
    upsert?: Enumerable<WorkoutPlanUpsertWithWhereUniqueWithoutCreatorInput>
    createMany?: WorkoutPlanCreateManyCreatorInputEnvelope
    set?: Enumerable<WorkoutPlanWhereUniqueInput>
    disconnect?: Enumerable<WorkoutPlanWhereUniqueInput>
    delete?: Enumerable<WorkoutPlanWhereUniqueInput>
    connect?: Enumerable<WorkoutPlanWhereUniqueInput>
    update?: Enumerable<WorkoutPlanUpdateWithWhereUniqueWithoutCreatorInput>
    updateMany?: Enumerable<WorkoutPlanUpdateManyWithWhereWithoutCreatorInput>
    deleteMany?: Enumerable<WorkoutPlanScalarWhereInput>
  }

  export type WorkoutPlanUncheckedUpdateManyWithoutAssignedToInput = {
    create?: XOR<Enumerable<WorkoutPlanCreateWithoutAssignedToInput>, Enumerable<WorkoutPlanUncheckedCreateWithoutAssignedToInput>>
    connectOrCreate?: Enumerable<WorkoutPlanCreateOrConnectWithoutAssignedToInput>
    upsert?: Enumerable<WorkoutPlanUpsertWithWhereUniqueWithoutAssignedToInput>
    createMany?: WorkoutPlanCreateManyAssignedToInputEnvelope
    set?: Enumerable<WorkoutPlanWhereUniqueInput>
    disconnect?: Enumerable<WorkoutPlanWhereUniqueInput>
    delete?: Enumerable<WorkoutPlanWhereUniqueInput>
    connect?: Enumerable<WorkoutPlanWhereUniqueInput>
    update?: Enumerable<WorkoutPlanUpdateWithWhereUniqueWithoutAssignedToInput>
    updateMany?: Enumerable<WorkoutPlanUpdateManyWithWhereWithoutAssignedToInput>
    deleteMany?: Enumerable<WorkoutPlanScalarWhereInput>
  }

  export type WorkoutUncheckedUpdateManyWithoutAthleteInput = {
    create?: XOR<Enumerable<WorkoutCreateWithoutAthleteInput>, Enumerable<WorkoutUncheckedCreateWithoutAthleteInput>>
    connectOrCreate?: Enumerable<WorkoutCreateOrConnectWithoutAthleteInput>
    upsert?: Enumerable<WorkoutUpsertWithWhereUniqueWithoutAthleteInput>
    createMany?: WorkoutCreateManyAthleteInputEnvelope
    set?: Enumerable<WorkoutWhereUniqueInput>
    disconnect?: Enumerable<WorkoutWhereUniqueInput>
    delete?: Enumerable<WorkoutWhereUniqueInput>
    connect?: Enumerable<WorkoutWhereUniqueInput>
    update?: Enumerable<WorkoutUpdateWithWhereUniqueWithoutAthleteInput>
    updateMany?: Enumerable<WorkoutUpdateManyWithWhereWithoutAthleteInput>
    deleteMany?: Enumerable<WorkoutScalarWhereInput>
  }

  export type WeightUncheckedUpdateManyWithoutAthleteInput = {
    create?: XOR<Enumerable<WeightCreateWithoutAthleteInput>, Enumerable<WeightUncheckedCreateWithoutAthleteInput>>
    connectOrCreate?: Enumerable<WeightCreateOrConnectWithoutAthleteInput>
    upsert?: Enumerable<WeightUpsertWithWhereUniqueWithoutAthleteInput>
    createMany?: WeightCreateManyAthleteInputEnvelope
    set?: Enumerable<WeightWhereUniqueInput>
    disconnect?: Enumerable<WeightWhereUniqueInput>
    delete?: Enumerable<WeightWhereUniqueInput>
    connect?: Enumerable<WeightWhereUniqueInput>
    update?: Enumerable<WeightUpdateWithWhereUniqueWithoutAthleteInput>
    updateMany?: Enumerable<WeightUpdateManyWithWhereWithoutAthleteInput>
    deleteMany?: Enumerable<WeightScalarWhereInput>
  }

  export type AthleteCoachUncheckedUpdateManyWithoutCoachInput = {
    create?: XOR<Enumerable<AthleteCoachCreateWithoutCoachInput>, Enumerable<AthleteCoachUncheckedCreateWithoutCoachInput>>
    connectOrCreate?: Enumerable<AthleteCoachCreateOrConnectWithoutCoachInput>
    upsert?: Enumerable<AthleteCoachUpsertWithWhereUniqueWithoutCoachInput>
    createMany?: AthleteCoachCreateManyCoachInputEnvelope
    set?: Enumerable<AthleteCoachWhereUniqueInput>
    disconnect?: Enumerable<AthleteCoachWhereUniqueInput>
    delete?: Enumerable<AthleteCoachWhereUniqueInput>
    connect?: Enumerable<AthleteCoachWhereUniqueInput>
    update?: Enumerable<AthleteCoachUpdateWithWhereUniqueWithoutCoachInput>
    updateMany?: Enumerable<AthleteCoachUpdateManyWithWhereWithoutCoachInput>
    deleteMany?: Enumerable<AthleteCoachScalarWhereInput>
  }

  export type AthleteCoachUncheckedUpdateManyWithoutAthleteInput = {
    create?: XOR<Enumerable<AthleteCoachCreateWithoutAthleteInput>, Enumerable<AthleteCoachUncheckedCreateWithoutAthleteInput>>
    connectOrCreate?: Enumerable<AthleteCoachCreateOrConnectWithoutAthleteInput>
    upsert?: Enumerable<AthleteCoachUpsertWithWhereUniqueWithoutAthleteInput>
    createMany?: AthleteCoachCreateManyAthleteInputEnvelope
    set?: Enumerable<AthleteCoachWhereUniqueInput>
    disconnect?: Enumerable<AthleteCoachWhereUniqueInput>
    delete?: Enumerable<AthleteCoachWhereUniqueInput>
    connect?: Enumerable<AthleteCoachWhereUniqueInput>
    update?: Enumerable<AthleteCoachUpdateWithWhereUniqueWithoutAthleteInput>
    updateMany?: Enumerable<AthleteCoachUpdateManyWithWhereWithoutAthleteInput>
    deleteMany?: Enumerable<AthleteCoachScalarWhereInput>
  }

  export type MessageUncheckedUpdateManyWithoutSenderInput = {
    create?: XOR<Enumerable<MessageCreateWithoutSenderInput>, Enumerable<MessageUncheckedCreateWithoutSenderInput>>
    connectOrCreate?: Enumerable<MessageCreateOrConnectWithoutSenderInput>
    upsert?: Enumerable<MessageUpsertWithWhereUniqueWithoutSenderInput>
    createMany?: MessageCreateManySenderInputEnvelope
    set?: Enumerable<MessageWhereUniqueInput>
    disconnect?: Enumerable<MessageWhereUniqueInput>
    delete?: Enumerable<MessageWhereUniqueInput>
    connect?: Enumerable<MessageWhereUniqueInput>
    update?: Enumerable<MessageUpdateWithWhereUniqueWithoutSenderInput>
    updateMany?: Enumerable<MessageUpdateManyWithWhereWithoutSenderInput>
    deleteMany?: Enumerable<MessageScalarWhereInput>
  }

  export type MessageUncheckedUpdateManyWithoutReceiverInput = {
    create?: XOR<Enumerable<MessageCreateWithoutReceiverInput>, Enumerable<MessageUncheckedCreateWithoutReceiverInput>>
    connectOrCreate?: Enumerable<MessageCreateOrConnectWithoutReceiverInput>
    upsert?: Enumerable<MessageUpsertWithWhereUniqueWithoutReceiverInput>
    createMany?: MessageCreateManyReceiverInputEnvelope
    set?: Enumerable<MessageWhereUniqueInput>
    disconnect?: Enumerable<MessageWhereUniqueInput>
    delete?: Enumerable<MessageWhereUniqueInput>
    connect?: Enumerable<MessageWhereUniqueInput>
    update?: Enumerable<MessageUpdateWithWhereUniqueWithoutReceiverInput>
    updateMany?: Enumerable<MessageUpdateManyWithWhereWithoutReceiverInput>
    deleteMany?: Enumerable<MessageScalarWhereInput>
  }

  export type WorkoutSessionUncheckedUpdateManyWithoutAthleteInput = {
    create?: XOR<Enumerable<WorkoutSessionCreateWithoutAthleteInput>, Enumerable<WorkoutSessionUncheckedCreateWithoutAthleteInput>>
    connectOrCreate?: Enumerable<WorkoutSessionCreateOrConnectWithoutAthleteInput>
    upsert?: Enumerable<WorkoutSessionUpsertWithWhereUniqueWithoutAthleteInput>
    createMany?: WorkoutSessionCreateManyAthleteInputEnvelope
    set?: Enumerable<WorkoutSessionWhereUniqueInput>
    disconnect?: Enumerable<WorkoutSessionWhereUniqueInput>
    delete?: Enumerable<WorkoutSessionWhereUniqueInput>
    connect?: Enumerable<WorkoutSessionWhereUniqueInput>
    update?: Enumerable<WorkoutSessionUpdateWithWhereUniqueWithoutAthleteInput>
    updateMany?: Enumerable<WorkoutSessionUpdateManyWithWhereWithoutAthleteInput>
    deleteMany?: Enumerable<WorkoutSessionScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutCoachLinksInput = {
    create?: XOR<UserCreateWithoutCoachLinksInput, UserUncheckedCreateWithoutCoachLinksInput>
    connectOrCreate?: UserCreateOrConnectWithoutCoachLinksInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAthleteLinksInput = {
    create?: XOR<UserCreateWithoutAthleteLinksInput, UserUncheckedCreateWithoutAthleteLinksInput>
    connectOrCreate?: UserCreateOrConnectWithoutAthleteLinksInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCoachLinksInput = {
    create?: XOR<UserCreateWithoutCoachLinksInput, UserUncheckedCreateWithoutCoachLinksInput>
    connectOrCreate?: UserCreateOrConnectWithoutCoachLinksInput
    upsert?: UserUpsertWithoutCoachLinksInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCoachLinksInput, UserUncheckedUpdateWithoutCoachLinksInput>
  }

  export type UserUpdateOneRequiredWithoutAthleteLinksInput = {
    create?: XOR<UserCreateWithoutAthleteLinksInput, UserUncheckedCreateWithoutAthleteLinksInput>
    connectOrCreate?: UserCreateOrConnectWithoutAthleteLinksInput
    upsert?: UserUpsertWithoutAthleteLinksInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAthleteLinksInput, UserUncheckedUpdateWithoutAthleteLinksInput>
  }

  export type UserCreateNestedOneWithoutCreatedWorkoutPlansInput = {
    create?: XOR<UserCreateWithoutCreatedWorkoutPlansInput, UserUncheckedCreateWithoutCreatedWorkoutPlansInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedWorkoutPlansInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssignedWorkoutPlansInput = {
    create?: XOR<UserCreateWithoutAssignedWorkoutPlansInput, UserUncheckedCreateWithoutAssignedWorkoutPlansInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedWorkoutPlansInput
    connect?: UserWhereUniqueInput
  }

  export type WorkoutPlanExerciseCreateNestedManyWithoutPlanInput = {
    create?: XOR<Enumerable<WorkoutPlanExerciseCreateWithoutPlanInput>, Enumerable<WorkoutPlanExerciseUncheckedCreateWithoutPlanInput>>
    connectOrCreate?: Enumerable<WorkoutPlanExerciseCreateOrConnectWithoutPlanInput>
    createMany?: WorkoutPlanExerciseCreateManyPlanInputEnvelope
    connect?: Enumerable<WorkoutPlanExerciseWhereUniqueInput>
  }

  export type WorkoutSessionCreateNestedManyWithoutPlanInput = {
    create?: XOR<Enumerable<WorkoutSessionCreateWithoutPlanInput>, Enumerable<WorkoutSessionUncheckedCreateWithoutPlanInput>>
    connectOrCreate?: Enumerable<WorkoutSessionCreateOrConnectWithoutPlanInput>
    createMany?: WorkoutSessionCreateManyPlanInputEnvelope
    connect?: Enumerable<WorkoutSessionWhereUniqueInput>
  }

  export type WorkoutCreateNestedManyWithoutWorkoutPlanInput = {
    create?: XOR<Enumerable<WorkoutCreateWithoutWorkoutPlanInput>, Enumerable<WorkoutUncheckedCreateWithoutWorkoutPlanInput>>
    connectOrCreate?: Enumerable<WorkoutCreateOrConnectWithoutWorkoutPlanInput>
    createMany?: WorkoutCreateManyWorkoutPlanInputEnvelope
    connect?: Enumerable<WorkoutWhereUniqueInput>
  }

  export type WorkoutPlanExerciseUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<Enumerable<WorkoutPlanExerciseCreateWithoutPlanInput>, Enumerable<WorkoutPlanExerciseUncheckedCreateWithoutPlanInput>>
    connectOrCreate?: Enumerable<WorkoutPlanExerciseCreateOrConnectWithoutPlanInput>
    createMany?: WorkoutPlanExerciseCreateManyPlanInputEnvelope
    connect?: Enumerable<WorkoutPlanExerciseWhereUniqueInput>
  }

  export type WorkoutSessionUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<Enumerable<WorkoutSessionCreateWithoutPlanInput>, Enumerable<WorkoutSessionUncheckedCreateWithoutPlanInput>>
    connectOrCreate?: Enumerable<WorkoutSessionCreateOrConnectWithoutPlanInput>
    createMany?: WorkoutSessionCreateManyPlanInputEnvelope
    connect?: Enumerable<WorkoutSessionWhereUniqueInput>
  }

  export type WorkoutUncheckedCreateNestedManyWithoutWorkoutPlanInput = {
    create?: XOR<Enumerable<WorkoutCreateWithoutWorkoutPlanInput>, Enumerable<WorkoutUncheckedCreateWithoutWorkoutPlanInput>>
    connectOrCreate?: Enumerable<WorkoutCreateOrConnectWithoutWorkoutPlanInput>
    createMany?: WorkoutCreateManyWorkoutPlanInputEnvelope
    connect?: Enumerable<WorkoutWhereUniqueInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UserUpdateOneRequiredWithoutCreatedWorkoutPlansInput = {
    create?: XOR<UserCreateWithoutCreatedWorkoutPlansInput, UserUncheckedCreateWithoutCreatedWorkoutPlansInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedWorkoutPlansInput
    upsert?: UserUpsertWithoutCreatedWorkoutPlansInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCreatedWorkoutPlansInput, UserUncheckedUpdateWithoutCreatedWorkoutPlansInput>
  }

  export type UserUpdateOneWithoutAssignedWorkoutPlansInput = {
    create?: XOR<UserCreateWithoutAssignedWorkoutPlansInput, UserUncheckedCreateWithoutAssignedWorkoutPlansInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedWorkoutPlansInput
    upsert?: UserUpsertWithoutAssignedWorkoutPlansInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAssignedWorkoutPlansInput, UserUncheckedUpdateWithoutAssignedWorkoutPlansInput>
  }

  export type WorkoutPlanExerciseUpdateManyWithoutPlanInput = {
    create?: XOR<Enumerable<WorkoutPlanExerciseCreateWithoutPlanInput>, Enumerable<WorkoutPlanExerciseUncheckedCreateWithoutPlanInput>>
    connectOrCreate?: Enumerable<WorkoutPlanExerciseCreateOrConnectWithoutPlanInput>
    upsert?: Enumerable<WorkoutPlanExerciseUpsertWithWhereUniqueWithoutPlanInput>
    createMany?: WorkoutPlanExerciseCreateManyPlanInputEnvelope
    set?: Enumerable<WorkoutPlanExerciseWhereUniqueInput>
    disconnect?: Enumerable<WorkoutPlanExerciseWhereUniqueInput>
    delete?: Enumerable<WorkoutPlanExerciseWhereUniqueInput>
    connect?: Enumerable<WorkoutPlanExerciseWhereUniqueInput>
    update?: Enumerable<WorkoutPlanExerciseUpdateWithWhereUniqueWithoutPlanInput>
    updateMany?: Enumerable<WorkoutPlanExerciseUpdateManyWithWhereWithoutPlanInput>
    deleteMany?: Enumerable<WorkoutPlanExerciseScalarWhereInput>
  }

  export type WorkoutSessionUpdateManyWithoutPlanInput = {
    create?: XOR<Enumerable<WorkoutSessionCreateWithoutPlanInput>, Enumerable<WorkoutSessionUncheckedCreateWithoutPlanInput>>
    connectOrCreate?: Enumerable<WorkoutSessionCreateOrConnectWithoutPlanInput>
    upsert?: Enumerable<WorkoutSessionUpsertWithWhereUniqueWithoutPlanInput>
    createMany?: WorkoutSessionCreateManyPlanInputEnvelope
    set?: Enumerable<WorkoutSessionWhereUniqueInput>
    disconnect?: Enumerable<WorkoutSessionWhereUniqueInput>
    delete?: Enumerable<WorkoutSessionWhereUniqueInput>
    connect?: Enumerable<WorkoutSessionWhereUniqueInput>
    update?: Enumerable<WorkoutSessionUpdateWithWhereUniqueWithoutPlanInput>
    updateMany?: Enumerable<WorkoutSessionUpdateManyWithWhereWithoutPlanInput>
    deleteMany?: Enumerable<WorkoutSessionScalarWhereInput>
  }

  export type WorkoutUpdateManyWithoutWorkoutPlanInput = {
    create?: XOR<Enumerable<WorkoutCreateWithoutWorkoutPlanInput>, Enumerable<WorkoutUncheckedCreateWithoutWorkoutPlanInput>>
    connectOrCreate?: Enumerable<WorkoutCreateOrConnectWithoutWorkoutPlanInput>
    upsert?: Enumerable<WorkoutUpsertWithWhereUniqueWithoutWorkoutPlanInput>
    createMany?: WorkoutCreateManyWorkoutPlanInputEnvelope
    set?: Enumerable<WorkoutWhereUniqueInput>
    disconnect?: Enumerable<WorkoutWhereUniqueInput>
    delete?: Enumerable<WorkoutWhereUniqueInput>
    connect?: Enumerable<WorkoutWhereUniqueInput>
    update?: Enumerable<WorkoutUpdateWithWhereUniqueWithoutWorkoutPlanInput>
    updateMany?: Enumerable<WorkoutUpdateManyWithWhereWithoutWorkoutPlanInput>
    deleteMany?: Enumerable<WorkoutScalarWhereInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type WorkoutPlanExerciseUncheckedUpdateManyWithoutPlanInput = {
    create?: XOR<Enumerable<WorkoutPlanExerciseCreateWithoutPlanInput>, Enumerable<WorkoutPlanExerciseUncheckedCreateWithoutPlanInput>>
    connectOrCreate?: Enumerable<WorkoutPlanExerciseCreateOrConnectWithoutPlanInput>
    upsert?: Enumerable<WorkoutPlanExerciseUpsertWithWhereUniqueWithoutPlanInput>
    createMany?: WorkoutPlanExerciseCreateManyPlanInputEnvelope
    set?: Enumerable<WorkoutPlanExerciseWhereUniqueInput>
    disconnect?: Enumerable<WorkoutPlanExerciseWhereUniqueInput>
    delete?: Enumerable<WorkoutPlanExerciseWhereUniqueInput>
    connect?: Enumerable<WorkoutPlanExerciseWhereUniqueInput>
    update?: Enumerable<WorkoutPlanExerciseUpdateWithWhereUniqueWithoutPlanInput>
    updateMany?: Enumerable<WorkoutPlanExerciseUpdateManyWithWhereWithoutPlanInput>
    deleteMany?: Enumerable<WorkoutPlanExerciseScalarWhereInput>
  }

  export type WorkoutSessionUncheckedUpdateManyWithoutPlanInput = {
    create?: XOR<Enumerable<WorkoutSessionCreateWithoutPlanInput>, Enumerable<WorkoutSessionUncheckedCreateWithoutPlanInput>>
    connectOrCreate?: Enumerable<WorkoutSessionCreateOrConnectWithoutPlanInput>
    upsert?: Enumerable<WorkoutSessionUpsertWithWhereUniqueWithoutPlanInput>
    createMany?: WorkoutSessionCreateManyPlanInputEnvelope
    set?: Enumerable<WorkoutSessionWhereUniqueInput>
    disconnect?: Enumerable<WorkoutSessionWhereUniqueInput>
    delete?: Enumerable<WorkoutSessionWhereUniqueInput>
    connect?: Enumerable<WorkoutSessionWhereUniqueInput>
    update?: Enumerable<WorkoutSessionUpdateWithWhereUniqueWithoutPlanInput>
    updateMany?: Enumerable<WorkoutSessionUpdateManyWithWhereWithoutPlanInput>
    deleteMany?: Enumerable<WorkoutSessionScalarWhereInput>
  }

  export type WorkoutUncheckedUpdateManyWithoutWorkoutPlanInput = {
    create?: XOR<Enumerable<WorkoutCreateWithoutWorkoutPlanInput>, Enumerable<WorkoutUncheckedCreateWithoutWorkoutPlanInput>>
    connectOrCreate?: Enumerable<WorkoutCreateOrConnectWithoutWorkoutPlanInput>
    upsert?: Enumerable<WorkoutUpsertWithWhereUniqueWithoutWorkoutPlanInput>
    createMany?: WorkoutCreateManyWorkoutPlanInputEnvelope
    set?: Enumerable<WorkoutWhereUniqueInput>
    disconnect?: Enumerable<WorkoutWhereUniqueInput>
    delete?: Enumerable<WorkoutWhereUniqueInput>
    connect?: Enumerable<WorkoutWhereUniqueInput>
    update?: Enumerable<WorkoutUpdateWithWhereUniqueWithoutWorkoutPlanInput>
    updateMany?: Enumerable<WorkoutUpdateManyWithWhereWithoutWorkoutPlanInput>
    deleteMany?: Enumerable<WorkoutScalarWhereInput>
  }

  export type WorkoutExerciseCreateNestedManyWithoutExerciseInput = {
    create?: XOR<Enumerable<WorkoutExerciseCreateWithoutExerciseInput>, Enumerable<WorkoutExerciseUncheckedCreateWithoutExerciseInput>>
    connectOrCreate?: Enumerable<WorkoutExerciseCreateOrConnectWithoutExerciseInput>
    createMany?: WorkoutExerciseCreateManyExerciseInputEnvelope
    connect?: Enumerable<WorkoutExerciseWhereUniqueInput>
  }

  export type WorkoutPlanExerciseCreateNestedManyWithoutExerciseInput = {
    create?: XOR<Enumerable<WorkoutPlanExerciseCreateWithoutExerciseInput>, Enumerable<WorkoutPlanExerciseUncheckedCreateWithoutExerciseInput>>
    connectOrCreate?: Enumerable<WorkoutPlanExerciseCreateOrConnectWithoutExerciseInput>
    createMany?: WorkoutPlanExerciseCreateManyExerciseInputEnvelope
    connect?: Enumerable<WorkoutPlanExerciseWhereUniqueInput>
  }

  export type WorkoutSessionExerciseCreateNestedManyWithoutExerciseInput = {
    create?: XOR<Enumerable<WorkoutSessionExerciseCreateWithoutExerciseInput>, Enumerable<WorkoutSessionExerciseUncheckedCreateWithoutExerciseInput>>
    connectOrCreate?: Enumerable<WorkoutSessionExerciseCreateOrConnectWithoutExerciseInput>
    createMany?: WorkoutSessionExerciseCreateManyExerciseInputEnvelope
    connect?: Enumerable<WorkoutSessionExerciseWhereUniqueInput>
  }

  export type WorkoutExerciseUncheckedCreateNestedManyWithoutExerciseInput = {
    create?: XOR<Enumerable<WorkoutExerciseCreateWithoutExerciseInput>, Enumerable<WorkoutExerciseUncheckedCreateWithoutExerciseInput>>
    connectOrCreate?: Enumerable<WorkoutExerciseCreateOrConnectWithoutExerciseInput>
    createMany?: WorkoutExerciseCreateManyExerciseInputEnvelope
    connect?: Enumerable<WorkoutExerciseWhereUniqueInput>
  }

  export type WorkoutPlanExerciseUncheckedCreateNestedManyWithoutExerciseInput = {
    create?: XOR<Enumerable<WorkoutPlanExerciseCreateWithoutExerciseInput>, Enumerable<WorkoutPlanExerciseUncheckedCreateWithoutExerciseInput>>
    connectOrCreate?: Enumerable<WorkoutPlanExerciseCreateOrConnectWithoutExerciseInput>
    createMany?: WorkoutPlanExerciseCreateManyExerciseInputEnvelope
    connect?: Enumerable<WorkoutPlanExerciseWhereUniqueInput>
  }

  export type WorkoutSessionExerciseUncheckedCreateNestedManyWithoutExerciseInput = {
    create?: XOR<Enumerable<WorkoutSessionExerciseCreateWithoutExerciseInput>, Enumerable<WorkoutSessionExerciseUncheckedCreateWithoutExerciseInput>>
    connectOrCreate?: Enumerable<WorkoutSessionExerciseCreateOrConnectWithoutExerciseInput>
    createMany?: WorkoutSessionExerciseCreateManyExerciseInputEnvelope
    connect?: Enumerable<WorkoutSessionExerciseWhereUniqueInput>
  }

  export type WorkoutExerciseUpdateManyWithoutExerciseInput = {
    create?: XOR<Enumerable<WorkoutExerciseCreateWithoutExerciseInput>, Enumerable<WorkoutExerciseUncheckedCreateWithoutExerciseInput>>
    connectOrCreate?: Enumerable<WorkoutExerciseCreateOrConnectWithoutExerciseInput>
    upsert?: Enumerable<WorkoutExerciseUpsertWithWhereUniqueWithoutExerciseInput>
    createMany?: WorkoutExerciseCreateManyExerciseInputEnvelope
    set?: Enumerable<WorkoutExerciseWhereUniqueInput>
    disconnect?: Enumerable<WorkoutExerciseWhereUniqueInput>
    delete?: Enumerable<WorkoutExerciseWhereUniqueInput>
    connect?: Enumerable<WorkoutExerciseWhereUniqueInput>
    update?: Enumerable<WorkoutExerciseUpdateWithWhereUniqueWithoutExerciseInput>
    updateMany?: Enumerable<WorkoutExerciseUpdateManyWithWhereWithoutExerciseInput>
    deleteMany?: Enumerable<WorkoutExerciseScalarWhereInput>
  }

  export type WorkoutPlanExerciseUpdateManyWithoutExerciseInput = {
    create?: XOR<Enumerable<WorkoutPlanExerciseCreateWithoutExerciseInput>, Enumerable<WorkoutPlanExerciseUncheckedCreateWithoutExerciseInput>>
    connectOrCreate?: Enumerable<WorkoutPlanExerciseCreateOrConnectWithoutExerciseInput>
    upsert?: Enumerable<WorkoutPlanExerciseUpsertWithWhereUniqueWithoutExerciseInput>
    createMany?: WorkoutPlanExerciseCreateManyExerciseInputEnvelope
    set?: Enumerable<WorkoutPlanExerciseWhereUniqueInput>
    disconnect?: Enumerable<WorkoutPlanExerciseWhereUniqueInput>
    delete?: Enumerable<WorkoutPlanExerciseWhereUniqueInput>
    connect?: Enumerable<WorkoutPlanExerciseWhereUniqueInput>
    update?: Enumerable<WorkoutPlanExerciseUpdateWithWhereUniqueWithoutExerciseInput>
    updateMany?: Enumerable<WorkoutPlanExerciseUpdateManyWithWhereWithoutExerciseInput>
    deleteMany?: Enumerable<WorkoutPlanExerciseScalarWhereInput>
  }

  export type WorkoutSessionExerciseUpdateManyWithoutExerciseInput = {
    create?: XOR<Enumerable<WorkoutSessionExerciseCreateWithoutExerciseInput>, Enumerable<WorkoutSessionExerciseUncheckedCreateWithoutExerciseInput>>
    connectOrCreate?: Enumerable<WorkoutSessionExerciseCreateOrConnectWithoutExerciseInput>
    upsert?: Enumerable<WorkoutSessionExerciseUpsertWithWhereUniqueWithoutExerciseInput>
    createMany?: WorkoutSessionExerciseCreateManyExerciseInputEnvelope
    set?: Enumerable<WorkoutSessionExerciseWhereUniqueInput>
    disconnect?: Enumerable<WorkoutSessionExerciseWhereUniqueInput>
    delete?: Enumerable<WorkoutSessionExerciseWhereUniqueInput>
    connect?: Enumerable<WorkoutSessionExerciseWhereUniqueInput>
    update?: Enumerable<WorkoutSessionExerciseUpdateWithWhereUniqueWithoutExerciseInput>
    updateMany?: Enumerable<WorkoutSessionExerciseUpdateManyWithWhereWithoutExerciseInput>
    deleteMany?: Enumerable<WorkoutSessionExerciseScalarWhereInput>
  }

  export type WorkoutExerciseUncheckedUpdateManyWithoutExerciseInput = {
    create?: XOR<Enumerable<WorkoutExerciseCreateWithoutExerciseInput>, Enumerable<WorkoutExerciseUncheckedCreateWithoutExerciseInput>>
    connectOrCreate?: Enumerable<WorkoutExerciseCreateOrConnectWithoutExerciseInput>
    upsert?: Enumerable<WorkoutExerciseUpsertWithWhereUniqueWithoutExerciseInput>
    createMany?: WorkoutExerciseCreateManyExerciseInputEnvelope
    set?: Enumerable<WorkoutExerciseWhereUniqueInput>
    disconnect?: Enumerable<WorkoutExerciseWhereUniqueInput>
    delete?: Enumerable<WorkoutExerciseWhereUniqueInput>
    connect?: Enumerable<WorkoutExerciseWhereUniqueInput>
    update?: Enumerable<WorkoutExerciseUpdateWithWhereUniqueWithoutExerciseInput>
    updateMany?: Enumerable<WorkoutExerciseUpdateManyWithWhereWithoutExerciseInput>
    deleteMany?: Enumerable<WorkoutExerciseScalarWhereInput>
  }

  export type WorkoutPlanExerciseUncheckedUpdateManyWithoutExerciseInput = {
    create?: XOR<Enumerable<WorkoutPlanExerciseCreateWithoutExerciseInput>, Enumerable<WorkoutPlanExerciseUncheckedCreateWithoutExerciseInput>>
    connectOrCreate?: Enumerable<WorkoutPlanExerciseCreateOrConnectWithoutExerciseInput>
    upsert?: Enumerable<WorkoutPlanExerciseUpsertWithWhereUniqueWithoutExerciseInput>
    createMany?: WorkoutPlanExerciseCreateManyExerciseInputEnvelope
    set?: Enumerable<WorkoutPlanExerciseWhereUniqueInput>
    disconnect?: Enumerable<WorkoutPlanExerciseWhereUniqueInput>
    delete?: Enumerable<WorkoutPlanExerciseWhereUniqueInput>
    connect?: Enumerable<WorkoutPlanExerciseWhereUniqueInput>
    update?: Enumerable<WorkoutPlanExerciseUpdateWithWhereUniqueWithoutExerciseInput>
    updateMany?: Enumerable<WorkoutPlanExerciseUpdateManyWithWhereWithoutExerciseInput>
    deleteMany?: Enumerable<WorkoutPlanExerciseScalarWhereInput>
  }

  export type WorkoutSessionExerciseUncheckedUpdateManyWithoutExerciseInput = {
    create?: XOR<Enumerable<WorkoutSessionExerciseCreateWithoutExerciseInput>, Enumerable<WorkoutSessionExerciseUncheckedCreateWithoutExerciseInput>>
    connectOrCreate?: Enumerable<WorkoutSessionExerciseCreateOrConnectWithoutExerciseInput>
    upsert?: Enumerable<WorkoutSessionExerciseUpsertWithWhereUniqueWithoutExerciseInput>
    createMany?: WorkoutSessionExerciseCreateManyExerciseInputEnvelope
    set?: Enumerable<WorkoutSessionExerciseWhereUniqueInput>
    disconnect?: Enumerable<WorkoutSessionExerciseWhereUniqueInput>
    delete?: Enumerable<WorkoutSessionExerciseWhereUniqueInput>
    connect?: Enumerable<WorkoutSessionExerciseWhereUniqueInput>
    update?: Enumerable<WorkoutSessionExerciseUpdateWithWhereUniqueWithoutExerciseInput>
    updateMany?: Enumerable<WorkoutSessionExerciseUpdateManyWithWhereWithoutExerciseInput>
    deleteMany?: Enumerable<WorkoutSessionExerciseScalarWhereInput>
  }

  export type WorkoutPlanCreateNestedOneWithoutExercisesInput = {
    create?: XOR<WorkoutPlanCreateWithoutExercisesInput, WorkoutPlanUncheckedCreateWithoutExercisesInput>
    connectOrCreate?: WorkoutPlanCreateOrConnectWithoutExercisesInput
    connect?: WorkoutPlanWhereUniqueInput
  }

  export type ExerciseCreateNestedOneWithoutPlanExercisesInput = {
    create?: XOR<ExerciseCreateWithoutPlanExercisesInput, ExerciseUncheckedCreateWithoutPlanExercisesInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutPlanExercisesInput
    connect?: ExerciseWhereUniqueInput
  }

  export type WorkoutPlanUpdateOneRequiredWithoutExercisesInput = {
    create?: XOR<WorkoutPlanCreateWithoutExercisesInput, WorkoutPlanUncheckedCreateWithoutExercisesInput>
    connectOrCreate?: WorkoutPlanCreateOrConnectWithoutExercisesInput
    upsert?: WorkoutPlanUpsertWithoutExercisesInput
    connect?: WorkoutPlanWhereUniqueInput
    update?: XOR<WorkoutPlanUpdateWithoutExercisesInput, WorkoutPlanUncheckedUpdateWithoutExercisesInput>
  }

  export type ExerciseUpdateOneRequiredWithoutPlanExercisesInput = {
    create?: XOR<ExerciseCreateWithoutPlanExercisesInput, ExerciseUncheckedCreateWithoutPlanExercisesInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutPlanExercisesInput
    upsert?: ExerciseUpsertWithoutPlanExercisesInput
    connect?: ExerciseWhereUniqueInput
    update?: XOR<ExerciseUpdateWithoutPlanExercisesInput, ExerciseUncheckedUpdateWithoutPlanExercisesInput>
  }

  export type UserCreateNestedOneWithoutWorkoutSessionsInput = {
    create?: XOR<UserCreateWithoutWorkoutSessionsInput, UserUncheckedCreateWithoutWorkoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type WorkoutPlanCreateNestedOneWithoutSessionsInput = {
    create?: XOR<WorkoutPlanCreateWithoutSessionsInput, WorkoutPlanUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: WorkoutPlanCreateOrConnectWithoutSessionsInput
    connect?: WorkoutPlanWhereUniqueInput
  }

  export type WorkoutSessionExerciseCreateNestedManyWithoutSessionInput = {
    create?: XOR<Enumerable<WorkoutSessionExerciseCreateWithoutSessionInput>, Enumerable<WorkoutSessionExerciseUncheckedCreateWithoutSessionInput>>
    connectOrCreate?: Enumerable<WorkoutSessionExerciseCreateOrConnectWithoutSessionInput>
    createMany?: WorkoutSessionExerciseCreateManySessionInputEnvelope
    connect?: Enumerable<WorkoutSessionExerciseWhereUniqueInput>
  }

  export type WorkoutSessionExerciseUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<Enumerable<WorkoutSessionExerciseCreateWithoutSessionInput>, Enumerable<WorkoutSessionExerciseUncheckedCreateWithoutSessionInput>>
    connectOrCreate?: Enumerable<WorkoutSessionExerciseCreateOrConnectWithoutSessionInput>
    createMany?: WorkoutSessionExerciseCreateManySessionInputEnvelope
    connect?: Enumerable<WorkoutSessionExerciseWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutWorkoutSessionsInput = {
    create?: XOR<UserCreateWithoutWorkoutSessionsInput, UserUncheckedCreateWithoutWorkoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkoutSessionsInput
    upsert?: UserUpsertWithoutWorkoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutWorkoutSessionsInput, UserUncheckedUpdateWithoutWorkoutSessionsInput>
  }

  export type WorkoutPlanUpdateOneRequiredWithoutSessionsInput = {
    create?: XOR<WorkoutPlanCreateWithoutSessionsInput, WorkoutPlanUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: WorkoutPlanCreateOrConnectWithoutSessionsInput
    upsert?: WorkoutPlanUpsertWithoutSessionsInput
    connect?: WorkoutPlanWhereUniqueInput
    update?: XOR<WorkoutPlanUpdateWithoutSessionsInput, WorkoutPlanUncheckedUpdateWithoutSessionsInput>
  }

  export type WorkoutSessionExerciseUpdateManyWithoutSessionInput = {
    create?: XOR<Enumerable<WorkoutSessionExerciseCreateWithoutSessionInput>, Enumerable<WorkoutSessionExerciseUncheckedCreateWithoutSessionInput>>
    connectOrCreate?: Enumerable<WorkoutSessionExerciseCreateOrConnectWithoutSessionInput>
    upsert?: Enumerable<WorkoutSessionExerciseUpsertWithWhereUniqueWithoutSessionInput>
    createMany?: WorkoutSessionExerciseCreateManySessionInputEnvelope
    set?: Enumerable<WorkoutSessionExerciseWhereUniqueInput>
    disconnect?: Enumerable<WorkoutSessionExerciseWhereUniqueInput>
    delete?: Enumerable<WorkoutSessionExerciseWhereUniqueInput>
    connect?: Enumerable<WorkoutSessionExerciseWhereUniqueInput>
    update?: Enumerable<WorkoutSessionExerciseUpdateWithWhereUniqueWithoutSessionInput>
    updateMany?: Enumerable<WorkoutSessionExerciseUpdateManyWithWhereWithoutSessionInput>
    deleteMany?: Enumerable<WorkoutSessionExerciseScalarWhereInput>
  }

  export type WorkoutSessionExerciseUncheckedUpdateManyWithoutSessionInput = {
    create?: XOR<Enumerable<WorkoutSessionExerciseCreateWithoutSessionInput>, Enumerable<WorkoutSessionExerciseUncheckedCreateWithoutSessionInput>>
    connectOrCreate?: Enumerable<WorkoutSessionExerciseCreateOrConnectWithoutSessionInput>
    upsert?: Enumerable<WorkoutSessionExerciseUpsertWithWhereUniqueWithoutSessionInput>
    createMany?: WorkoutSessionExerciseCreateManySessionInputEnvelope
    set?: Enumerable<WorkoutSessionExerciseWhereUniqueInput>
    disconnect?: Enumerable<WorkoutSessionExerciseWhereUniqueInput>
    delete?: Enumerable<WorkoutSessionExerciseWhereUniqueInput>
    connect?: Enumerable<WorkoutSessionExerciseWhereUniqueInput>
    update?: Enumerable<WorkoutSessionExerciseUpdateWithWhereUniqueWithoutSessionInput>
    updateMany?: Enumerable<WorkoutSessionExerciseUpdateManyWithWhereWithoutSessionInput>
    deleteMany?: Enumerable<WorkoutSessionExerciseScalarWhereInput>
  }

  export type WorkoutSessionCreateNestedOneWithoutSessionExercisesInput = {
    create?: XOR<WorkoutSessionCreateWithoutSessionExercisesInput, WorkoutSessionUncheckedCreateWithoutSessionExercisesInput>
    connectOrCreate?: WorkoutSessionCreateOrConnectWithoutSessionExercisesInput
    connect?: WorkoutSessionWhereUniqueInput
  }

  export type ExerciseCreateNestedOneWithoutSessionExercisesInput = {
    create?: XOR<ExerciseCreateWithoutSessionExercisesInput, ExerciseUncheckedCreateWithoutSessionExercisesInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutSessionExercisesInput
    connect?: ExerciseWhereUniqueInput
  }

  export type WorkoutSessionSetCreateNestedManyWithoutSessionExerciseInput = {
    create?: XOR<Enumerable<WorkoutSessionSetCreateWithoutSessionExerciseInput>, Enumerable<WorkoutSessionSetUncheckedCreateWithoutSessionExerciseInput>>
    connectOrCreate?: Enumerable<WorkoutSessionSetCreateOrConnectWithoutSessionExerciseInput>
    createMany?: WorkoutSessionSetCreateManySessionExerciseInputEnvelope
    connect?: Enumerable<WorkoutSessionSetWhereUniqueInput>
  }

  export type WorkoutSessionSetUncheckedCreateNestedManyWithoutSessionExerciseInput = {
    create?: XOR<Enumerable<WorkoutSessionSetCreateWithoutSessionExerciseInput>, Enumerable<WorkoutSessionSetUncheckedCreateWithoutSessionExerciseInput>>
    connectOrCreate?: Enumerable<WorkoutSessionSetCreateOrConnectWithoutSessionExerciseInput>
    createMany?: WorkoutSessionSetCreateManySessionExerciseInputEnvelope
    connect?: Enumerable<WorkoutSessionSetWhereUniqueInput>
  }

  export type WorkoutSessionUpdateOneRequiredWithoutSessionExercisesInput = {
    create?: XOR<WorkoutSessionCreateWithoutSessionExercisesInput, WorkoutSessionUncheckedCreateWithoutSessionExercisesInput>
    connectOrCreate?: WorkoutSessionCreateOrConnectWithoutSessionExercisesInput
    upsert?: WorkoutSessionUpsertWithoutSessionExercisesInput
    connect?: WorkoutSessionWhereUniqueInput
    update?: XOR<WorkoutSessionUpdateWithoutSessionExercisesInput, WorkoutSessionUncheckedUpdateWithoutSessionExercisesInput>
  }

  export type ExerciseUpdateOneRequiredWithoutSessionExercisesInput = {
    create?: XOR<ExerciseCreateWithoutSessionExercisesInput, ExerciseUncheckedCreateWithoutSessionExercisesInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutSessionExercisesInput
    upsert?: ExerciseUpsertWithoutSessionExercisesInput
    connect?: ExerciseWhereUniqueInput
    update?: XOR<ExerciseUpdateWithoutSessionExercisesInput, ExerciseUncheckedUpdateWithoutSessionExercisesInput>
  }

  export type WorkoutSessionSetUpdateManyWithoutSessionExerciseInput = {
    create?: XOR<Enumerable<WorkoutSessionSetCreateWithoutSessionExerciseInput>, Enumerable<WorkoutSessionSetUncheckedCreateWithoutSessionExerciseInput>>
    connectOrCreate?: Enumerable<WorkoutSessionSetCreateOrConnectWithoutSessionExerciseInput>
    upsert?: Enumerable<WorkoutSessionSetUpsertWithWhereUniqueWithoutSessionExerciseInput>
    createMany?: WorkoutSessionSetCreateManySessionExerciseInputEnvelope
    set?: Enumerable<WorkoutSessionSetWhereUniqueInput>
    disconnect?: Enumerable<WorkoutSessionSetWhereUniqueInput>
    delete?: Enumerable<WorkoutSessionSetWhereUniqueInput>
    connect?: Enumerable<WorkoutSessionSetWhereUniqueInput>
    update?: Enumerable<WorkoutSessionSetUpdateWithWhereUniqueWithoutSessionExerciseInput>
    updateMany?: Enumerable<WorkoutSessionSetUpdateManyWithWhereWithoutSessionExerciseInput>
    deleteMany?: Enumerable<WorkoutSessionSetScalarWhereInput>
  }

  export type WorkoutSessionSetUncheckedUpdateManyWithoutSessionExerciseInput = {
    create?: XOR<Enumerable<WorkoutSessionSetCreateWithoutSessionExerciseInput>, Enumerable<WorkoutSessionSetUncheckedCreateWithoutSessionExerciseInput>>
    connectOrCreate?: Enumerable<WorkoutSessionSetCreateOrConnectWithoutSessionExerciseInput>
    upsert?: Enumerable<WorkoutSessionSetUpsertWithWhereUniqueWithoutSessionExerciseInput>
    createMany?: WorkoutSessionSetCreateManySessionExerciseInputEnvelope
    set?: Enumerable<WorkoutSessionSetWhereUniqueInput>
    disconnect?: Enumerable<WorkoutSessionSetWhereUniqueInput>
    delete?: Enumerable<WorkoutSessionSetWhereUniqueInput>
    connect?: Enumerable<WorkoutSessionSetWhereUniqueInput>
    update?: Enumerable<WorkoutSessionSetUpdateWithWhereUniqueWithoutSessionExerciseInput>
    updateMany?: Enumerable<WorkoutSessionSetUpdateManyWithWhereWithoutSessionExerciseInput>
    deleteMany?: Enumerable<WorkoutSessionSetScalarWhereInput>
  }

  export type WorkoutSessionExerciseCreateNestedOneWithoutSetsInput = {
    create?: XOR<WorkoutSessionExerciseCreateWithoutSetsInput, WorkoutSessionExerciseUncheckedCreateWithoutSetsInput>
    connectOrCreate?: WorkoutSessionExerciseCreateOrConnectWithoutSetsInput
    connect?: WorkoutSessionExerciseWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type WorkoutSessionExerciseUpdateOneRequiredWithoutSetsInput = {
    create?: XOR<WorkoutSessionExerciseCreateWithoutSetsInput, WorkoutSessionExerciseUncheckedCreateWithoutSetsInput>
    connectOrCreate?: WorkoutSessionExerciseCreateOrConnectWithoutSetsInput
    upsert?: WorkoutSessionExerciseUpsertWithoutSetsInput
    connect?: WorkoutSessionExerciseWhereUniqueInput
    update?: XOR<WorkoutSessionExerciseUpdateWithoutSetsInput, WorkoutSessionExerciseUncheckedUpdateWithoutSetsInput>
  }

  export type UserCreateNestedOneWithoutWorkoutsInput = {
    create?: XOR<UserCreateWithoutWorkoutsInput, UserUncheckedCreateWithoutWorkoutsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkoutsInput
    connect?: UserWhereUniqueInput
  }

  export type WorkoutPlanCreateNestedOneWithoutWorkoutsInput = {
    create?: XOR<WorkoutPlanCreateWithoutWorkoutsInput, WorkoutPlanUncheckedCreateWithoutWorkoutsInput>
    connectOrCreate?: WorkoutPlanCreateOrConnectWithoutWorkoutsInput
    connect?: WorkoutPlanWhereUniqueInput
  }

  export type WorkoutExerciseCreateNestedManyWithoutWorkoutInput = {
    create?: XOR<Enumerable<WorkoutExerciseCreateWithoutWorkoutInput>, Enumerable<WorkoutExerciseUncheckedCreateWithoutWorkoutInput>>
    connectOrCreate?: Enumerable<WorkoutExerciseCreateOrConnectWithoutWorkoutInput>
    createMany?: WorkoutExerciseCreateManyWorkoutInputEnvelope
    connect?: Enumerable<WorkoutExerciseWhereUniqueInput>
  }

  export type WorkoutExerciseUncheckedCreateNestedManyWithoutWorkoutInput = {
    create?: XOR<Enumerable<WorkoutExerciseCreateWithoutWorkoutInput>, Enumerable<WorkoutExerciseUncheckedCreateWithoutWorkoutInput>>
    connectOrCreate?: Enumerable<WorkoutExerciseCreateOrConnectWithoutWorkoutInput>
    createMany?: WorkoutExerciseCreateManyWorkoutInputEnvelope
    connect?: Enumerable<WorkoutExerciseWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutWorkoutsInput = {
    create?: XOR<UserCreateWithoutWorkoutsInput, UserUncheckedCreateWithoutWorkoutsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkoutsInput
    upsert?: UserUpsertWithoutWorkoutsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutWorkoutsInput, UserUncheckedUpdateWithoutWorkoutsInput>
  }

  export type WorkoutPlanUpdateOneWithoutWorkoutsInput = {
    create?: XOR<WorkoutPlanCreateWithoutWorkoutsInput, WorkoutPlanUncheckedCreateWithoutWorkoutsInput>
    connectOrCreate?: WorkoutPlanCreateOrConnectWithoutWorkoutsInput
    upsert?: WorkoutPlanUpsertWithoutWorkoutsInput
    disconnect?: boolean
    delete?: boolean
    connect?: WorkoutPlanWhereUniqueInput
    update?: XOR<WorkoutPlanUpdateWithoutWorkoutsInput, WorkoutPlanUncheckedUpdateWithoutWorkoutsInput>
  }

  export type WorkoutExerciseUpdateManyWithoutWorkoutInput = {
    create?: XOR<Enumerable<WorkoutExerciseCreateWithoutWorkoutInput>, Enumerable<WorkoutExerciseUncheckedCreateWithoutWorkoutInput>>
    connectOrCreate?: Enumerable<WorkoutExerciseCreateOrConnectWithoutWorkoutInput>
    upsert?: Enumerable<WorkoutExerciseUpsertWithWhereUniqueWithoutWorkoutInput>
    createMany?: WorkoutExerciseCreateManyWorkoutInputEnvelope
    set?: Enumerable<WorkoutExerciseWhereUniqueInput>
    disconnect?: Enumerable<WorkoutExerciseWhereUniqueInput>
    delete?: Enumerable<WorkoutExerciseWhereUniqueInput>
    connect?: Enumerable<WorkoutExerciseWhereUniqueInput>
    update?: Enumerable<WorkoutExerciseUpdateWithWhereUniqueWithoutWorkoutInput>
    updateMany?: Enumerable<WorkoutExerciseUpdateManyWithWhereWithoutWorkoutInput>
    deleteMany?: Enumerable<WorkoutExerciseScalarWhereInput>
  }

  export type WorkoutExerciseUncheckedUpdateManyWithoutWorkoutInput = {
    create?: XOR<Enumerable<WorkoutExerciseCreateWithoutWorkoutInput>, Enumerable<WorkoutExerciseUncheckedCreateWithoutWorkoutInput>>
    connectOrCreate?: Enumerable<WorkoutExerciseCreateOrConnectWithoutWorkoutInput>
    upsert?: Enumerable<WorkoutExerciseUpsertWithWhereUniqueWithoutWorkoutInput>
    createMany?: WorkoutExerciseCreateManyWorkoutInputEnvelope
    set?: Enumerable<WorkoutExerciseWhereUniqueInput>
    disconnect?: Enumerable<WorkoutExerciseWhereUniqueInput>
    delete?: Enumerable<WorkoutExerciseWhereUniqueInput>
    connect?: Enumerable<WorkoutExerciseWhereUniqueInput>
    update?: Enumerable<WorkoutExerciseUpdateWithWhereUniqueWithoutWorkoutInput>
    updateMany?: Enumerable<WorkoutExerciseUpdateManyWithWhereWithoutWorkoutInput>
    deleteMany?: Enumerable<WorkoutExerciseScalarWhereInput>
  }

  export type WorkoutCreateNestedOneWithoutWorkoutExercisesInput = {
    create?: XOR<WorkoutCreateWithoutWorkoutExercisesInput, WorkoutUncheckedCreateWithoutWorkoutExercisesInput>
    connectOrCreate?: WorkoutCreateOrConnectWithoutWorkoutExercisesInput
    connect?: WorkoutWhereUniqueInput
  }

  export type ExerciseCreateNestedOneWithoutWorkoutExercisesInput = {
    create?: XOR<ExerciseCreateWithoutWorkoutExercisesInput, ExerciseUncheckedCreateWithoutWorkoutExercisesInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutWorkoutExercisesInput
    connect?: ExerciseWhereUniqueInput
  }

  export type WorkoutSetCreateNestedManyWithoutWorkoutExerciseInput = {
    create?: XOR<Enumerable<WorkoutSetCreateWithoutWorkoutExerciseInput>, Enumerable<WorkoutSetUncheckedCreateWithoutWorkoutExerciseInput>>
    connectOrCreate?: Enumerable<WorkoutSetCreateOrConnectWithoutWorkoutExerciseInput>
    createMany?: WorkoutSetCreateManyWorkoutExerciseInputEnvelope
    connect?: Enumerable<WorkoutSetWhereUniqueInput>
  }

  export type WorkoutSetUncheckedCreateNestedManyWithoutWorkoutExerciseInput = {
    create?: XOR<Enumerable<WorkoutSetCreateWithoutWorkoutExerciseInput>, Enumerable<WorkoutSetUncheckedCreateWithoutWorkoutExerciseInput>>
    connectOrCreate?: Enumerable<WorkoutSetCreateOrConnectWithoutWorkoutExerciseInput>
    createMany?: WorkoutSetCreateManyWorkoutExerciseInputEnvelope
    connect?: Enumerable<WorkoutSetWhereUniqueInput>
  }

  export type WorkoutUpdateOneRequiredWithoutWorkoutExercisesInput = {
    create?: XOR<WorkoutCreateWithoutWorkoutExercisesInput, WorkoutUncheckedCreateWithoutWorkoutExercisesInput>
    connectOrCreate?: WorkoutCreateOrConnectWithoutWorkoutExercisesInput
    upsert?: WorkoutUpsertWithoutWorkoutExercisesInput
    connect?: WorkoutWhereUniqueInput
    update?: XOR<WorkoutUpdateWithoutWorkoutExercisesInput, WorkoutUncheckedUpdateWithoutWorkoutExercisesInput>
  }

  export type ExerciseUpdateOneRequiredWithoutWorkoutExercisesInput = {
    create?: XOR<ExerciseCreateWithoutWorkoutExercisesInput, ExerciseUncheckedCreateWithoutWorkoutExercisesInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutWorkoutExercisesInput
    upsert?: ExerciseUpsertWithoutWorkoutExercisesInput
    connect?: ExerciseWhereUniqueInput
    update?: XOR<ExerciseUpdateWithoutWorkoutExercisesInput, ExerciseUncheckedUpdateWithoutWorkoutExercisesInput>
  }

  export type WorkoutSetUpdateManyWithoutWorkoutExerciseInput = {
    create?: XOR<Enumerable<WorkoutSetCreateWithoutWorkoutExerciseInput>, Enumerable<WorkoutSetUncheckedCreateWithoutWorkoutExerciseInput>>
    connectOrCreate?: Enumerable<WorkoutSetCreateOrConnectWithoutWorkoutExerciseInput>
    upsert?: Enumerable<WorkoutSetUpsertWithWhereUniqueWithoutWorkoutExerciseInput>
    createMany?: WorkoutSetCreateManyWorkoutExerciseInputEnvelope
    set?: Enumerable<WorkoutSetWhereUniqueInput>
    disconnect?: Enumerable<WorkoutSetWhereUniqueInput>
    delete?: Enumerable<WorkoutSetWhereUniqueInput>
    connect?: Enumerable<WorkoutSetWhereUniqueInput>
    update?: Enumerable<WorkoutSetUpdateWithWhereUniqueWithoutWorkoutExerciseInput>
    updateMany?: Enumerable<WorkoutSetUpdateManyWithWhereWithoutWorkoutExerciseInput>
    deleteMany?: Enumerable<WorkoutSetScalarWhereInput>
  }

  export type WorkoutSetUncheckedUpdateManyWithoutWorkoutExerciseInput = {
    create?: XOR<Enumerable<WorkoutSetCreateWithoutWorkoutExerciseInput>, Enumerable<WorkoutSetUncheckedCreateWithoutWorkoutExerciseInput>>
    connectOrCreate?: Enumerable<WorkoutSetCreateOrConnectWithoutWorkoutExerciseInput>
    upsert?: Enumerable<WorkoutSetUpsertWithWhereUniqueWithoutWorkoutExerciseInput>
    createMany?: WorkoutSetCreateManyWorkoutExerciseInputEnvelope
    set?: Enumerable<WorkoutSetWhereUniqueInput>
    disconnect?: Enumerable<WorkoutSetWhereUniqueInput>
    delete?: Enumerable<WorkoutSetWhereUniqueInput>
    connect?: Enumerable<WorkoutSetWhereUniqueInput>
    update?: Enumerable<WorkoutSetUpdateWithWhereUniqueWithoutWorkoutExerciseInput>
    updateMany?: Enumerable<WorkoutSetUpdateManyWithWhereWithoutWorkoutExerciseInput>
    deleteMany?: Enumerable<WorkoutSetScalarWhereInput>
  }

  export type WorkoutExerciseCreateNestedOneWithoutSetsInput = {
    create?: XOR<WorkoutExerciseCreateWithoutSetsInput, WorkoutExerciseUncheckedCreateWithoutSetsInput>
    connectOrCreate?: WorkoutExerciseCreateOrConnectWithoutSetsInput
    connect?: WorkoutExerciseWhereUniqueInput
  }

  export type WorkoutExerciseUpdateOneRequiredWithoutSetsInput = {
    create?: XOR<WorkoutExerciseCreateWithoutSetsInput, WorkoutExerciseUncheckedCreateWithoutSetsInput>
    connectOrCreate?: WorkoutExerciseCreateOrConnectWithoutSetsInput
    upsert?: WorkoutExerciseUpsertWithoutSetsInput
    connect?: WorkoutExerciseWhereUniqueInput
    update?: XOR<WorkoutExerciseUpdateWithoutSetsInput, WorkoutExerciseUncheckedUpdateWithoutSetsInput>
  }

  export type UserCreateNestedOneWithoutWeightsInput = {
    create?: XOR<UserCreateWithoutWeightsInput, UserUncheckedCreateWithoutWeightsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWeightsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutWeightsInput = {
    create?: XOR<UserCreateWithoutWeightsInput, UserUncheckedCreateWithoutWeightsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWeightsInput
    upsert?: UserUpsertWithoutWeightsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutWeightsInput, UserUncheckedUpdateWithoutWeightsInput>
  }

  export type UserCreateNestedOneWithoutSentMessagesInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedMessagesInput = {
    create?: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSentMessagesInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    upsert?: UserUpsertWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutReceivedMessagesInput = {
    create?: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedMessagesInput
    upsert?: UserUpsertWithoutReceivedMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutReceivedMessagesInput, UserUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedEnumRoleFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleFilter | Role
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedEnumRoleWithAggregatesFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleWithAggregatesFilter | Role
    _count?: NestedIntFilter
    _min?: NestedEnumRoleFilter
    _max?: NestedEnumRoleFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type NestedFloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type WorkoutPlanCreateWithoutCreatorInput = {
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedTo?: UserCreateNestedOneWithoutAssignedWorkoutPlansInput
    exercises?: WorkoutPlanExerciseCreateNestedManyWithoutPlanInput
    sessions?: WorkoutSessionCreateNestedManyWithoutPlanInput
    workouts?: WorkoutCreateNestedManyWithoutWorkoutPlanInput
  }

  export type WorkoutPlanUncheckedCreateWithoutCreatorInput = {
    id?: number
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToId?: number | null
    exercises?: WorkoutPlanExerciseUncheckedCreateNestedManyWithoutPlanInput
    sessions?: WorkoutSessionUncheckedCreateNestedManyWithoutPlanInput
    workouts?: WorkoutUncheckedCreateNestedManyWithoutWorkoutPlanInput
  }

  export type WorkoutPlanCreateOrConnectWithoutCreatorInput = {
    where: WorkoutPlanWhereUniqueInput
    create: XOR<WorkoutPlanCreateWithoutCreatorInput, WorkoutPlanUncheckedCreateWithoutCreatorInput>
  }

  export type WorkoutPlanCreateManyCreatorInputEnvelope = {
    data: Enumerable<WorkoutPlanCreateManyCreatorInput>
    skipDuplicates?: boolean
  }

  export type WorkoutPlanCreateWithoutAssignedToInput = {
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedWorkoutPlansInput
    exercises?: WorkoutPlanExerciseCreateNestedManyWithoutPlanInput
    sessions?: WorkoutSessionCreateNestedManyWithoutPlanInput
    workouts?: WorkoutCreateNestedManyWithoutWorkoutPlanInput
  }

  export type WorkoutPlanUncheckedCreateWithoutAssignedToInput = {
    id?: number
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: number
    exercises?: WorkoutPlanExerciseUncheckedCreateNestedManyWithoutPlanInput
    sessions?: WorkoutSessionUncheckedCreateNestedManyWithoutPlanInput
    workouts?: WorkoutUncheckedCreateNestedManyWithoutWorkoutPlanInput
  }

  export type WorkoutPlanCreateOrConnectWithoutAssignedToInput = {
    where: WorkoutPlanWhereUniqueInput
    create: XOR<WorkoutPlanCreateWithoutAssignedToInput, WorkoutPlanUncheckedCreateWithoutAssignedToInput>
  }

  export type WorkoutPlanCreateManyAssignedToInputEnvelope = {
    data: Enumerable<WorkoutPlanCreateManyAssignedToInput>
    skipDuplicates?: boolean
  }

  export type WorkoutCreateWithoutAthleteInput = {
    date: Date | string
    durationMinutes: number
    notes?: string | null
    createdAt?: Date | string
    workoutPlan?: WorkoutPlanCreateNestedOneWithoutWorkoutsInput
    workoutExercises?: WorkoutExerciseCreateNestedManyWithoutWorkoutInput
  }

  export type WorkoutUncheckedCreateWithoutAthleteInput = {
    id?: number
    date: Date | string
    durationMinutes: number
    notes?: string | null
    createdAt?: Date | string
    workoutPlanId?: number | null
    workoutExercises?: WorkoutExerciseUncheckedCreateNestedManyWithoutWorkoutInput
  }

  export type WorkoutCreateOrConnectWithoutAthleteInput = {
    where: WorkoutWhereUniqueInput
    create: XOR<WorkoutCreateWithoutAthleteInput, WorkoutUncheckedCreateWithoutAthleteInput>
  }

  export type WorkoutCreateManyAthleteInputEnvelope = {
    data: Enumerable<WorkoutCreateManyAthleteInput>
    skipDuplicates?: boolean
  }

  export type WeightCreateWithoutAthleteInput = {
    weightKg: number
    date: Date | string
    createdAt?: Date | string
  }

  export type WeightUncheckedCreateWithoutAthleteInput = {
    id?: number
    weightKg: number
    date: Date | string
    createdAt?: Date | string
  }

  export type WeightCreateOrConnectWithoutAthleteInput = {
    where: WeightWhereUniqueInput
    create: XOR<WeightCreateWithoutAthleteInput, WeightUncheckedCreateWithoutAthleteInput>
  }

  export type WeightCreateManyAthleteInputEnvelope = {
    data: Enumerable<WeightCreateManyAthleteInput>
    skipDuplicates?: boolean
  }

  export type AthleteCoachCreateWithoutCoachInput = {
    athlete: UserCreateNestedOneWithoutAthleteLinksInput
  }

  export type AthleteCoachUncheckedCreateWithoutCoachInput = {
    id?: number
    athleteId: number
  }

  export type AthleteCoachCreateOrConnectWithoutCoachInput = {
    where: AthleteCoachWhereUniqueInput
    create: XOR<AthleteCoachCreateWithoutCoachInput, AthleteCoachUncheckedCreateWithoutCoachInput>
  }

  export type AthleteCoachCreateManyCoachInputEnvelope = {
    data: Enumerable<AthleteCoachCreateManyCoachInput>
    skipDuplicates?: boolean
  }

  export type AthleteCoachCreateWithoutAthleteInput = {
    coach: UserCreateNestedOneWithoutCoachLinksInput
  }

  export type AthleteCoachUncheckedCreateWithoutAthleteInput = {
    id?: number
    coachId: number
  }

  export type AthleteCoachCreateOrConnectWithoutAthleteInput = {
    where: AthleteCoachWhereUniqueInput
    create: XOR<AthleteCoachCreateWithoutAthleteInput, AthleteCoachUncheckedCreateWithoutAthleteInput>
  }

  export type AthleteCoachCreateManyAthleteInputEnvelope = {
    data: Enumerable<AthleteCoachCreateManyAthleteInput>
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutSenderInput = {
    content: string
    createdAt?: Date | string
    receiver: UserCreateNestedOneWithoutReceivedMessagesInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: number
    receiverId: number
    content: string
    createdAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: Enumerable<MessageCreateManySenderInput>
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutReceiverInput = {
    content: string
    createdAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
  }

  export type MessageUncheckedCreateWithoutReceiverInput = {
    id?: number
    senderId: number
    content: string
    createdAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutReceiverInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput>
  }

  export type MessageCreateManyReceiverInputEnvelope = {
    data: Enumerable<MessageCreateManyReceiverInput>
    skipDuplicates?: boolean
  }

  export type WorkoutSessionCreateWithoutAthleteInput = {
    date?: Date | string
    plan: WorkoutPlanCreateNestedOneWithoutSessionsInput
    sessionExercises?: WorkoutSessionExerciseCreateNestedManyWithoutSessionInput
  }

  export type WorkoutSessionUncheckedCreateWithoutAthleteInput = {
    id?: number
    planId: number
    date?: Date | string
    sessionExercises?: WorkoutSessionExerciseUncheckedCreateNestedManyWithoutSessionInput
  }

  export type WorkoutSessionCreateOrConnectWithoutAthleteInput = {
    where: WorkoutSessionWhereUniqueInput
    create: XOR<WorkoutSessionCreateWithoutAthleteInput, WorkoutSessionUncheckedCreateWithoutAthleteInput>
  }

  export type WorkoutSessionCreateManyAthleteInputEnvelope = {
    data: Enumerable<WorkoutSessionCreateManyAthleteInput>
    skipDuplicates?: boolean
  }

  export type WorkoutPlanUpsertWithWhereUniqueWithoutCreatorInput = {
    where: WorkoutPlanWhereUniqueInput
    update: XOR<WorkoutPlanUpdateWithoutCreatorInput, WorkoutPlanUncheckedUpdateWithoutCreatorInput>
    create: XOR<WorkoutPlanCreateWithoutCreatorInput, WorkoutPlanUncheckedCreateWithoutCreatorInput>
  }

  export type WorkoutPlanUpdateWithWhereUniqueWithoutCreatorInput = {
    where: WorkoutPlanWhereUniqueInput
    data: XOR<WorkoutPlanUpdateWithoutCreatorInput, WorkoutPlanUncheckedUpdateWithoutCreatorInput>
  }

  export type WorkoutPlanUpdateManyWithWhereWithoutCreatorInput = {
    where: WorkoutPlanScalarWhereInput
    data: XOR<WorkoutPlanUpdateManyMutationInput, WorkoutPlanUncheckedUpdateManyWithoutCreatedWorkoutPlansInput>
  }

  export type WorkoutPlanScalarWhereInput = {
    AND?: Enumerable<WorkoutPlanScalarWhereInput>
    OR?: Enumerable<WorkoutPlanScalarWhereInput>
    NOT?: Enumerable<WorkoutPlanScalarWhereInput>
    id?: IntFilter | number
    title?: StringFilter | string
    description?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    creatorId?: IntFilter | number
    assignedToId?: IntNullableFilter | number | null
  }

  export type WorkoutPlanUpsertWithWhereUniqueWithoutAssignedToInput = {
    where: WorkoutPlanWhereUniqueInput
    update: XOR<WorkoutPlanUpdateWithoutAssignedToInput, WorkoutPlanUncheckedUpdateWithoutAssignedToInput>
    create: XOR<WorkoutPlanCreateWithoutAssignedToInput, WorkoutPlanUncheckedCreateWithoutAssignedToInput>
  }

  export type WorkoutPlanUpdateWithWhereUniqueWithoutAssignedToInput = {
    where: WorkoutPlanWhereUniqueInput
    data: XOR<WorkoutPlanUpdateWithoutAssignedToInput, WorkoutPlanUncheckedUpdateWithoutAssignedToInput>
  }

  export type WorkoutPlanUpdateManyWithWhereWithoutAssignedToInput = {
    where: WorkoutPlanScalarWhereInput
    data: XOR<WorkoutPlanUpdateManyMutationInput, WorkoutPlanUncheckedUpdateManyWithoutAssignedWorkoutPlansInput>
  }

  export type WorkoutUpsertWithWhereUniqueWithoutAthleteInput = {
    where: WorkoutWhereUniqueInput
    update: XOR<WorkoutUpdateWithoutAthleteInput, WorkoutUncheckedUpdateWithoutAthleteInput>
    create: XOR<WorkoutCreateWithoutAthleteInput, WorkoutUncheckedCreateWithoutAthleteInput>
  }

  export type WorkoutUpdateWithWhereUniqueWithoutAthleteInput = {
    where: WorkoutWhereUniqueInput
    data: XOR<WorkoutUpdateWithoutAthleteInput, WorkoutUncheckedUpdateWithoutAthleteInput>
  }

  export type WorkoutUpdateManyWithWhereWithoutAthleteInput = {
    where: WorkoutScalarWhereInput
    data: XOR<WorkoutUpdateManyMutationInput, WorkoutUncheckedUpdateManyWithoutWorkoutsInput>
  }

  export type WorkoutScalarWhereInput = {
    AND?: Enumerable<WorkoutScalarWhereInput>
    OR?: Enumerable<WorkoutScalarWhereInput>
    NOT?: Enumerable<WorkoutScalarWhereInput>
    id?: IntFilter | number
    date?: DateTimeFilter | Date | string
    durationMinutes?: IntFilter | number
    notes?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    athleteId?: IntFilter | number
    workoutPlanId?: IntNullableFilter | number | null
  }

  export type WeightUpsertWithWhereUniqueWithoutAthleteInput = {
    where: WeightWhereUniqueInput
    update: XOR<WeightUpdateWithoutAthleteInput, WeightUncheckedUpdateWithoutAthleteInput>
    create: XOR<WeightCreateWithoutAthleteInput, WeightUncheckedCreateWithoutAthleteInput>
  }

  export type WeightUpdateWithWhereUniqueWithoutAthleteInput = {
    where: WeightWhereUniqueInput
    data: XOR<WeightUpdateWithoutAthleteInput, WeightUncheckedUpdateWithoutAthleteInput>
  }

  export type WeightUpdateManyWithWhereWithoutAthleteInput = {
    where: WeightScalarWhereInput
    data: XOR<WeightUpdateManyMutationInput, WeightUncheckedUpdateManyWithoutWeightsInput>
  }

  export type WeightScalarWhereInput = {
    AND?: Enumerable<WeightScalarWhereInput>
    OR?: Enumerable<WeightScalarWhereInput>
    NOT?: Enumerable<WeightScalarWhereInput>
    id?: IntFilter | number
    weightKg?: FloatFilter | number
    date?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    athleteId?: IntFilter | number
  }

  export type AthleteCoachUpsertWithWhereUniqueWithoutCoachInput = {
    where: AthleteCoachWhereUniqueInput
    update: XOR<AthleteCoachUpdateWithoutCoachInput, AthleteCoachUncheckedUpdateWithoutCoachInput>
    create: XOR<AthleteCoachCreateWithoutCoachInput, AthleteCoachUncheckedCreateWithoutCoachInput>
  }

  export type AthleteCoachUpdateWithWhereUniqueWithoutCoachInput = {
    where: AthleteCoachWhereUniqueInput
    data: XOR<AthleteCoachUpdateWithoutCoachInput, AthleteCoachUncheckedUpdateWithoutCoachInput>
  }

  export type AthleteCoachUpdateManyWithWhereWithoutCoachInput = {
    where: AthleteCoachScalarWhereInput
    data: XOR<AthleteCoachUpdateManyMutationInput, AthleteCoachUncheckedUpdateManyWithoutCoachLinksInput>
  }

  export type AthleteCoachScalarWhereInput = {
    AND?: Enumerable<AthleteCoachScalarWhereInput>
    OR?: Enumerable<AthleteCoachScalarWhereInput>
    NOT?: Enumerable<AthleteCoachScalarWhereInput>
    id?: IntFilter | number
    coachId?: IntFilter | number
    athleteId?: IntFilter | number
  }

  export type AthleteCoachUpsertWithWhereUniqueWithoutAthleteInput = {
    where: AthleteCoachWhereUniqueInput
    update: XOR<AthleteCoachUpdateWithoutAthleteInput, AthleteCoachUncheckedUpdateWithoutAthleteInput>
    create: XOR<AthleteCoachCreateWithoutAthleteInput, AthleteCoachUncheckedCreateWithoutAthleteInput>
  }

  export type AthleteCoachUpdateWithWhereUniqueWithoutAthleteInput = {
    where: AthleteCoachWhereUniqueInput
    data: XOR<AthleteCoachUpdateWithoutAthleteInput, AthleteCoachUncheckedUpdateWithoutAthleteInput>
  }

  export type AthleteCoachUpdateManyWithWhereWithoutAthleteInput = {
    where: AthleteCoachScalarWhereInput
    data: XOR<AthleteCoachUpdateManyMutationInput, AthleteCoachUncheckedUpdateManyWithoutAthleteLinksInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSentMessagesInput>
  }

  export type MessageScalarWhereInput = {
    AND?: Enumerable<MessageScalarWhereInput>
    OR?: Enumerable<MessageScalarWhereInput>
    NOT?: Enumerable<MessageScalarWhereInput>
    id?: IntFilter | number
    senderId?: IntFilter | number
    receiverId?: IntFilter | number
    content?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutReceiverInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutReceiverInput, MessageUncheckedUpdateWithoutReceiverInput>
    create: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutReceiverInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutReceiverInput, MessageUncheckedUpdateWithoutReceiverInput>
  }

  export type MessageUpdateManyWithWhereWithoutReceiverInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutReceivedMessagesInput>
  }

  export type WorkoutSessionUpsertWithWhereUniqueWithoutAthleteInput = {
    where: WorkoutSessionWhereUniqueInput
    update: XOR<WorkoutSessionUpdateWithoutAthleteInput, WorkoutSessionUncheckedUpdateWithoutAthleteInput>
    create: XOR<WorkoutSessionCreateWithoutAthleteInput, WorkoutSessionUncheckedCreateWithoutAthleteInput>
  }

  export type WorkoutSessionUpdateWithWhereUniqueWithoutAthleteInput = {
    where: WorkoutSessionWhereUniqueInput
    data: XOR<WorkoutSessionUpdateWithoutAthleteInput, WorkoutSessionUncheckedUpdateWithoutAthleteInput>
  }

  export type WorkoutSessionUpdateManyWithWhereWithoutAthleteInput = {
    where: WorkoutSessionScalarWhereInput
    data: XOR<WorkoutSessionUpdateManyMutationInput, WorkoutSessionUncheckedUpdateManyWithoutWorkoutSessionsInput>
  }

  export type WorkoutSessionScalarWhereInput = {
    AND?: Enumerable<WorkoutSessionScalarWhereInput>
    OR?: Enumerable<WorkoutSessionScalarWhereInput>
    NOT?: Enumerable<WorkoutSessionScalarWhereInput>
    id?: IntFilter | number
    athleteId?: IntFilter | number
    planId?: IntFilter | number
    date?: DateTimeFilter | Date | string
  }

  export type UserCreateWithoutCoachLinksInput = {
    email: string
    passwordHash: string
    fullName: string
    role: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    createdWorkoutPlans?: WorkoutPlanCreateNestedManyWithoutCreatorInput
    assignedWorkoutPlans?: WorkoutPlanCreateNestedManyWithoutAssignedToInput
    workouts?: WorkoutCreateNestedManyWithoutAthleteInput
    weights?: WeightCreateNestedManyWithoutAthleteInput
    athleteLinks?: AthleteCoachCreateNestedManyWithoutAthleteInput
    SentMessages?: MessageCreateNestedManyWithoutSenderInput
    ReceivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    workoutSessions?: WorkoutSessionCreateNestedManyWithoutAthleteInput
  }

  export type UserUncheckedCreateWithoutCoachLinksInput = {
    id?: number
    email: string
    passwordHash: string
    fullName: string
    role: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    createdWorkoutPlans?: WorkoutPlanUncheckedCreateNestedManyWithoutCreatorInput
    assignedWorkoutPlans?: WorkoutPlanUncheckedCreateNestedManyWithoutAssignedToInput
    workouts?: WorkoutUncheckedCreateNestedManyWithoutAthleteInput
    weights?: WeightUncheckedCreateNestedManyWithoutAthleteInput
    athleteLinks?: AthleteCoachUncheckedCreateNestedManyWithoutAthleteInput
    SentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    ReceivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    workoutSessions?: WorkoutSessionUncheckedCreateNestedManyWithoutAthleteInput
  }

  export type UserCreateOrConnectWithoutCoachLinksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCoachLinksInput, UserUncheckedCreateWithoutCoachLinksInput>
  }

  export type UserCreateWithoutAthleteLinksInput = {
    email: string
    passwordHash: string
    fullName: string
    role: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    createdWorkoutPlans?: WorkoutPlanCreateNestedManyWithoutCreatorInput
    assignedWorkoutPlans?: WorkoutPlanCreateNestedManyWithoutAssignedToInput
    workouts?: WorkoutCreateNestedManyWithoutAthleteInput
    weights?: WeightCreateNestedManyWithoutAthleteInput
    coachLinks?: AthleteCoachCreateNestedManyWithoutCoachInput
    SentMessages?: MessageCreateNestedManyWithoutSenderInput
    ReceivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    workoutSessions?: WorkoutSessionCreateNestedManyWithoutAthleteInput
  }

  export type UserUncheckedCreateWithoutAthleteLinksInput = {
    id?: number
    email: string
    passwordHash: string
    fullName: string
    role: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    createdWorkoutPlans?: WorkoutPlanUncheckedCreateNestedManyWithoutCreatorInput
    assignedWorkoutPlans?: WorkoutPlanUncheckedCreateNestedManyWithoutAssignedToInput
    workouts?: WorkoutUncheckedCreateNestedManyWithoutAthleteInput
    weights?: WeightUncheckedCreateNestedManyWithoutAthleteInput
    coachLinks?: AthleteCoachUncheckedCreateNestedManyWithoutCoachInput
    SentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    ReceivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    workoutSessions?: WorkoutSessionUncheckedCreateNestedManyWithoutAthleteInput
  }

  export type UserCreateOrConnectWithoutAthleteLinksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAthleteLinksInput, UserUncheckedCreateWithoutAthleteLinksInput>
  }

  export type UserUpsertWithoutCoachLinksInput = {
    update: XOR<UserUpdateWithoutCoachLinksInput, UserUncheckedUpdateWithoutCoachLinksInput>
    create: XOR<UserCreateWithoutCoachLinksInput, UserUncheckedCreateWithoutCoachLinksInput>
  }

  export type UserUpdateWithoutCoachLinksInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdWorkoutPlans?: WorkoutPlanUpdateManyWithoutCreatorInput
    assignedWorkoutPlans?: WorkoutPlanUpdateManyWithoutAssignedToInput
    workouts?: WorkoutUpdateManyWithoutAthleteInput
    weights?: WeightUpdateManyWithoutAthleteInput
    athleteLinks?: AthleteCoachUpdateManyWithoutAthleteInput
    SentMessages?: MessageUpdateManyWithoutSenderInput
    ReceivedMessages?: MessageUpdateManyWithoutReceiverInput
    workoutSessions?: WorkoutSessionUpdateManyWithoutAthleteInput
  }

  export type UserUncheckedUpdateWithoutCoachLinksInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdWorkoutPlans?: WorkoutPlanUncheckedUpdateManyWithoutCreatorInput
    assignedWorkoutPlans?: WorkoutPlanUncheckedUpdateManyWithoutAssignedToInput
    workouts?: WorkoutUncheckedUpdateManyWithoutAthleteInput
    weights?: WeightUncheckedUpdateManyWithoutAthleteInput
    athleteLinks?: AthleteCoachUncheckedUpdateManyWithoutAthleteInput
    SentMessages?: MessageUncheckedUpdateManyWithoutSenderInput
    ReceivedMessages?: MessageUncheckedUpdateManyWithoutReceiverInput
    workoutSessions?: WorkoutSessionUncheckedUpdateManyWithoutAthleteInput
  }

  export type UserUpsertWithoutAthleteLinksInput = {
    update: XOR<UserUpdateWithoutAthleteLinksInput, UserUncheckedUpdateWithoutAthleteLinksInput>
    create: XOR<UserCreateWithoutAthleteLinksInput, UserUncheckedCreateWithoutAthleteLinksInput>
  }

  export type UserUpdateWithoutAthleteLinksInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdWorkoutPlans?: WorkoutPlanUpdateManyWithoutCreatorInput
    assignedWorkoutPlans?: WorkoutPlanUpdateManyWithoutAssignedToInput
    workouts?: WorkoutUpdateManyWithoutAthleteInput
    weights?: WeightUpdateManyWithoutAthleteInput
    coachLinks?: AthleteCoachUpdateManyWithoutCoachInput
    SentMessages?: MessageUpdateManyWithoutSenderInput
    ReceivedMessages?: MessageUpdateManyWithoutReceiverInput
    workoutSessions?: WorkoutSessionUpdateManyWithoutAthleteInput
  }

  export type UserUncheckedUpdateWithoutAthleteLinksInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdWorkoutPlans?: WorkoutPlanUncheckedUpdateManyWithoutCreatorInput
    assignedWorkoutPlans?: WorkoutPlanUncheckedUpdateManyWithoutAssignedToInput
    workouts?: WorkoutUncheckedUpdateManyWithoutAthleteInput
    weights?: WeightUncheckedUpdateManyWithoutAthleteInput
    coachLinks?: AthleteCoachUncheckedUpdateManyWithoutCoachInput
    SentMessages?: MessageUncheckedUpdateManyWithoutSenderInput
    ReceivedMessages?: MessageUncheckedUpdateManyWithoutReceiverInput
    workoutSessions?: WorkoutSessionUncheckedUpdateManyWithoutAthleteInput
  }

  export type UserCreateWithoutCreatedWorkoutPlansInput = {
    email: string
    passwordHash: string
    fullName: string
    role: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedWorkoutPlans?: WorkoutPlanCreateNestedManyWithoutAssignedToInput
    workouts?: WorkoutCreateNestedManyWithoutAthleteInput
    weights?: WeightCreateNestedManyWithoutAthleteInput
    coachLinks?: AthleteCoachCreateNestedManyWithoutCoachInput
    athleteLinks?: AthleteCoachCreateNestedManyWithoutAthleteInput
    SentMessages?: MessageCreateNestedManyWithoutSenderInput
    ReceivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    workoutSessions?: WorkoutSessionCreateNestedManyWithoutAthleteInput
  }

  export type UserUncheckedCreateWithoutCreatedWorkoutPlansInput = {
    id?: number
    email: string
    passwordHash: string
    fullName: string
    role: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedWorkoutPlans?: WorkoutPlanUncheckedCreateNestedManyWithoutAssignedToInput
    workouts?: WorkoutUncheckedCreateNestedManyWithoutAthleteInput
    weights?: WeightUncheckedCreateNestedManyWithoutAthleteInput
    coachLinks?: AthleteCoachUncheckedCreateNestedManyWithoutCoachInput
    athleteLinks?: AthleteCoachUncheckedCreateNestedManyWithoutAthleteInput
    SentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    ReceivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    workoutSessions?: WorkoutSessionUncheckedCreateNestedManyWithoutAthleteInput
  }

  export type UserCreateOrConnectWithoutCreatedWorkoutPlansInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedWorkoutPlansInput, UserUncheckedCreateWithoutCreatedWorkoutPlansInput>
  }

  export type UserCreateWithoutAssignedWorkoutPlansInput = {
    email: string
    passwordHash: string
    fullName: string
    role: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    createdWorkoutPlans?: WorkoutPlanCreateNestedManyWithoutCreatorInput
    workouts?: WorkoutCreateNestedManyWithoutAthleteInput
    weights?: WeightCreateNestedManyWithoutAthleteInput
    coachLinks?: AthleteCoachCreateNestedManyWithoutCoachInput
    athleteLinks?: AthleteCoachCreateNestedManyWithoutAthleteInput
    SentMessages?: MessageCreateNestedManyWithoutSenderInput
    ReceivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    workoutSessions?: WorkoutSessionCreateNestedManyWithoutAthleteInput
  }

  export type UserUncheckedCreateWithoutAssignedWorkoutPlansInput = {
    id?: number
    email: string
    passwordHash: string
    fullName: string
    role: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    createdWorkoutPlans?: WorkoutPlanUncheckedCreateNestedManyWithoutCreatorInput
    workouts?: WorkoutUncheckedCreateNestedManyWithoutAthleteInput
    weights?: WeightUncheckedCreateNestedManyWithoutAthleteInput
    coachLinks?: AthleteCoachUncheckedCreateNestedManyWithoutCoachInput
    athleteLinks?: AthleteCoachUncheckedCreateNestedManyWithoutAthleteInput
    SentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    ReceivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    workoutSessions?: WorkoutSessionUncheckedCreateNestedManyWithoutAthleteInput
  }

  export type UserCreateOrConnectWithoutAssignedWorkoutPlansInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedWorkoutPlansInput, UserUncheckedCreateWithoutAssignedWorkoutPlansInput>
  }

  export type WorkoutPlanExerciseCreateWithoutPlanInput = {
    orderIndex?: number
    exercise: ExerciseCreateNestedOneWithoutPlanExercisesInput
  }

  export type WorkoutPlanExerciseUncheckedCreateWithoutPlanInput = {
    id?: number
    exerciseId: number
    orderIndex?: number
  }

  export type WorkoutPlanExerciseCreateOrConnectWithoutPlanInput = {
    where: WorkoutPlanExerciseWhereUniqueInput
    create: XOR<WorkoutPlanExerciseCreateWithoutPlanInput, WorkoutPlanExerciseUncheckedCreateWithoutPlanInput>
  }

  export type WorkoutPlanExerciseCreateManyPlanInputEnvelope = {
    data: Enumerable<WorkoutPlanExerciseCreateManyPlanInput>
    skipDuplicates?: boolean
  }

  export type WorkoutSessionCreateWithoutPlanInput = {
    date?: Date | string
    athlete: UserCreateNestedOneWithoutWorkoutSessionsInput
    sessionExercises?: WorkoutSessionExerciseCreateNestedManyWithoutSessionInput
  }

  export type WorkoutSessionUncheckedCreateWithoutPlanInput = {
    id?: number
    athleteId: number
    date?: Date | string
    sessionExercises?: WorkoutSessionExerciseUncheckedCreateNestedManyWithoutSessionInput
  }

  export type WorkoutSessionCreateOrConnectWithoutPlanInput = {
    where: WorkoutSessionWhereUniqueInput
    create: XOR<WorkoutSessionCreateWithoutPlanInput, WorkoutSessionUncheckedCreateWithoutPlanInput>
  }

  export type WorkoutSessionCreateManyPlanInputEnvelope = {
    data: Enumerable<WorkoutSessionCreateManyPlanInput>
    skipDuplicates?: boolean
  }

  export type WorkoutCreateWithoutWorkoutPlanInput = {
    date: Date | string
    durationMinutes: number
    notes?: string | null
    createdAt?: Date | string
    athlete: UserCreateNestedOneWithoutWorkoutsInput
    workoutExercises?: WorkoutExerciseCreateNestedManyWithoutWorkoutInput
  }

  export type WorkoutUncheckedCreateWithoutWorkoutPlanInput = {
    id?: number
    date: Date | string
    durationMinutes: number
    notes?: string | null
    createdAt?: Date | string
    athleteId: number
    workoutExercises?: WorkoutExerciseUncheckedCreateNestedManyWithoutWorkoutInput
  }

  export type WorkoutCreateOrConnectWithoutWorkoutPlanInput = {
    where: WorkoutWhereUniqueInput
    create: XOR<WorkoutCreateWithoutWorkoutPlanInput, WorkoutUncheckedCreateWithoutWorkoutPlanInput>
  }

  export type WorkoutCreateManyWorkoutPlanInputEnvelope = {
    data: Enumerable<WorkoutCreateManyWorkoutPlanInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCreatedWorkoutPlansInput = {
    update: XOR<UserUpdateWithoutCreatedWorkoutPlansInput, UserUncheckedUpdateWithoutCreatedWorkoutPlansInput>
    create: XOR<UserCreateWithoutCreatedWorkoutPlansInput, UserUncheckedCreateWithoutCreatedWorkoutPlansInput>
  }

  export type UserUpdateWithoutCreatedWorkoutPlansInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedWorkoutPlans?: WorkoutPlanUpdateManyWithoutAssignedToInput
    workouts?: WorkoutUpdateManyWithoutAthleteInput
    weights?: WeightUpdateManyWithoutAthleteInput
    coachLinks?: AthleteCoachUpdateManyWithoutCoachInput
    athleteLinks?: AthleteCoachUpdateManyWithoutAthleteInput
    SentMessages?: MessageUpdateManyWithoutSenderInput
    ReceivedMessages?: MessageUpdateManyWithoutReceiverInput
    workoutSessions?: WorkoutSessionUpdateManyWithoutAthleteInput
  }

  export type UserUncheckedUpdateWithoutCreatedWorkoutPlansInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedWorkoutPlans?: WorkoutPlanUncheckedUpdateManyWithoutAssignedToInput
    workouts?: WorkoutUncheckedUpdateManyWithoutAthleteInput
    weights?: WeightUncheckedUpdateManyWithoutAthleteInput
    coachLinks?: AthleteCoachUncheckedUpdateManyWithoutCoachInput
    athleteLinks?: AthleteCoachUncheckedUpdateManyWithoutAthleteInput
    SentMessages?: MessageUncheckedUpdateManyWithoutSenderInput
    ReceivedMessages?: MessageUncheckedUpdateManyWithoutReceiverInput
    workoutSessions?: WorkoutSessionUncheckedUpdateManyWithoutAthleteInput
  }

  export type UserUpsertWithoutAssignedWorkoutPlansInput = {
    update: XOR<UserUpdateWithoutAssignedWorkoutPlansInput, UserUncheckedUpdateWithoutAssignedWorkoutPlansInput>
    create: XOR<UserCreateWithoutAssignedWorkoutPlansInput, UserUncheckedCreateWithoutAssignedWorkoutPlansInput>
  }

  export type UserUpdateWithoutAssignedWorkoutPlansInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdWorkoutPlans?: WorkoutPlanUpdateManyWithoutCreatorInput
    workouts?: WorkoutUpdateManyWithoutAthleteInput
    weights?: WeightUpdateManyWithoutAthleteInput
    coachLinks?: AthleteCoachUpdateManyWithoutCoachInput
    athleteLinks?: AthleteCoachUpdateManyWithoutAthleteInput
    SentMessages?: MessageUpdateManyWithoutSenderInput
    ReceivedMessages?: MessageUpdateManyWithoutReceiverInput
    workoutSessions?: WorkoutSessionUpdateManyWithoutAthleteInput
  }

  export type UserUncheckedUpdateWithoutAssignedWorkoutPlansInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdWorkoutPlans?: WorkoutPlanUncheckedUpdateManyWithoutCreatorInput
    workouts?: WorkoutUncheckedUpdateManyWithoutAthleteInput
    weights?: WeightUncheckedUpdateManyWithoutAthleteInput
    coachLinks?: AthleteCoachUncheckedUpdateManyWithoutCoachInput
    athleteLinks?: AthleteCoachUncheckedUpdateManyWithoutAthleteInput
    SentMessages?: MessageUncheckedUpdateManyWithoutSenderInput
    ReceivedMessages?: MessageUncheckedUpdateManyWithoutReceiverInput
    workoutSessions?: WorkoutSessionUncheckedUpdateManyWithoutAthleteInput
  }

  export type WorkoutPlanExerciseUpsertWithWhereUniqueWithoutPlanInput = {
    where: WorkoutPlanExerciseWhereUniqueInput
    update: XOR<WorkoutPlanExerciseUpdateWithoutPlanInput, WorkoutPlanExerciseUncheckedUpdateWithoutPlanInput>
    create: XOR<WorkoutPlanExerciseCreateWithoutPlanInput, WorkoutPlanExerciseUncheckedCreateWithoutPlanInput>
  }

  export type WorkoutPlanExerciseUpdateWithWhereUniqueWithoutPlanInput = {
    where: WorkoutPlanExerciseWhereUniqueInput
    data: XOR<WorkoutPlanExerciseUpdateWithoutPlanInput, WorkoutPlanExerciseUncheckedUpdateWithoutPlanInput>
  }

  export type WorkoutPlanExerciseUpdateManyWithWhereWithoutPlanInput = {
    where: WorkoutPlanExerciseScalarWhereInput
    data: XOR<WorkoutPlanExerciseUpdateManyMutationInput, WorkoutPlanExerciseUncheckedUpdateManyWithoutExercisesInput>
  }

  export type WorkoutPlanExerciseScalarWhereInput = {
    AND?: Enumerable<WorkoutPlanExerciseScalarWhereInput>
    OR?: Enumerable<WorkoutPlanExerciseScalarWhereInput>
    NOT?: Enumerable<WorkoutPlanExerciseScalarWhereInput>
    id?: IntFilter | number
    planId?: IntFilter | number
    exerciseId?: IntFilter | number
    orderIndex?: IntFilter | number
  }

  export type WorkoutSessionUpsertWithWhereUniqueWithoutPlanInput = {
    where: WorkoutSessionWhereUniqueInput
    update: XOR<WorkoutSessionUpdateWithoutPlanInput, WorkoutSessionUncheckedUpdateWithoutPlanInput>
    create: XOR<WorkoutSessionCreateWithoutPlanInput, WorkoutSessionUncheckedCreateWithoutPlanInput>
  }

  export type WorkoutSessionUpdateWithWhereUniqueWithoutPlanInput = {
    where: WorkoutSessionWhereUniqueInput
    data: XOR<WorkoutSessionUpdateWithoutPlanInput, WorkoutSessionUncheckedUpdateWithoutPlanInput>
  }

  export type WorkoutSessionUpdateManyWithWhereWithoutPlanInput = {
    where: WorkoutSessionScalarWhereInput
    data: XOR<WorkoutSessionUpdateManyMutationInput, WorkoutSessionUncheckedUpdateManyWithoutSessionsInput>
  }

  export type WorkoutUpsertWithWhereUniqueWithoutWorkoutPlanInput = {
    where: WorkoutWhereUniqueInput
    update: XOR<WorkoutUpdateWithoutWorkoutPlanInput, WorkoutUncheckedUpdateWithoutWorkoutPlanInput>
    create: XOR<WorkoutCreateWithoutWorkoutPlanInput, WorkoutUncheckedCreateWithoutWorkoutPlanInput>
  }

  export type WorkoutUpdateWithWhereUniqueWithoutWorkoutPlanInput = {
    where: WorkoutWhereUniqueInput
    data: XOR<WorkoutUpdateWithoutWorkoutPlanInput, WorkoutUncheckedUpdateWithoutWorkoutPlanInput>
  }

  export type WorkoutUpdateManyWithWhereWithoutWorkoutPlanInput = {
    where: WorkoutScalarWhereInput
    data: XOR<WorkoutUpdateManyMutationInput, WorkoutUncheckedUpdateManyWithoutWorkoutsInput>
  }

  export type WorkoutExerciseCreateWithoutExerciseInput = {
    orderIndex?: number
    notes?: string | null
    workout: WorkoutCreateNestedOneWithoutWorkoutExercisesInput
    sets?: WorkoutSetCreateNestedManyWithoutWorkoutExerciseInput
  }

  export type WorkoutExerciseUncheckedCreateWithoutExerciseInput = {
    id?: number
    workoutId: number
    orderIndex?: number
    notes?: string | null
    sets?: WorkoutSetUncheckedCreateNestedManyWithoutWorkoutExerciseInput
  }

  export type WorkoutExerciseCreateOrConnectWithoutExerciseInput = {
    where: WorkoutExerciseWhereUniqueInput
    create: XOR<WorkoutExerciseCreateWithoutExerciseInput, WorkoutExerciseUncheckedCreateWithoutExerciseInput>
  }

  export type WorkoutExerciseCreateManyExerciseInputEnvelope = {
    data: Enumerable<WorkoutExerciseCreateManyExerciseInput>
    skipDuplicates?: boolean
  }

  export type WorkoutPlanExerciseCreateWithoutExerciseInput = {
    orderIndex?: number
    plan: WorkoutPlanCreateNestedOneWithoutExercisesInput
  }

  export type WorkoutPlanExerciseUncheckedCreateWithoutExerciseInput = {
    id?: number
    planId: number
    orderIndex?: number
  }

  export type WorkoutPlanExerciseCreateOrConnectWithoutExerciseInput = {
    where: WorkoutPlanExerciseWhereUniqueInput
    create: XOR<WorkoutPlanExerciseCreateWithoutExerciseInput, WorkoutPlanExerciseUncheckedCreateWithoutExerciseInput>
  }

  export type WorkoutPlanExerciseCreateManyExerciseInputEnvelope = {
    data: Enumerable<WorkoutPlanExerciseCreateManyExerciseInput>
    skipDuplicates?: boolean
  }

  export type WorkoutSessionExerciseCreateWithoutExerciseInput = {
    orderIndex?: number
    session: WorkoutSessionCreateNestedOneWithoutSessionExercisesInput
    sets?: WorkoutSessionSetCreateNestedManyWithoutSessionExerciseInput
  }

  export type WorkoutSessionExerciseUncheckedCreateWithoutExerciseInput = {
    id?: number
    sessionId: number
    orderIndex?: number
    sets?: WorkoutSessionSetUncheckedCreateNestedManyWithoutSessionExerciseInput
  }

  export type WorkoutSessionExerciseCreateOrConnectWithoutExerciseInput = {
    where: WorkoutSessionExerciseWhereUniqueInput
    create: XOR<WorkoutSessionExerciseCreateWithoutExerciseInput, WorkoutSessionExerciseUncheckedCreateWithoutExerciseInput>
  }

  export type WorkoutSessionExerciseCreateManyExerciseInputEnvelope = {
    data: Enumerable<WorkoutSessionExerciseCreateManyExerciseInput>
    skipDuplicates?: boolean
  }

  export type WorkoutExerciseUpsertWithWhereUniqueWithoutExerciseInput = {
    where: WorkoutExerciseWhereUniqueInput
    update: XOR<WorkoutExerciseUpdateWithoutExerciseInput, WorkoutExerciseUncheckedUpdateWithoutExerciseInput>
    create: XOR<WorkoutExerciseCreateWithoutExerciseInput, WorkoutExerciseUncheckedCreateWithoutExerciseInput>
  }

  export type WorkoutExerciseUpdateWithWhereUniqueWithoutExerciseInput = {
    where: WorkoutExerciseWhereUniqueInput
    data: XOR<WorkoutExerciseUpdateWithoutExerciseInput, WorkoutExerciseUncheckedUpdateWithoutExerciseInput>
  }

  export type WorkoutExerciseUpdateManyWithWhereWithoutExerciseInput = {
    where: WorkoutExerciseScalarWhereInput
    data: XOR<WorkoutExerciseUpdateManyMutationInput, WorkoutExerciseUncheckedUpdateManyWithoutWorkoutExercisesInput>
  }

  export type WorkoutExerciseScalarWhereInput = {
    AND?: Enumerable<WorkoutExerciseScalarWhereInput>
    OR?: Enumerable<WorkoutExerciseScalarWhereInput>
    NOT?: Enumerable<WorkoutExerciseScalarWhereInput>
    id?: IntFilter | number
    workoutId?: IntFilter | number
    exerciseId?: IntFilter | number
    orderIndex?: IntFilter | number
    notes?: StringNullableFilter | string | null
  }

  export type WorkoutPlanExerciseUpsertWithWhereUniqueWithoutExerciseInput = {
    where: WorkoutPlanExerciseWhereUniqueInput
    update: XOR<WorkoutPlanExerciseUpdateWithoutExerciseInput, WorkoutPlanExerciseUncheckedUpdateWithoutExerciseInput>
    create: XOR<WorkoutPlanExerciseCreateWithoutExerciseInput, WorkoutPlanExerciseUncheckedCreateWithoutExerciseInput>
  }

  export type WorkoutPlanExerciseUpdateWithWhereUniqueWithoutExerciseInput = {
    where: WorkoutPlanExerciseWhereUniqueInput
    data: XOR<WorkoutPlanExerciseUpdateWithoutExerciseInput, WorkoutPlanExerciseUncheckedUpdateWithoutExerciseInput>
  }

  export type WorkoutPlanExerciseUpdateManyWithWhereWithoutExerciseInput = {
    where: WorkoutPlanExerciseScalarWhereInput
    data: XOR<WorkoutPlanExerciseUpdateManyMutationInput, WorkoutPlanExerciseUncheckedUpdateManyWithoutPlanExercisesInput>
  }

  export type WorkoutSessionExerciseUpsertWithWhereUniqueWithoutExerciseInput = {
    where: WorkoutSessionExerciseWhereUniqueInput
    update: XOR<WorkoutSessionExerciseUpdateWithoutExerciseInput, WorkoutSessionExerciseUncheckedUpdateWithoutExerciseInput>
    create: XOR<WorkoutSessionExerciseCreateWithoutExerciseInput, WorkoutSessionExerciseUncheckedCreateWithoutExerciseInput>
  }

  export type WorkoutSessionExerciseUpdateWithWhereUniqueWithoutExerciseInput = {
    where: WorkoutSessionExerciseWhereUniqueInput
    data: XOR<WorkoutSessionExerciseUpdateWithoutExerciseInput, WorkoutSessionExerciseUncheckedUpdateWithoutExerciseInput>
  }

  export type WorkoutSessionExerciseUpdateManyWithWhereWithoutExerciseInput = {
    where: WorkoutSessionExerciseScalarWhereInput
    data: XOR<WorkoutSessionExerciseUpdateManyMutationInput, WorkoutSessionExerciseUncheckedUpdateManyWithoutSessionExercisesInput>
  }

  export type WorkoutSessionExerciseScalarWhereInput = {
    AND?: Enumerable<WorkoutSessionExerciseScalarWhereInput>
    OR?: Enumerable<WorkoutSessionExerciseScalarWhereInput>
    NOT?: Enumerable<WorkoutSessionExerciseScalarWhereInput>
    id?: IntFilter | number
    sessionId?: IntFilter | number
    exerciseId?: IntFilter | number
    orderIndex?: IntFilter | number
  }

  export type WorkoutPlanCreateWithoutExercisesInput = {
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedWorkoutPlansInput
    assignedTo?: UserCreateNestedOneWithoutAssignedWorkoutPlansInput
    sessions?: WorkoutSessionCreateNestedManyWithoutPlanInput
    workouts?: WorkoutCreateNestedManyWithoutWorkoutPlanInput
  }

  export type WorkoutPlanUncheckedCreateWithoutExercisesInput = {
    id?: number
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: number
    assignedToId?: number | null
    sessions?: WorkoutSessionUncheckedCreateNestedManyWithoutPlanInput
    workouts?: WorkoutUncheckedCreateNestedManyWithoutWorkoutPlanInput
  }

  export type WorkoutPlanCreateOrConnectWithoutExercisesInput = {
    where: WorkoutPlanWhereUniqueInput
    create: XOR<WorkoutPlanCreateWithoutExercisesInput, WorkoutPlanUncheckedCreateWithoutExercisesInput>
  }

  export type ExerciseCreateWithoutPlanExercisesInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    workoutExercises?: WorkoutExerciseCreateNestedManyWithoutExerciseInput
    sessionExercises?: WorkoutSessionExerciseCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseUncheckedCreateWithoutPlanExercisesInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    workoutExercises?: WorkoutExerciseUncheckedCreateNestedManyWithoutExerciseInput
    sessionExercises?: WorkoutSessionExerciseUncheckedCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseCreateOrConnectWithoutPlanExercisesInput = {
    where: ExerciseWhereUniqueInput
    create: XOR<ExerciseCreateWithoutPlanExercisesInput, ExerciseUncheckedCreateWithoutPlanExercisesInput>
  }

  export type WorkoutPlanUpsertWithoutExercisesInput = {
    update: XOR<WorkoutPlanUpdateWithoutExercisesInput, WorkoutPlanUncheckedUpdateWithoutExercisesInput>
    create: XOR<WorkoutPlanCreateWithoutExercisesInput, WorkoutPlanUncheckedCreateWithoutExercisesInput>
  }

  export type WorkoutPlanUpdateWithoutExercisesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedWorkoutPlansInput
    assignedTo?: UserUpdateOneWithoutAssignedWorkoutPlansInput
    sessions?: WorkoutSessionUpdateManyWithoutPlanInput
    workouts?: WorkoutUpdateManyWithoutWorkoutPlanInput
  }

  export type WorkoutPlanUncheckedUpdateWithoutExercisesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    sessions?: WorkoutSessionUncheckedUpdateManyWithoutPlanInput
    workouts?: WorkoutUncheckedUpdateManyWithoutWorkoutPlanInput
  }

  export type ExerciseUpsertWithoutPlanExercisesInput = {
    update: XOR<ExerciseUpdateWithoutPlanExercisesInput, ExerciseUncheckedUpdateWithoutPlanExercisesInput>
    create: XOR<ExerciseCreateWithoutPlanExercisesInput, ExerciseUncheckedCreateWithoutPlanExercisesInput>
  }

  export type ExerciseUpdateWithoutPlanExercisesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workoutExercises?: WorkoutExerciseUpdateManyWithoutExerciseInput
    sessionExercises?: WorkoutSessionExerciseUpdateManyWithoutExerciseInput
  }

  export type ExerciseUncheckedUpdateWithoutPlanExercisesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workoutExercises?: WorkoutExerciseUncheckedUpdateManyWithoutExerciseInput
    sessionExercises?: WorkoutSessionExerciseUncheckedUpdateManyWithoutExerciseInput
  }

  export type UserCreateWithoutWorkoutSessionsInput = {
    email: string
    passwordHash: string
    fullName: string
    role: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    createdWorkoutPlans?: WorkoutPlanCreateNestedManyWithoutCreatorInput
    assignedWorkoutPlans?: WorkoutPlanCreateNestedManyWithoutAssignedToInput
    workouts?: WorkoutCreateNestedManyWithoutAthleteInput
    weights?: WeightCreateNestedManyWithoutAthleteInput
    coachLinks?: AthleteCoachCreateNestedManyWithoutCoachInput
    athleteLinks?: AthleteCoachCreateNestedManyWithoutAthleteInput
    SentMessages?: MessageCreateNestedManyWithoutSenderInput
    ReceivedMessages?: MessageCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutWorkoutSessionsInput = {
    id?: number
    email: string
    passwordHash: string
    fullName: string
    role: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    createdWorkoutPlans?: WorkoutPlanUncheckedCreateNestedManyWithoutCreatorInput
    assignedWorkoutPlans?: WorkoutPlanUncheckedCreateNestedManyWithoutAssignedToInput
    workouts?: WorkoutUncheckedCreateNestedManyWithoutAthleteInput
    weights?: WeightUncheckedCreateNestedManyWithoutAthleteInput
    coachLinks?: AthleteCoachUncheckedCreateNestedManyWithoutCoachInput
    athleteLinks?: AthleteCoachUncheckedCreateNestedManyWithoutAthleteInput
    SentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    ReceivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutWorkoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWorkoutSessionsInput, UserUncheckedCreateWithoutWorkoutSessionsInput>
  }

  export type WorkoutPlanCreateWithoutSessionsInput = {
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedWorkoutPlansInput
    assignedTo?: UserCreateNestedOneWithoutAssignedWorkoutPlansInput
    exercises?: WorkoutPlanExerciseCreateNestedManyWithoutPlanInput
    workouts?: WorkoutCreateNestedManyWithoutWorkoutPlanInput
  }

  export type WorkoutPlanUncheckedCreateWithoutSessionsInput = {
    id?: number
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: number
    assignedToId?: number | null
    exercises?: WorkoutPlanExerciseUncheckedCreateNestedManyWithoutPlanInput
    workouts?: WorkoutUncheckedCreateNestedManyWithoutWorkoutPlanInput
  }

  export type WorkoutPlanCreateOrConnectWithoutSessionsInput = {
    where: WorkoutPlanWhereUniqueInput
    create: XOR<WorkoutPlanCreateWithoutSessionsInput, WorkoutPlanUncheckedCreateWithoutSessionsInput>
  }

  export type WorkoutSessionExerciseCreateWithoutSessionInput = {
    orderIndex?: number
    exercise: ExerciseCreateNestedOneWithoutSessionExercisesInput
    sets?: WorkoutSessionSetCreateNestedManyWithoutSessionExerciseInput
  }

  export type WorkoutSessionExerciseUncheckedCreateWithoutSessionInput = {
    id?: number
    exerciseId: number
    orderIndex?: number
    sets?: WorkoutSessionSetUncheckedCreateNestedManyWithoutSessionExerciseInput
  }

  export type WorkoutSessionExerciseCreateOrConnectWithoutSessionInput = {
    where: WorkoutSessionExerciseWhereUniqueInput
    create: XOR<WorkoutSessionExerciseCreateWithoutSessionInput, WorkoutSessionExerciseUncheckedCreateWithoutSessionInput>
  }

  export type WorkoutSessionExerciseCreateManySessionInputEnvelope = {
    data: Enumerable<WorkoutSessionExerciseCreateManySessionInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutWorkoutSessionsInput = {
    update: XOR<UserUpdateWithoutWorkoutSessionsInput, UserUncheckedUpdateWithoutWorkoutSessionsInput>
    create: XOR<UserCreateWithoutWorkoutSessionsInput, UserUncheckedCreateWithoutWorkoutSessionsInput>
  }

  export type UserUpdateWithoutWorkoutSessionsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdWorkoutPlans?: WorkoutPlanUpdateManyWithoutCreatorInput
    assignedWorkoutPlans?: WorkoutPlanUpdateManyWithoutAssignedToInput
    workouts?: WorkoutUpdateManyWithoutAthleteInput
    weights?: WeightUpdateManyWithoutAthleteInput
    coachLinks?: AthleteCoachUpdateManyWithoutCoachInput
    athleteLinks?: AthleteCoachUpdateManyWithoutAthleteInput
    SentMessages?: MessageUpdateManyWithoutSenderInput
    ReceivedMessages?: MessageUpdateManyWithoutReceiverInput
  }

  export type UserUncheckedUpdateWithoutWorkoutSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdWorkoutPlans?: WorkoutPlanUncheckedUpdateManyWithoutCreatorInput
    assignedWorkoutPlans?: WorkoutPlanUncheckedUpdateManyWithoutAssignedToInput
    workouts?: WorkoutUncheckedUpdateManyWithoutAthleteInput
    weights?: WeightUncheckedUpdateManyWithoutAthleteInput
    coachLinks?: AthleteCoachUncheckedUpdateManyWithoutCoachInput
    athleteLinks?: AthleteCoachUncheckedUpdateManyWithoutAthleteInput
    SentMessages?: MessageUncheckedUpdateManyWithoutSenderInput
    ReceivedMessages?: MessageUncheckedUpdateManyWithoutReceiverInput
  }

  export type WorkoutPlanUpsertWithoutSessionsInput = {
    update: XOR<WorkoutPlanUpdateWithoutSessionsInput, WorkoutPlanUncheckedUpdateWithoutSessionsInput>
    create: XOR<WorkoutPlanCreateWithoutSessionsInput, WorkoutPlanUncheckedCreateWithoutSessionsInput>
  }

  export type WorkoutPlanUpdateWithoutSessionsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedWorkoutPlansInput
    assignedTo?: UserUpdateOneWithoutAssignedWorkoutPlansInput
    exercises?: WorkoutPlanExerciseUpdateManyWithoutPlanInput
    workouts?: WorkoutUpdateManyWithoutWorkoutPlanInput
  }

  export type WorkoutPlanUncheckedUpdateWithoutSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    exercises?: WorkoutPlanExerciseUncheckedUpdateManyWithoutPlanInput
    workouts?: WorkoutUncheckedUpdateManyWithoutWorkoutPlanInput
  }

  export type WorkoutSessionExerciseUpsertWithWhereUniqueWithoutSessionInput = {
    where: WorkoutSessionExerciseWhereUniqueInput
    update: XOR<WorkoutSessionExerciseUpdateWithoutSessionInput, WorkoutSessionExerciseUncheckedUpdateWithoutSessionInput>
    create: XOR<WorkoutSessionExerciseCreateWithoutSessionInput, WorkoutSessionExerciseUncheckedCreateWithoutSessionInput>
  }

  export type WorkoutSessionExerciseUpdateWithWhereUniqueWithoutSessionInput = {
    where: WorkoutSessionExerciseWhereUniqueInput
    data: XOR<WorkoutSessionExerciseUpdateWithoutSessionInput, WorkoutSessionExerciseUncheckedUpdateWithoutSessionInput>
  }

  export type WorkoutSessionExerciseUpdateManyWithWhereWithoutSessionInput = {
    where: WorkoutSessionExerciseScalarWhereInput
    data: XOR<WorkoutSessionExerciseUpdateManyMutationInput, WorkoutSessionExerciseUncheckedUpdateManyWithoutSessionExercisesInput>
  }

  export type WorkoutSessionCreateWithoutSessionExercisesInput = {
    date?: Date | string
    athlete: UserCreateNestedOneWithoutWorkoutSessionsInput
    plan: WorkoutPlanCreateNestedOneWithoutSessionsInput
  }

  export type WorkoutSessionUncheckedCreateWithoutSessionExercisesInput = {
    id?: number
    athleteId: number
    planId: number
    date?: Date | string
  }

  export type WorkoutSessionCreateOrConnectWithoutSessionExercisesInput = {
    where: WorkoutSessionWhereUniqueInput
    create: XOR<WorkoutSessionCreateWithoutSessionExercisesInput, WorkoutSessionUncheckedCreateWithoutSessionExercisesInput>
  }

  export type ExerciseCreateWithoutSessionExercisesInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    workoutExercises?: WorkoutExerciseCreateNestedManyWithoutExerciseInput
    planExercises?: WorkoutPlanExerciseCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseUncheckedCreateWithoutSessionExercisesInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    workoutExercises?: WorkoutExerciseUncheckedCreateNestedManyWithoutExerciseInput
    planExercises?: WorkoutPlanExerciseUncheckedCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseCreateOrConnectWithoutSessionExercisesInput = {
    where: ExerciseWhereUniqueInput
    create: XOR<ExerciseCreateWithoutSessionExercisesInput, ExerciseUncheckedCreateWithoutSessionExercisesInput>
  }

  export type WorkoutSessionSetCreateWithoutSessionExerciseInput = {
    setIndex?: number
    reps: number
    weightKg: number
    rpe?: number | null
    notes?: string | null
  }

  export type WorkoutSessionSetUncheckedCreateWithoutSessionExerciseInput = {
    id?: number
    setIndex?: number
    reps: number
    weightKg: number
    rpe?: number | null
    notes?: string | null
  }

  export type WorkoutSessionSetCreateOrConnectWithoutSessionExerciseInput = {
    where: WorkoutSessionSetWhereUniqueInput
    create: XOR<WorkoutSessionSetCreateWithoutSessionExerciseInput, WorkoutSessionSetUncheckedCreateWithoutSessionExerciseInput>
  }

  export type WorkoutSessionSetCreateManySessionExerciseInputEnvelope = {
    data: Enumerable<WorkoutSessionSetCreateManySessionExerciseInput>
    skipDuplicates?: boolean
  }

  export type WorkoutSessionUpsertWithoutSessionExercisesInput = {
    update: XOR<WorkoutSessionUpdateWithoutSessionExercisesInput, WorkoutSessionUncheckedUpdateWithoutSessionExercisesInput>
    create: XOR<WorkoutSessionCreateWithoutSessionExercisesInput, WorkoutSessionUncheckedCreateWithoutSessionExercisesInput>
  }

  export type WorkoutSessionUpdateWithoutSessionExercisesInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    athlete?: UserUpdateOneRequiredWithoutWorkoutSessionsInput
    plan?: WorkoutPlanUpdateOneRequiredWithoutSessionsInput
  }

  export type WorkoutSessionUncheckedUpdateWithoutSessionExercisesInput = {
    id?: IntFieldUpdateOperationsInput | number
    athleteId?: IntFieldUpdateOperationsInput | number
    planId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseUpsertWithoutSessionExercisesInput = {
    update: XOR<ExerciseUpdateWithoutSessionExercisesInput, ExerciseUncheckedUpdateWithoutSessionExercisesInput>
    create: XOR<ExerciseCreateWithoutSessionExercisesInput, ExerciseUncheckedCreateWithoutSessionExercisesInput>
  }

  export type ExerciseUpdateWithoutSessionExercisesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workoutExercises?: WorkoutExerciseUpdateManyWithoutExerciseInput
    planExercises?: WorkoutPlanExerciseUpdateManyWithoutExerciseInput
  }

  export type ExerciseUncheckedUpdateWithoutSessionExercisesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workoutExercises?: WorkoutExerciseUncheckedUpdateManyWithoutExerciseInput
    planExercises?: WorkoutPlanExerciseUncheckedUpdateManyWithoutExerciseInput
  }

  export type WorkoutSessionSetUpsertWithWhereUniqueWithoutSessionExerciseInput = {
    where: WorkoutSessionSetWhereUniqueInput
    update: XOR<WorkoutSessionSetUpdateWithoutSessionExerciseInput, WorkoutSessionSetUncheckedUpdateWithoutSessionExerciseInput>
    create: XOR<WorkoutSessionSetCreateWithoutSessionExerciseInput, WorkoutSessionSetUncheckedCreateWithoutSessionExerciseInput>
  }

  export type WorkoutSessionSetUpdateWithWhereUniqueWithoutSessionExerciseInput = {
    where: WorkoutSessionSetWhereUniqueInput
    data: XOR<WorkoutSessionSetUpdateWithoutSessionExerciseInput, WorkoutSessionSetUncheckedUpdateWithoutSessionExerciseInput>
  }

  export type WorkoutSessionSetUpdateManyWithWhereWithoutSessionExerciseInput = {
    where: WorkoutSessionSetScalarWhereInput
    data: XOR<WorkoutSessionSetUpdateManyMutationInput, WorkoutSessionSetUncheckedUpdateManyWithoutSetsInput>
  }

  export type WorkoutSessionSetScalarWhereInput = {
    AND?: Enumerable<WorkoutSessionSetScalarWhereInput>
    OR?: Enumerable<WorkoutSessionSetScalarWhereInput>
    NOT?: Enumerable<WorkoutSessionSetScalarWhereInput>
    id?: IntFilter | number
    sessionExerciseId?: IntFilter | number
    setIndex?: IntFilter | number
    reps?: IntFilter | number
    weightKg?: FloatFilter | number
    rpe?: FloatNullableFilter | number | null
    notes?: StringNullableFilter | string | null
  }

  export type WorkoutSessionExerciseCreateWithoutSetsInput = {
    orderIndex?: number
    session: WorkoutSessionCreateNestedOneWithoutSessionExercisesInput
    exercise: ExerciseCreateNestedOneWithoutSessionExercisesInput
  }

  export type WorkoutSessionExerciseUncheckedCreateWithoutSetsInput = {
    id?: number
    sessionId: number
    exerciseId: number
    orderIndex?: number
  }

  export type WorkoutSessionExerciseCreateOrConnectWithoutSetsInput = {
    where: WorkoutSessionExerciseWhereUniqueInput
    create: XOR<WorkoutSessionExerciseCreateWithoutSetsInput, WorkoutSessionExerciseUncheckedCreateWithoutSetsInput>
  }

  export type WorkoutSessionExerciseUpsertWithoutSetsInput = {
    update: XOR<WorkoutSessionExerciseUpdateWithoutSetsInput, WorkoutSessionExerciseUncheckedUpdateWithoutSetsInput>
    create: XOR<WorkoutSessionExerciseCreateWithoutSetsInput, WorkoutSessionExerciseUncheckedCreateWithoutSetsInput>
  }

  export type WorkoutSessionExerciseUpdateWithoutSetsInput = {
    orderIndex?: IntFieldUpdateOperationsInput | number
    session?: WorkoutSessionUpdateOneRequiredWithoutSessionExercisesInput
    exercise?: ExerciseUpdateOneRequiredWithoutSessionExercisesInput
  }

  export type WorkoutSessionExerciseUncheckedUpdateWithoutSetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: IntFieldUpdateOperationsInput | number
    exerciseId?: IntFieldUpdateOperationsInput | number
    orderIndex?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateWithoutWorkoutsInput = {
    email: string
    passwordHash: string
    fullName: string
    role: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    createdWorkoutPlans?: WorkoutPlanCreateNestedManyWithoutCreatorInput
    assignedWorkoutPlans?: WorkoutPlanCreateNestedManyWithoutAssignedToInput
    weights?: WeightCreateNestedManyWithoutAthleteInput
    coachLinks?: AthleteCoachCreateNestedManyWithoutCoachInput
    athleteLinks?: AthleteCoachCreateNestedManyWithoutAthleteInput
    SentMessages?: MessageCreateNestedManyWithoutSenderInput
    ReceivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    workoutSessions?: WorkoutSessionCreateNestedManyWithoutAthleteInput
  }

  export type UserUncheckedCreateWithoutWorkoutsInput = {
    id?: number
    email: string
    passwordHash: string
    fullName: string
    role: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    createdWorkoutPlans?: WorkoutPlanUncheckedCreateNestedManyWithoutCreatorInput
    assignedWorkoutPlans?: WorkoutPlanUncheckedCreateNestedManyWithoutAssignedToInput
    weights?: WeightUncheckedCreateNestedManyWithoutAthleteInput
    coachLinks?: AthleteCoachUncheckedCreateNestedManyWithoutCoachInput
    athleteLinks?: AthleteCoachUncheckedCreateNestedManyWithoutAthleteInput
    SentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    ReceivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    workoutSessions?: WorkoutSessionUncheckedCreateNestedManyWithoutAthleteInput
  }

  export type UserCreateOrConnectWithoutWorkoutsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWorkoutsInput, UserUncheckedCreateWithoutWorkoutsInput>
  }

  export type WorkoutPlanCreateWithoutWorkoutsInput = {
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedWorkoutPlansInput
    assignedTo?: UserCreateNestedOneWithoutAssignedWorkoutPlansInput
    exercises?: WorkoutPlanExerciseCreateNestedManyWithoutPlanInput
    sessions?: WorkoutSessionCreateNestedManyWithoutPlanInput
  }

  export type WorkoutPlanUncheckedCreateWithoutWorkoutsInput = {
    id?: number
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: number
    assignedToId?: number | null
    exercises?: WorkoutPlanExerciseUncheckedCreateNestedManyWithoutPlanInput
    sessions?: WorkoutSessionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type WorkoutPlanCreateOrConnectWithoutWorkoutsInput = {
    where: WorkoutPlanWhereUniqueInput
    create: XOR<WorkoutPlanCreateWithoutWorkoutsInput, WorkoutPlanUncheckedCreateWithoutWorkoutsInput>
  }

  export type WorkoutExerciseCreateWithoutWorkoutInput = {
    orderIndex?: number
    notes?: string | null
    exercise: ExerciseCreateNestedOneWithoutWorkoutExercisesInput
    sets?: WorkoutSetCreateNestedManyWithoutWorkoutExerciseInput
  }

  export type WorkoutExerciseUncheckedCreateWithoutWorkoutInput = {
    id?: number
    exerciseId: number
    orderIndex?: number
    notes?: string | null
    sets?: WorkoutSetUncheckedCreateNestedManyWithoutWorkoutExerciseInput
  }

  export type WorkoutExerciseCreateOrConnectWithoutWorkoutInput = {
    where: WorkoutExerciseWhereUniqueInput
    create: XOR<WorkoutExerciseCreateWithoutWorkoutInput, WorkoutExerciseUncheckedCreateWithoutWorkoutInput>
  }

  export type WorkoutExerciseCreateManyWorkoutInputEnvelope = {
    data: Enumerable<WorkoutExerciseCreateManyWorkoutInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutWorkoutsInput = {
    update: XOR<UserUpdateWithoutWorkoutsInput, UserUncheckedUpdateWithoutWorkoutsInput>
    create: XOR<UserCreateWithoutWorkoutsInput, UserUncheckedCreateWithoutWorkoutsInput>
  }

  export type UserUpdateWithoutWorkoutsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdWorkoutPlans?: WorkoutPlanUpdateManyWithoutCreatorInput
    assignedWorkoutPlans?: WorkoutPlanUpdateManyWithoutAssignedToInput
    weights?: WeightUpdateManyWithoutAthleteInput
    coachLinks?: AthleteCoachUpdateManyWithoutCoachInput
    athleteLinks?: AthleteCoachUpdateManyWithoutAthleteInput
    SentMessages?: MessageUpdateManyWithoutSenderInput
    ReceivedMessages?: MessageUpdateManyWithoutReceiverInput
    workoutSessions?: WorkoutSessionUpdateManyWithoutAthleteInput
  }

  export type UserUncheckedUpdateWithoutWorkoutsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdWorkoutPlans?: WorkoutPlanUncheckedUpdateManyWithoutCreatorInput
    assignedWorkoutPlans?: WorkoutPlanUncheckedUpdateManyWithoutAssignedToInput
    weights?: WeightUncheckedUpdateManyWithoutAthleteInput
    coachLinks?: AthleteCoachUncheckedUpdateManyWithoutCoachInput
    athleteLinks?: AthleteCoachUncheckedUpdateManyWithoutAthleteInput
    SentMessages?: MessageUncheckedUpdateManyWithoutSenderInput
    ReceivedMessages?: MessageUncheckedUpdateManyWithoutReceiverInput
    workoutSessions?: WorkoutSessionUncheckedUpdateManyWithoutAthleteInput
  }

  export type WorkoutPlanUpsertWithoutWorkoutsInput = {
    update: XOR<WorkoutPlanUpdateWithoutWorkoutsInput, WorkoutPlanUncheckedUpdateWithoutWorkoutsInput>
    create: XOR<WorkoutPlanCreateWithoutWorkoutsInput, WorkoutPlanUncheckedCreateWithoutWorkoutsInput>
  }

  export type WorkoutPlanUpdateWithoutWorkoutsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedWorkoutPlansInput
    assignedTo?: UserUpdateOneWithoutAssignedWorkoutPlansInput
    exercises?: WorkoutPlanExerciseUpdateManyWithoutPlanInput
    sessions?: WorkoutSessionUpdateManyWithoutPlanInput
  }

  export type WorkoutPlanUncheckedUpdateWithoutWorkoutsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    exercises?: WorkoutPlanExerciseUncheckedUpdateManyWithoutPlanInput
    sessions?: WorkoutSessionUncheckedUpdateManyWithoutPlanInput
  }

  export type WorkoutExerciseUpsertWithWhereUniqueWithoutWorkoutInput = {
    where: WorkoutExerciseWhereUniqueInput
    update: XOR<WorkoutExerciseUpdateWithoutWorkoutInput, WorkoutExerciseUncheckedUpdateWithoutWorkoutInput>
    create: XOR<WorkoutExerciseCreateWithoutWorkoutInput, WorkoutExerciseUncheckedCreateWithoutWorkoutInput>
  }

  export type WorkoutExerciseUpdateWithWhereUniqueWithoutWorkoutInput = {
    where: WorkoutExerciseWhereUniqueInput
    data: XOR<WorkoutExerciseUpdateWithoutWorkoutInput, WorkoutExerciseUncheckedUpdateWithoutWorkoutInput>
  }

  export type WorkoutExerciseUpdateManyWithWhereWithoutWorkoutInput = {
    where: WorkoutExerciseScalarWhereInput
    data: XOR<WorkoutExerciseUpdateManyMutationInput, WorkoutExerciseUncheckedUpdateManyWithoutWorkoutExercisesInput>
  }

  export type WorkoutCreateWithoutWorkoutExercisesInput = {
    date: Date | string
    durationMinutes: number
    notes?: string | null
    createdAt?: Date | string
    athlete: UserCreateNestedOneWithoutWorkoutsInput
    workoutPlan?: WorkoutPlanCreateNestedOneWithoutWorkoutsInput
  }

  export type WorkoutUncheckedCreateWithoutWorkoutExercisesInput = {
    id?: number
    date: Date | string
    durationMinutes: number
    notes?: string | null
    createdAt?: Date | string
    athleteId: number
    workoutPlanId?: number | null
  }

  export type WorkoutCreateOrConnectWithoutWorkoutExercisesInput = {
    where: WorkoutWhereUniqueInput
    create: XOR<WorkoutCreateWithoutWorkoutExercisesInput, WorkoutUncheckedCreateWithoutWorkoutExercisesInput>
  }

  export type ExerciseCreateWithoutWorkoutExercisesInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    planExercises?: WorkoutPlanExerciseCreateNestedManyWithoutExerciseInput
    sessionExercises?: WorkoutSessionExerciseCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseUncheckedCreateWithoutWorkoutExercisesInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    planExercises?: WorkoutPlanExerciseUncheckedCreateNestedManyWithoutExerciseInput
    sessionExercises?: WorkoutSessionExerciseUncheckedCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseCreateOrConnectWithoutWorkoutExercisesInput = {
    where: ExerciseWhereUniqueInput
    create: XOR<ExerciseCreateWithoutWorkoutExercisesInput, ExerciseUncheckedCreateWithoutWorkoutExercisesInput>
  }

  export type WorkoutSetCreateWithoutWorkoutExerciseInput = {
    setIndex?: number
    reps: number
    weightKg: number
    rpe?: number | null
    notes?: string | null
  }

  export type WorkoutSetUncheckedCreateWithoutWorkoutExerciseInput = {
    id?: number
    setIndex?: number
    reps: number
    weightKg: number
    rpe?: number | null
    notes?: string | null
  }

  export type WorkoutSetCreateOrConnectWithoutWorkoutExerciseInput = {
    where: WorkoutSetWhereUniqueInput
    create: XOR<WorkoutSetCreateWithoutWorkoutExerciseInput, WorkoutSetUncheckedCreateWithoutWorkoutExerciseInput>
  }

  export type WorkoutSetCreateManyWorkoutExerciseInputEnvelope = {
    data: Enumerable<WorkoutSetCreateManyWorkoutExerciseInput>
    skipDuplicates?: boolean
  }

  export type WorkoutUpsertWithoutWorkoutExercisesInput = {
    update: XOR<WorkoutUpdateWithoutWorkoutExercisesInput, WorkoutUncheckedUpdateWithoutWorkoutExercisesInput>
    create: XOR<WorkoutCreateWithoutWorkoutExercisesInput, WorkoutUncheckedCreateWithoutWorkoutExercisesInput>
  }

  export type WorkoutUpdateWithoutWorkoutExercisesInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    athlete?: UserUpdateOneRequiredWithoutWorkoutsInput
    workoutPlan?: WorkoutPlanUpdateOneWithoutWorkoutsInput
  }

  export type WorkoutUncheckedUpdateWithoutWorkoutExercisesInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    athleteId?: IntFieldUpdateOperationsInput | number
    workoutPlanId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ExerciseUpsertWithoutWorkoutExercisesInput = {
    update: XOR<ExerciseUpdateWithoutWorkoutExercisesInput, ExerciseUncheckedUpdateWithoutWorkoutExercisesInput>
    create: XOR<ExerciseCreateWithoutWorkoutExercisesInput, ExerciseUncheckedCreateWithoutWorkoutExercisesInput>
  }

  export type ExerciseUpdateWithoutWorkoutExercisesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planExercises?: WorkoutPlanExerciseUpdateManyWithoutExerciseInput
    sessionExercises?: WorkoutSessionExerciseUpdateManyWithoutExerciseInput
  }

  export type ExerciseUncheckedUpdateWithoutWorkoutExercisesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planExercises?: WorkoutPlanExerciseUncheckedUpdateManyWithoutExerciseInput
    sessionExercises?: WorkoutSessionExerciseUncheckedUpdateManyWithoutExerciseInput
  }

  export type WorkoutSetUpsertWithWhereUniqueWithoutWorkoutExerciseInput = {
    where: WorkoutSetWhereUniqueInput
    update: XOR<WorkoutSetUpdateWithoutWorkoutExerciseInput, WorkoutSetUncheckedUpdateWithoutWorkoutExerciseInput>
    create: XOR<WorkoutSetCreateWithoutWorkoutExerciseInput, WorkoutSetUncheckedCreateWithoutWorkoutExerciseInput>
  }

  export type WorkoutSetUpdateWithWhereUniqueWithoutWorkoutExerciseInput = {
    where: WorkoutSetWhereUniqueInput
    data: XOR<WorkoutSetUpdateWithoutWorkoutExerciseInput, WorkoutSetUncheckedUpdateWithoutWorkoutExerciseInput>
  }

  export type WorkoutSetUpdateManyWithWhereWithoutWorkoutExerciseInput = {
    where: WorkoutSetScalarWhereInput
    data: XOR<WorkoutSetUpdateManyMutationInput, WorkoutSetUncheckedUpdateManyWithoutSetsInput>
  }

  export type WorkoutSetScalarWhereInput = {
    AND?: Enumerable<WorkoutSetScalarWhereInput>
    OR?: Enumerable<WorkoutSetScalarWhereInput>
    NOT?: Enumerable<WorkoutSetScalarWhereInput>
    id?: IntFilter | number
    workoutExerciseId?: IntFilter | number
    setIndex?: IntFilter | number
    reps?: IntFilter | number
    weightKg?: FloatFilter | number
    rpe?: FloatNullableFilter | number | null
    notes?: StringNullableFilter | string | null
  }

  export type WorkoutExerciseCreateWithoutSetsInput = {
    orderIndex?: number
    notes?: string | null
    workout: WorkoutCreateNestedOneWithoutWorkoutExercisesInput
    exercise: ExerciseCreateNestedOneWithoutWorkoutExercisesInput
  }

  export type WorkoutExerciseUncheckedCreateWithoutSetsInput = {
    id?: number
    workoutId: number
    exerciseId: number
    orderIndex?: number
    notes?: string | null
  }

  export type WorkoutExerciseCreateOrConnectWithoutSetsInput = {
    where: WorkoutExerciseWhereUniqueInput
    create: XOR<WorkoutExerciseCreateWithoutSetsInput, WorkoutExerciseUncheckedCreateWithoutSetsInput>
  }

  export type WorkoutExerciseUpsertWithoutSetsInput = {
    update: XOR<WorkoutExerciseUpdateWithoutSetsInput, WorkoutExerciseUncheckedUpdateWithoutSetsInput>
    create: XOR<WorkoutExerciseCreateWithoutSetsInput, WorkoutExerciseUncheckedCreateWithoutSetsInput>
  }

  export type WorkoutExerciseUpdateWithoutSetsInput = {
    orderIndex?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    workout?: WorkoutUpdateOneRequiredWithoutWorkoutExercisesInput
    exercise?: ExerciseUpdateOneRequiredWithoutWorkoutExercisesInput
  }

  export type WorkoutExerciseUncheckedUpdateWithoutSetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    workoutId?: IntFieldUpdateOperationsInput | number
    exerciseId?: IntFieldUpdateOperationsInput | number
    orderIndex?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateWithoutWeightsInput = {
    email: string
    passwordHash: string
    fullName: string
    role: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    createdWorkoutPlans?: WorkoutPlanCreateNestedManyWithoutCreatorInput
    assignedWorkoutPlans?: WorkoutPlanCreateNestedManyWithoutAssignedToInput
    workouts?: WorkoutCreateNestedManyWithoutAthleteInput
    coachLinks?: AthleteCoachCreateNestedManyWithoutCoachInput
    athleteLinks?: AthleteCoachCreateNestedManyWithoutAthleteInput
    SentMessages?: MessageCreateNestedManyWithoutSenderInput
    ReceivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    workoutSessions?: WorkoutSessionCreateNestedManyWithoutAthleteInput
  }

  export type UserUncheckedCreateWithoutWeightsInput = {
    id?: number
    email: string
    passwordHash: string
    fullName: string
    role: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    createdWorkoutPlans?: WorkoutPlanUncheckedCreateNestedManyWithoutCreatorInput
    assignedWorkoutPlans?: WorkoutPlanUncheckedCreateNestedManyWithoutAssignedToInput
    workouts?: WorkoutUncheckedCreateNestedManyWithoutAthleteInput
    coachLinks?: AthleteCoachUncheckedCreateNestedManyWithoutCoachInput
    athleteLinks?: AthleteCoachUncheckedCreateNestedManyWithoutAthleteInput
    SentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    ReceivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    workoutSessions?: WorkoutSessionUncheckedCreateNestedManyWithoutAthleteInput
  }

  export type UserCreateOrConnectWithoutWeightsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWeightsInput, UserUncheckedCreateWithoutWeightsInput>
  }

  export type UserUpsertWithoutWeightsInput = {
    update: XOR<UserUpdateWithoutWeightsInput, UserUncheckedUpdateWithoutWeightsInput>
    create: XOR<UserCreateWithoutWeightsInput, UserUncheckedCreateWithoutWeightsInput>
  }

  export type UserUpdateWithoutWeightsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdWorkoutPlans?: WorkoutPlanUpdateManyWithoutCreatorInput
    assignedWorkoutPlans?: WorkoutPlanUpdateManyWithoutAssignedToInput
    workouts?: WorkoutUpdateManyWithoutAthleteInput
    coachLinks?: AthleteCoachUpdateManyWithoutCoachInput
    athleteLinks?: AthleteCoachUpdateManyWithoutAthleteInput
    SentMessages?: MessageUpdateManyWithoutSenderInput
    ReceivedMessages?: MessageUpdateManyWithoutReceiverInput
    workoutSessions?: WorkoutSessionUpdateManyWithoutAthleteInput
  }

  export type UserUncheckedUpdateWithoutWeightsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdWorkoutPlans?: WorkoutPlanUncheckedUpdateManyWithoutCreatorInput
    assignedWorkoutPlans?: WorkoutPlanUncheckedUpdateManyWithoutAssignedToInput
    workouts?: WorkoutUncheckedUpdateManyWithoutAthleteInput
    coachLinks?: AthleteCoachUncheckedUpdateManyWithoutCoachInput
    athleteLinks?: AthleteCoachUncheckedUpdateManyWithoutAthleteInput
    SentMessages?: MessageUncheckedUpdateManyWithoutSenderInput
    ReceivedMessages?: MessageUncheckedUpdateManyWithoutReceiverInput
    workoutSessions?: WorkoutSessionUncheckedUpdateManyWithoutAthleteInput
  }

  export type UserCreateWithoutSentMessagesInput = {
    email: string
    passwordHash: string
    fullName: string
    role: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    createdWorkoutPlans?: WorkoutPlanCreateNestedManyWithoutCreatorInput
    assignedWorkoutPlans?: WorkoutPlanCreateNestedManyWithoutAssignedToInput
    workouts?: WorkoutCreateNestedManyWithoutAthleteInput
    weights?: WeightCreateNestedManyWithoutAthleteInput
    coachLinks?: AthleteCoachCreateNestedManyWithoutCoachInput
    athleteLinks?: AthleteCoachCreateNestedManyWithoutAthleteInput
    ReceivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    workoutSessions?: WorkoutSessionCreateNestedManyWithoutAthleteInput
  }

  export type UserUncheckedCreateWithoutSentMessagesInput = {
    id?: number
    email: string
    passwordHash: string
    fullName: string
    role: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    createdWorkoutPlans?: WorkoutPlanUncheckedCreateNestedManyWithoutCreatorInput
    assignedWorkoutPlans?: WorkoutPlanUncheckedCreateNestedManyWithoutAssignedToInput
    workouts?: WorkoutUncheckedCreateNestedManyWithoutAthleteInput
    weights?: WeightUncheckedCreateNestedManyWithoutAthleteInput
    coachLinks?: AthleteCoachUncheckedCreateNestedManyWithoutCoachInput
    athleteLinks?: AthleteCoachUncheckedCreateNestedManyWithoutAthleteInput
    ReceivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    workoutSessions?: WorkoutSessionUncheckedCreateNestedManyWithoutAthleteInput
  }

  export type UserCreateOrConnectWithoutSentMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
  }

  export type UserCreateWithoutReceivedMessagesInput = {
    email: string
    passwordHash: string
    fullName: string
    role: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    createdWorkoutPlans?: WorkoutPlanCreateNestedManyWithoutCreatorInput
    assignedWorkoutPlans?: WorkoutPlanCreateNestedManyWithoutAssignedToInput
    workouts?: WorkoutCreateNestedManyWithoutAthleteInput
    weights?: WeightCreateNestedManyWithoutAthleteInput
    coachLinks?: AthleteCoachCreateNestedManyWithoutCoachInput
    athleteLinks?: AthleteCoachCreateNestedManyWithoutAthleteInput
    SentMessages?: MessageCreateNestedManyWithoutSenderInput
    workoutSessions?: WorkoutSessionCreateNestedManyWithoutAthleteInput
  }

  export type UserUncheckedCreateWithoutReceivedMessagesInput = {
    id?: number
    email: string
    passwordHash: string
    fullName: string
    role: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    createdWorkoutPlans?: WorkoutPlanUncheckedCreateNestedManyWithoutCreatorInput
    assignedWorkoutPlans?: WorkoutPlanUncheckedCreateNestedManyWithoutAssignedToInput
    workouts?: WorkoutUncheckedCreateNestedManyWithoutAthleteInput
    weights?: WeightUncheckedCreateNestedManyWithoutAthleteInput
    coachLinks?: AthleteCoachUncheckedCreateNestedManyWithoutCoachInput
    athleteLinks?: AthleteCoachUncheckedCreateNestedManyWithoutAthleteInput
    SentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    workoutSessions?: WorkoutSessionUncheckedCreateNestedManyWithoutAthleteInput
  }

  export type UserCreateOrConnectWithoutReceivedMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
  }

  export type UserUpsertWithoutSentMessagesInput = {
    update: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
  }

  export type UserUpdateWithoutSentMessagesInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdWorkoutPlans?: WorkoutPlanUpdateManyWithoutCreatorInput
    assignedWorkoutPlans?: WorkoutPlanUpdateManyWithoutAssignedToInput
    workouts?: WorkoutUpdateManyWithoutAthleteInput
    weights?: WeightUpdateManyWithoutAthleteInput
    coachLinks?: AthleteCoachUpdateManyWithoutCoachInput
    athleteLinks?: AthleteCoachUpdateManyWithoutAthleteInput
    ReceivedMessages?: MessageUpdateManyWithoutReceiverInput
    workoutSessions?: WorkoutSessionUpdateManyWithoutAthleteInput
  }

  export type UserUncheckedUpdateWithoutSentMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdWorkoutPlans?: WorkoutPlanUncheckedUpdateManyWithoutCreatorInput
    assignedWorkoutPlans?: WorkoutPlanUncheckedUpdateManyWithoutAssignedToInput
    workouts?: WorkoutUncheckedUpdateManyWithoutAthleteInput
    weights?: WeightUncheckedUpdateManyWithoutAthleteInput
    coachLinks?: AthleteCoachUncheckedUpdateManyWithoutCoachInput
    athleteLinks?: AthleteCoachUncheckedUpdateManyWithoutAthleteInput
    ReceivedMessages?: MessageUncheckedUpdateManyWithoutReceiverInput
    workoutSessions?: WorkoutSessionUncheckedUpdateManyWithoutAthleteInput
  }

  export type UserUpsertWithoutReceivedMessagesInput = {
    update: XOR<UserUpdateWithoutReceivedMessagesInput, UserUncheckedUpdateWithoutReceivedMessagesInput>
    create: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
  }

  export type UserUpdateWithoutReceivedMessagesInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdWorkoutPlans?: WorkoutPlanUpdateManyWithoutCreatorInput
    assignedWorkoutPlans?: WorkoutPlanUpdateManyWithoutAssignedToInput
    workouts?: WorkoutUpdateManyWithoutAthleteInput
    weights?: WeightUpdateManyWithoutAthleteInput
    coachLinks?: AthleteCoachUpdateManyWithoutCoachInput
    athleteLinks?: AthleteCoachUpdateManyWithoutAthleteInput
    SentMessages?: MessageUpdateManyWithoutSenderInput
    workoutSessions?: WorkoutSessionUpdateManyWithoutAthleteInput
  }

  export type UserUncheckedUpdateWithoutReceivedMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdWorkoutPlans?: WorkoutPlanUncheckedUpdateManyWithoutCreatorInput
    assignedWorkoutPlans?: WorkoutPlanUncheckedUpdateManyWithoutAssignedToInput
    workouts?: WorkoutUncheckedUpdateManyWithoutAthleteInput
    weights?: WeightUncheckedUpdateManyWithoutAthleteInput
    coachLinks?: AthleteCoachUncheckedUpdateManyWithoutCoachInput
    athleteLinks?: AthleteCoachUncheckedUpdateManyWithoutAthleteInput
    SentMessages?: MessageUncheckedUpdateManyWithoutSenderInput
    workoutSessions?: WorkoutSessionUncheckedUpdateManyWithoutAthleteInput
  }

  export type WorkoutPlanCreateManyCreatorInput = {
    id?: number
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToId?: number | null
  }

  export type WorkoutPlanCreateManyAssignedToInput = {
    id?: number
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: number
  }

  export type WorkoutCreateManyAthleteInput = {
    id?: number
    date: Date | string
    durationMinutes: number
    notes?: string | null
    createdAt?: Date | string
    workoutPlanId?: number | null
  }

  export type WeightCreateManyAthleteInput = {
    id?: number
    weightKg: number
    date: Date | string
    createdAt?: Date | string
  }

  export type AthleteCoachCreateManyCoachInput = {
    id?: number
    athleteId: number
  }

  export type AthleteCoachCreateManyAthleteInput = {
    id?: number
    coachId: number
  }

  export type MessageCreateManySenderInput = {
    id?: number
    receiverId: number
    content: string
    createdAt?: Date | string
  }

  export type MessageCreateManyReceiverInput = {
    id?: number
    senderId: number
    content: string
    createdAt?: Date | string
  }

  export type WorkoutSessionCreateManyAthleteInput = {
    id?: number
    planId: number
    date?: Date | string
  }

  export type WorkoutPlanUpdateWithoutCreatorInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTo?: UserUpdateOneWithoutAssignedWorkoutPlansInput
    exercises?: WorkoutPlanExerciseUpdateManyWithoutPlanInput
    sessions?: WorkoutSessionUpdateManyWithoutPlanInput
    workouts?: WorkoutUpdateManyWithoutWorkoutPlanInput
  }

  export type WorkoutPlanUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    exercises?: WorkoutPlanExerciseUncheckedUpdateManyWithoutPlanInput
    sessions?: WorkoutSessionUncheckedUpdateManyWithoutPlanInput
    workouts?: WorkoutUncheckedUpdateManyWithoutWorkoutPlanInput
  }

  export type WorkoutPlanUncheckedUpdateManyWithoutCreatedWorkoutPlansInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WorkoutPlanUpdateWithoutAssignedToInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedWorkoutPlansInput
    exercises?: WorkoutPlanExerciseUpdateManyWithoutPlanInput
    sessions?: WorkoutSessionUpdateManyWithoutPlanInput
    workouts?: WorkoutUpdateManyWithoutWorkoutPlanInput
  }

  export type WorkoutPlanUncheckedUpdateWithoutAssignedToInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: IntFieldUpdateOperationsInput | number
    exercises?: WorkoutPlanExerciseUncheckedUpdateManyWithoutPlanInput
    sessions?: WorkoutSessionUncheckedUpdateManyWithoutPlanInput
    workouts?: WorkoutUncheckedUpdateManyWithoutWorkoutPlanInput
  }

  export type WorkoutPlanUncheckedUpdateManyWithoutAssignedWorkoutPlansInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: IntFieldUpdateOperationsInput | number
  }

  export type WorkoutUpdateWithoutAthleteInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workoutPlan?: WorkoutPlanUpdateOneWithoutWorkoutsInput
    workoutExercises?: WorkoutExerciseUpdateManyWithoutWorkoutInput
  }

  export type WorkoutUncheckedUpdateWithoutAthleteInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workoutPlanId?: NullableIntFieldUpdateOperationsInput | number | null
    workoutExercises?: WorkoutExerciseUncheckedUpdateManyWithoutWorkoutInput
  }

  export type WorkoutUncheckedUpdateManyWithoutWorkoutsInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workoutPlanId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WeightUpdateWithoutAthleteInput = {
    weightKg?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeightUncheckedUpdateWithoutAthleteInput = {
    id?: IntFieldUpdateOperationsInput | number
    weightKg?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeightUncheckedUpdateManyWithoutWeightsInput = {
    id?: IntFieldUpdateOperationsInput | number
    weightKg?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AthleteCoachUpdateWithoutCoachInput = {
    athlete?: UserUpdateOneRequiredWithoutAthleteLinksInput
  }

  export type AthleteCoachUncheckedUpdateWithoutCoachInput = {
    id?: IntFieldUpdateOperationsInput | number
    athleteId?: IntFieldUpdateOperationsInput | number
  }

  export type AthleteCoachUncheckedUpdateManyWithoutCoachLinksInput = {
    id?: IntFieldUpdateOperationsInput | number
    athleteId?: IntFieldUpdateOperationsInput | number
  }

  export type AthleteCoachUpdateWithoutAthleteInput = {
    coach?: UserUpdateOneRequiredWithoutCoachLinksInput
  }

  export type AthleteCoachUncheckedUpdateWithoutAthleteInput = {
    id?: IntFieldUpdateOperationsInput | number
    coachId?: IntFieldUpdateOperationsInput | number
  }

  export type AthleteCoachUncheckedUpdateManyWithoutAthleteLinksInput = {
    id?: IntFieldUpdateOperationsInput | number
    coachId?: IntFieldUpdateOperationsInput | number
  }

  export type MessageUpdateWithoutSenderInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: UserUpdateOneRequiredWithoutReceivedMessagesInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiverId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutSentMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiverId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutReceiverInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesInput
  }

  export type MessageUncheckedUpdateWithoutReceiverInput = {
    id?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutReceivedMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutSessionUpdateWithoutAthleteInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: WorkoutPlanUpdateOneRequiredWithoutSessionsInput
    sessionExercises?: WorkoutSessionExerciseUpdateManyWithoutSessionInput
  }

  export type WorkoutSessionUncheckedUpdateWithoutAthleteInput = {
    id?: IntFieldUpdateOperationsInput | number
    planId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionExercises?: WorkoutSessionExerciseUncheckedUpdateManyWithoutSessionInput
  }

  export type WorkoutSessionUncheckedUpdateManyWithoutWorkoutSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    planId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutPlanExerciseCreateManyPlanInput = {
    id?: number
    exerciseId: number
    orderIndex?: number
  }

  export type WorkoutSessionCreateManyPlanInput = {
    id?: number
    athleteId: number
    date?: Date | string
  }

  export type WorkoutCreateManyWorkoutPlanInput = {
    id?: number
    date: Date | string
    durationMinutes: number
    notes?: string | null
    createdAt?: Date | string
    athleteId: number
  }

  export type WorkoutPlanExerciseUpdateWithoutPlanInput = {
    orderIndex?: IntFieldUpdateOperationsInput | number
    exercise?: ExerciseUpdateOneRequiredWithoutPlanExercisesInput
  }

  export type WorkoutPlanExerciseUncheckedUpdateWithoutPlanInput = {
    id?: IntFieldUpdateOperationsInput | number
    exerciseId?: IntFieldUpdateOperationsInput | number
    orderIndex?: IntFieldUpdateOperationsInput | number
  }

  export type WorkoutPlanExerciseUncheckedUpdateManyWithoutExercisesInput = {
    id?: IntFieldUpdateOperationsInput | number
    exerciseId?: IntFieldUpdateOperationsInput | number
    orderIndex?: IntFieldUpdateOperationsInput | number
  }

  export type WorkoutSessionUpdateWithoutPlanInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    athlete?: UserUpdateOneRequiredWithoutWorkoutSessionsInput
    sessionExercises?: WorkoutSessionExerciseUpdateManyWithoutSessionInput
  }

  export type WorkoutSessionUncheckedUpdateWithoutPlanInput = {
    id?: IntFieldUpdateOperationsInput | number
    athleteId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionExercises?: WorkoutSessionExerciseUncheckedUpdateManyWithoutSessionInput
  }

  export type WorkoutSessionUncheckedUpdateManyWithoutSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    athleteId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutUpdateWithoutWorkoutPlanInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    athlete?: UserUpdateOneRequiredWithoutWorkoutsInput
    workoutExercises?: WorkoutExerciseUpdateManyWithoutWorkoutInput
  }

  export type WorkoutUncheckedUpdateWithoutWorkoutPlanInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    athleteId?: IntFieldUpdateOperationsInput | number
    workoutExercises?: WorkoutExerciseUncheckedUpdateManyWithoutWorkoutInput
  }

  export type WorkoutExerciseCreateManyExerciseInput = {
    id?: number
    workoutId: number
    orderIndex?: number
    notes?: string | null
  }

  export type WorkoutPlanExerciseCreateManyExerciseInput = {
    id?: number
    planId: number
    orderIndex?: number
  }

  export type WorkoutSessionExerciseCreateManyExerciseInput = {
    id?: number
    sessionId: number
    orderIndex?: number
  }

  export type WorkoutExerciseUpdateWithoutExerciseInput = {
    orderIndex?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    workout?: WorkoutUpdateOneRequiredWithoutWorkoutExercisesInput
    sets?: WorkoutSetUpdateManyWithoutWorkoutExerciseInput
  }

  export type WorkoutExerciseUncheckedUpdateWithoutExerciseInput = {
    id?: IntFieldUpdateOperationsInput | number
    workoutId?: IntFieldUpdateOperationsInput | number
    orderIndex?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sets?: WorkoutSetUncheckedUpdateManyWithoutWorkoutExerciseInput
  }

  export type WorkoutExerciseUncheckedUpdateManyWithoutWorkoutExercisesInput = {
    id?: IntFieldUpdateOperationsInput | number
    workoutId?: IntFieldUpdateOperationsInput | number
    orderIndex?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkoutPlanExerciseUpdateWithoutExerciseInput = {
    orderIndex?: IntFieldUpdateOperationsInput | number
    plan?: WorkoutPlanUpdateOneRequiredWithoutExercisesInput
  }

  export type WorkoutPlanExerciseUncheckedUpdateWithoutExerciseInput = {
    id?: IntFieldUpdateOperationsInput | number
    planId?: IntFieldUpdateOperationsInput | number
    orderIndex?: IntFieldUpdateOperationsInput | number
  }

  export type WorkoutPlanExerciseUncheckedUpdateManyWithoutPlanExercisesInput = {
    id?: IntFieldUpdateOperationsInput | number
    planId?: IntFieldUpdateOperationsInput | number
    orderIndex?: IntFieldUpdateOperationsInput | number
  }

  export type WorkoutSessionExerciseUpdateWithoutExerciseInput = {
    orderIndex?: IntFieldUpdateOperationsInput | number
    session?: WorkoutSessionUpdateOneRequiredWithoutSessionExercisesInput
    sets?: WorkoutSessionSetUpdateManyWithoutSessionExerciseInput
  }

  export type WorkoutSessionExerciseUncheckedUpdateWithoutExerciseInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: IntFieldUpdateOperationsInput | number
    orderIndex?: IntFieldUpdateOperationsInput | number
    sets?: WorkoutSessionSetUncheckedUpdateManyWithoutSessionExerciseInput
  }

  export type WorkoutSessionExerciseUncheckedUpdateManyWithoutSessionExercisesInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: IntFieldUpdateOperationsInput | number
    orderIndex?: IntFieldUpdateOperationsInput | number
  }

  export type WorkoutSessionExerciseCreateManySessionInput = {
    id?: number
    exerciseId: number
    orderIndex?: number
  }

  export type WorkoutSessionExerciseUpdateWithoutSessionInput = {
    orderIndex?: IntFieldUpdateOperationsInput | number
    exercise?: ExerciseUpdateOneRequiredWithoutSessionExercisesInput
    sets?: WorkoutSessionSetUpdateManyWithoutSessionExerciseInput
  }

  export type WorkoutSessionExerciseUncheckedUpdateWithoutSessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    exerciseId?: IntFieldUpdateOperationsInput | number
    orderIndex?: IntFieldUpdateOperationsInput | number
    sets?: WorkoutSessionSetUncheckedUpdateManyWithoutSessionExerciseInput
  }

  export type WorkoutSessionSetCreateManySessionExerciseInput = {
    id?: number
    setIndex?: number
    reps: number
    weightKg: number
    rpe?: number | null
    notes?: string | null
  }

  export type WorkoutSessionSetUpdateWithoutSessionExerciseInput = {
    setIndex?: IntFieldUpdateOperationsInput | number
    reps?: IntFieldUpdateOperationsInput | number
    weightKg?: FloatFieldUpdateOperationsInput | number
    rpe?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkoutSessionSetUncheckedUpdateWithoutSessionExerciseInput = {
    id?: IntFieldUpdateOperationsInput | number
    setIndex?: IntFieldUpdateOperationsInput | number
    reps?: IntFieldUpdateOperationsInput | number
    weightKg?: FloatFieldUpdateOperationsInput | number
    rpe?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkoutSessionSetUncheckedUpdateManyWithoutSetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    setIndex?: IntFieldUpdateOperationsInput | number
    reps?: IntFieldUpdateOperationsInput | number
    weightKg?: FloatFieldUpdateOperationsInput | number
    rpe?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkoutExerciseCreateManyWorkoutInput = {
    id?: number
    exerciseId: number
    orderIndex?: number
    notes?: string | null
  }

  export type WorkoutExerciseUpdateWithoutWorkoutInput = {
    orderIndex?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    exercise?: ExerciseUpdateOneRequiredWithoutWorkoutExercisesInput
    sets?: WorkoutSetUpdateManyWithoutWorkoutExerciseInput
  }

  export type WorkoutExerciseUncheckedUpdateWithoutWorkoutInput = {
    id?: IntFieldUpdateOperationsInput | number
    exerciseId?: IntFieldUpdateOperationsInput | number
    orderIndex?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sets?: WorkoutSetUncheckedUpdateManyWithoutWorkoutExerciseInput
  }

  export type WorkoutSetCreateManyWorkoutExerciseInput = {
    id?: number
    setIndex?: number
    reps: number
    weightKg: number
    rpe?: number | null
    notes?: string | null
  }

  export type WorkoutSetUpdateWithoutWorkoutExerciseInput = {
    setIndex?: IntFieldUpdateOperationsInput | number
    reps?: IntFieldUpdateOperationsInput | number
    weightKg?: FloatFieldUpdateOperationsInput | number
    rpe?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkoutSetUncheckedUpdateWithoutWorkoutExerciseInput = {
    id?: IntFieldUpdateOperationsInput | number
    setIndex?: IntFieldUpdateOperationsInput | number
    reps?: IntFieldUpdateOperationsInput | number
    weightKg?: FloatFieldUpdateOperationsInput | number
    rpe?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkoutSetUncheckedUpdateManyWithoutSetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    setIndex?: IntFieldUpdateOperationsInput | number
    reps?: IntFieldUpdateOperationsInput | number
    weightKg?: FloatFieldUpdateOperationsInput | number
    rpe?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}